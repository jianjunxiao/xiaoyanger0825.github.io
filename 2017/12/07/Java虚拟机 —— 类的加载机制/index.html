<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java虚拟机类的加载机制我们知道class文件中存储了类的描述信息和各种细节的数据，在运行Java程序时，虚拟机需要先将类的这些数据加载到内存中，并经过校验、转换、解析和初始化过后，最终形成可以直接使用的Java类型。 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。 类的加载机制实">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2017/12/07/Java虚拟机 —— 类的加载机制/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java虚拟机类的加载机制我们知道class文件中存储了类的描述信息和各种细节的数据，在运行Java程序时，虚拟机需要先将类的这些数据加载到内存中，并经过校验、转换、解析和初始化过后，最终形成可以直接使用的Java类型。 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。 类的加载机制实">
<meta property="og:image" content="http://i.imgur.com/2uatooQ.png">
<meta property="og:image" content="http://i.imgur.com/9bEPBkZ.png">
<meta property="og:image" content="http://i.imgur.com/NCkfOLT.png">
<meta property="og:updated_time" content="2017-08-11T05:50:48.284Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="Java虚拟机类的加载机制我们知道class文件中存储了类的描述信息和各种细节的数据，在运行Java程序时，虚拟机需要先将类的这些数据加载到内存中，并经过校验、转换、解析和初始化过后，最终形成可以直接使用的Java类型。 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。 类的加载机制实">
<meta name="twitter:image" content="http://i.imgur.com/2uatooQ.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java虚拟机 —— 类的加载机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/07/Java虚拟机 —— 类的加载机制/" class="article-date">
  <time datetime="2017-12-07T07:37:18.325Z" itemprop="datePublished">2017-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java虚拟机类的加载机制"><a href="#Java虚拟机类的加载机制" class="headerlink" title="Java虚拟机类的加载机制"></a>Java虚拟机类的加载机制</h2><p>我们知道class文件中存储了类的描述信息和各种细节的数据，在运行Java程序时，虚拟机需要先将类的这些数据加载到内存中，并经过校验、转换、解析和初始化过后，最终形成可以直接使用的Java类型。</p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。<br><img src="http://i.imgur.com/2uatooQ.png" alt="类的生命周期"></p>
<p>类的加载机制实际上就是类的生命周期中加载、验证、准备、解析、初始化5个过程。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类的加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>通过全限定名来获取二进制流可以有很多种方式，比如从JAR、EAR、WAR文件包中读取，从网络获取，也可以由其他文件来生成（jsp文件生成对应的Servlet类），甚至还可以通过运行时动态生成（Java动态代理）。</p>
<p>相比类加载过程的其他阶段，加载阶段是可控性最强的。因为开发者既可以利用系统提供的启动类加载器来完成，也可以通过自定义类加载去完成（重写<code>loadClass</code>方法，控制字节流的获取方式）。</p>
<p>关于类加载器的详细介绍将放在文章最后。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中。然后在内存中实例化一个<code>java.lang.Class</code>类的对象，这样就可以通过这个对象来访问方法区中的这些数据。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<ul>
<li>文件格式验证： 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的<br>3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</li>
<li>元数据验证： 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。这个主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</li>
<li>字节码验证： 对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</li>
<li>符号验证： 对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，这个阶段发生在将符号引用转化为直接引用的时候（解析阶段中发生），目的是确保解析动作能正常执行。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量（静态变量）分配内存并设置初始值的阶段，这些类变量所使用的内存都将在方法区中进行分配。</p>
<p>这里有两点需要注意：</p>
<ol>
<li>成员变量不是在这里分配内存的，成员变量是在类实例化对象的时候在堆中分配的。</li>
<li>这里设置初始值是指类型的零值（比如0，null，false等），而不是代码中被显示的赋予的值。</li>
</ol>
<p>比如：</p>
<pre><code>public class Test {
    public int number = 111;
    public static int sNumber = 111; 
}
</code></pre><p>成员变量<code>number</code>在这个阶段就不会进行内存分配和初始化。而类变量<code>sNunber</code>会在方法区中分配内存，并<strong>设置为int类型的零0而不是111</strong>，赋值为111是在初始化阶段才会执行。<br><img src="http://i.imgur.com/9bEPBkZ.png" alt="Java基本数据类型和引用数据类型零值"><br>但是呢，如果类变量如果是被final修饰，为静态常量，那么在准备阶段也会在方法区中分配内存，并且将其值设置为显示赋予的值。</p>
<p>比如：</p>
<pre><code>public class Test {
    public static final int NUMBER = 111; 
}
</code></pre><p>此时，就会在准备阶段将<code>NUMBER</code>的值设置为111。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用： 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li>直接引用： 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
</ul>
<p>解析动作主要就是在常量池中寻找类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符等7类符号引用，把这些符号引用替换为直接引用。下面主要介绍下类或接口、字段、类方法、接口方法的解析：</p>
<ol>
<li>类或接口解析： 假设当前的类<code>A</code>通过符号X引用了类<code>B</code>，虚拟机会把代表类<code>B</code>的全限定名传递给<code>A</code>的类加载器去加载<code>B</code>，<code>B</code>经过加载、验证、准备过程，在解析过程又可能会触发<code>B</code>引用的其他的类的加载过程，相当于一个类引用链的递归加载过程，整个过程只要不出现异常，<code>B</code>的就是一个加载成功的类或接口了，也就是可以获取到代表<code>B</code>的<code>java.lang.Class</code>对象。在验证了<code>A</code>具备对<code>B</code>的访问权限后，就将符号引用X替换为<code>B</code>的直接引用。</li>
<li>字段解析： 解析未被解析过的字段，要先解析字段所属的类或接口的符号引用。如果类本身就包含了简单的名称和字段描述与目标字段相匹配，就直接返回这个字段引用；如果实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段；如果是继承自其他类的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。</li>
<li>类方法解析：类方法解析和字段解析的方式类似，也是依据继承和实现关系从小到上搜索，只不过是先搜索类，后搜索接口。如果有简单名称和字段描述符都与目标相匹配的字段，就返回字段引用。</li>
<li>接口的方法解析： 与类方法解析类似，从小到上搜索接口（接口没有父类，只可能有父接口）。如果存在简单名称和字段描述符都与目标相匹配的字段，就返回字段引用。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类的初始化类加载过程的最后一步，在前面的过中，除了在加载阶段开发者可以自定义加载器之外，其余的动作都是完全有虚拟机主导和控制完成。到了初始化阶段，才真正开始执行类中定义的Java代码。</p>
<p>在准备阶段，类变量已经设置了系统要求的零值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<code>＜clinit＞()</code>方法的过程。</p>
<p><code>＜clinit＞()</code>方法是由编译器自动收集类中所有的类变量（<code>static</code>变量）和静态代码块（<code>static{}</code>块）中的语句合并生成的。编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态代码块中只能访问到定义在静态代码块之前的变量，定义在它之后的变量，在前面的静态代码块可以赋值，但是不能访问。</p>
<pre><code>public class Test {
    static {
        number = 111;               // 可以赋值
        System.out.println(number); // 不能读取，编辑器或报错Illegal forward reference
    }
    static int number;
}
</code></pre><p><code>＜clinit＞()</code>方法与类的构造函数（或者说实例构造器<code>＜init＞()</code>方法）不同，它不需要显式地调用父类的<code>＜clinit＞()</code>方法，虚拟机会保证在子类的<code>＜clinit＞()</code>方法执行之前，父类的<code>＜clinit＞()</code>方法已经执行完毕。所以，父类定义的静态代码块要先与子类的赋值操作。</p>
<pre><code>class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

class Sub extends Parent {
    public static int B = A;
    public static void main(String[] args) {
        System.out.println(Sub.B);
    }
}
</code></pre><p><code>＜clinit＞()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>＜clinit＞()</code>方法。</p>
<p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>＜clinit＞()</code>方法。但接口与类不同的是，执行接口的<code>＜clinit＞()</code>方法不需要先执行父接口的<code>＜clinit＞()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>＜clinit＞()</code>方法。</p>
<p>虚拟机会保证一个类的<code>＜clinit＞()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>＜clinit＞()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>＜clinit＞()</code>方法完毕。如果在一个类的<code>＜clinit＞()</code>方法中有耗时很长的操作，就可能造成多个进程阻塞。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>在之前的加载过程中，提到了类加载器通过一个类的全限定名来获取描述此类的二进制字节流，这个过程可以让开发中自定义类加载器来决定如何获取需要的字节流。那么，什么是类加载器呢？</p>
<p>对于任意一个Java类，都必须通过类加载器加载到方法区，并生成<code>java.lang.Class</code>对象才能使用类的各个功能，所以我们可以把类加载器理解为一个将<code>class</code>类文件转换为<code>java.lang.Class</code>对象的工具。</p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，如果两个类“相等”，那么这两个类必须是被同一个虚拟机中的同一个类加载器加载，并且来自同一个<code>class</code>文件。</p>
<p>在Java当中，已经有3个预制的类加载器，分别是<code>BootStrapClassLoader</code>、<code>ExtClassLoader、AppClassLoader</code>。</p>
<ul>
<li>BootStrapClassLoader： 启动类加载器，它是由C++来实现的，在Java程序中不能显氏的获取到。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下的类。</li>
<li>ExtClassLoader： 扩展类加载器，它是由sun.misc.Launcher$ExtClassLoader实现，负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库。开发者可以直接使用它。</li>
<li>AppClassLoader： 应用程序类加载器，由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。一般来说，开发者自定义的类就是由应用程序类加载器加载的。</li>
</ul>
<p><code>ExtClassLoader</code>作为类加载器，但它也是一个Java类，是由<code>BootStrapClassLoader</code>来加载的，所以，<code>ExtClassLoader</code>的parent是<code>BootStrapClassLoader</code>。但是由于<code>BootStrapClassLoader</code>是<code>c++</code>实现的，我们通过<code>ExtClassLoader.getParent</code>获取到的是<code>null</code>。同样地，<code>AppClassLoader</code>是由<code>ExtClassLoader</code>加载，<code>AppClassLoader</code>的parent是<code>ExtClassLoader</code>。</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        ClassLoader cl = Test.class.getClassLoader();
        while (cl != null) {
            System.out.println(cl);
            cl = cl.getParent();
        }
    }
}
</code></pre><p>打印结果：</p>
<pre><code>sun.misc.Launcher$AppClassLoader@232204a1
sun.misc.Launcher$ExtClassLoader@74a14482
</code></pre><p>同时我们可以定义自己的类加载器<code>CustomClassLoader</code>，那么它的parent肯定就是<code>AppClassLoader</code>了。类加载器的这种层次关系称为双亲委派模型。<br><img src="http://i.imgur.com/NCkfOLT.png" alt="类加载器"></p>
<h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系不是以继承的关系来实现，而是都使用递归的方式来调用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>ClassLoader的源码：</p>
<pre><code>protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class&lt;?&gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
</code></pre><p>先检查是否已经被加载过，若没有加载则调用父类加载器的<code>loadClass()</code>方法，依次向上递归。若父类加载器为空则说明递归到启动类加载器了。如果从父类加载器到启动类加载器的上层次的所有加载器都加载失败，则调用自己的<code>findClass()</code>方法进行加载。</p>
<p>使用双亲委派模型能使Java类随着加载器一起具备一种优先级的层次关系，保证同一个类只加载一次，避免了重复加载，同时也能阻止有人恶意替换加载系统类。</p>
<h5 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h5><p>一般地，在<code>ClassLoader</code>方法的<code>loadClass</code>方法中已经给开发者实现了双亲委派模型，在自定义类加载器的时候，只需要复写<code>findClass</code>方法即可。</p>
<pre><code>public class CustomClassLoader extends ClassLoader {

    private String root;

    public CustomClassLoader(String root) {
        this.root = root;
    }

    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        byte[] classData = loadClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] loadClassData(String name) {
        String fileName = root + File.separatorChar
                + name.replace(&apos;.&apos;, File.separatorChar)
                + &quot;.class&quot;;
        try {
            InputStream ins = new FileInputStream(fileName);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 1024;
            byte[] buffer = new byte[bufferSize];
            int length;
            while ((length = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, length);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre><p>新建一个类<code>com.xiao.U</code>，编译成class文件，放到桌面，来测试一下：</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        CustomClassLoader customClassLoader = new CustomClassLoader(&quot;C:\\Users\\PC\\Desktop&quot;);
        try {
            Class clazz = customClassLoader.loadClass(&quot;com.xiao.U&quot;);
            Object o = clazz.newInstance();
            System.out.println(o.getClass().getClassLoader());
        } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>打印结果：</p>
<pre><code>CustomClassLoader@1540e19d
</code></pre><p>自定义类加载器在可以实现服务端的热部署，在移动端比如android也可以实现热更新。</p>
<hr>
<p>参考：</p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">深入理解Java虚拟机（第二版）</a></li>
<li><a href="http://www.jianshu.com/p/808a36134da5" target="_blank" rel="noopener">Java 类加载机制详解</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/07/Java虚拟机 —— 类的加载机制/" data-id="cjaw66m580008zkv9vmx2ue35" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/07/Java虚拟机 —— 运行时数据区/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/12/07/Java虚拟机 —— 垃圾回收机制/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/07/Java类集框架 —— HashMap源码分析/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/12/07/Java类集框架 —— ArrayList源码分析/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/12/07/Java虚拟机 —— 运行时数据区/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/12/07/Java虚拟机 —— 类的加载机制/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/12/07/Java虚拟机 —— 垃圾回收机制/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>