<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java线程并发相关的优秀技术文章]]></title>
    <url>%2F2018%2F03%2F05%2FJava%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Java并发编程：Thread类的使用 Java并发编程：synchronized Java并发编程：Lock Java并发编程：volatile关键字解析 Java并发编程：深入剖析ThreadLocal Java并发编程：同步容器 Java并发编程：线程间协作的两种方式：wait、notify、notifyAll和Condition]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Charles抓取app数据包]]></title>
    <url>%2F2017%2F12%2F20%2F%E4%BD%BF%E7%94%A8Charles%E6%8A%93%E5%8F%96app%E6%95%B0%E6%8D%AE%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Charles是一款非常实用的抓包工具。它通过电脑端代理，拦截网络请求和响应来实现数据包的抓取。支持http/https。 安装Charles需要Java环境，在安装之前确保已有配置Java运行环境。然后到官网下载Charles并安装。破解的话，可以使用网友提供的工具： Charles 在线破解。 设置打开Charles抓包工具：电脑端设置代理：Proxy —&gt; Proxy Setting：端口号填写8888，并选中Enable transparent HTTP proxying。Android手机端设置：首选将手机和电脑连接在同一无线局域网上（同一个路由器）。然后利用cmd-ipconfig查看自己电脑的ip：然后在手机wifi连接中进行设置：这里代理设置选择手动，主机名即是电脑的局域网ip，端口号为电脑端Charles设置的端口号。 抓取http数据安卓上面的步骤就设置完成了。我们使用小米商城app来试一下抓取的数据包。手机端打开小米商城：同时监测电脑端Charles的数据抓取：需要自己筛选一下，可以看到红框中就是小米商城http请求的域名，点开可以看到详细的网络请求接口：点击选中对应的接口，在右侧可以看到抓包的结果，选中Contents可以看到抓取的内容，上部分为请求的数据包，有Headers、Cookie、请求体的Text/Hex/Form形式。下部分为响应的数据包。包括有Headers、响应结果Json、JsonText等形式。 抓取https数据包上面的方式只能抓取到http数据包，要抓https还需要安装证书。首先安装电脑端的CA证书：Help —&gt; SSL Proxyging —&gt; Install Charles Root Certificate：安装证书：下一步：将所有证书都放入下列储存 —&gt; 浏览 —&gt; 受信任的根证书颁发机构 —&gt; 确定 —&gt; 下一步：最后点击完成。 安卓手机端安卓证书：很多手机通过浏览器下载证书安装会提示无法安装，所以这里通过在电脑上下载好手机端的证书，传到手机上再来安装。 在浏览器中地址中输入chsl.pro/ssl，下载手机端证书并传到手机储存上：在手机设置里面找到系统安全/安全与隐私（小米5手机：设置 —&gt; 更多设置 —&gt; 系统安全）找到之前存放证书的位置，选择证书文件：输入证书名称charles，点击确定，安装完成。 通过小米商城lite的微信小程序来测试下抓取https数据包。打开微信小程序“小米商城Lite”，点击页面跳转。并监测Charles抓取的数据：可以看到这就抓取到了小米商城Lite小程序的https请求数据包。]]></content>
      <categories>
        <category>抓包工具</category>
      </categories>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架 —— HashSet、LinkedHashSet源码分析]]></title>
    <url>%2F2017%2F09%2F21%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E2%80%94%E2%80%94-HashSet%E3%80%81LinkedHashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言HashSet实现了Set接口，它的底层是由HashMap来支持的。HashSet的元素实际上是存储在底层HashMap的key上的。由于HashMap的无序不重复特性，HashSet存储的元素也是无序的，并且元素也不能重复，同时也只允许存储一个null元素。 HashSet源码分析主要属性：1234// HashSet底层mapprivate transient HashMap&lt;E,Object&gt; map;// 虚拟对象private static final Object PRESENT = new Object(); HashSet是通过HashMap来保存元素，由于只需要在key中保存，所以采用虚拟对象PRESENT对应map中插入key-value的value值的引用。每次向map中添加元素时，键值对对应的value都是PRESENT。 构造函数：123456789101112131415161718192021// 默认无参构造public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;// 根据已有集合元素来构造HashSetpublic HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;// 给定初始容量public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;// 给定初始容量和加载因子public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;// 这个构造函数外部不能调用，供LinkedHashSet复写HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 构造函数都是初始map，以便加入元素的时候存储。 重要方法：1234567891011121314151617181920212223242526272829// 集合大小public int size() &#123; return map.size();&#125;// 集合是否为空public boolean isEmpty() &#123; return map.isEmpty();&#125;// 添加元素public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;// 移除元素public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;// 清空集合public void clear() &#123; map.clear();&#125;// 集合中是否有元素opublic boolean contains(Object o) &#123; return map.containsKey(o);&#125; HashSet的增删改查，同时直接操作map来完成的，代码都非常简单。 LinkedHashSetLinkedHashSet继承自HashSet，它的构造方法：12345678910111213141516public LinkedHashSet() &#123; super(16, .75f, true);&#125;public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true);&#125;public LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);&#125;public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123; super(Math.max(2*c.size(), 11), .75f, true); addAll(c);&#125; LinkedHashSet构造方法调用了父类HashSet的这个构造方法：1234// LinkedHashSet复写，初始化LinkedHashMapHashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 所以，它的底层是一个LinkedHashMap，元素的所有操作都是由LinkedHashMap来维护。LinkedHashSet与HashSet的区别和LinkedHashMap与HashMap的区别一样，LinkedHashMap和LinkedHashSet是有序的，内部由双向链表来记录顺序，而HashMap和HashSet都是无序的。 最后对于HashSet/LinkedHashSet，只要阅读过HashMap/LinkedHashMap的源码，基本上就能完全了解它的实现原理。HashSet/LinkedHashSet中数据的存入、删除、访问都是都是直接操作内部的HashMap，可以说HashSet/LinkedHashSet是在HashMap/LinkedHashMap的基础上加了一层壳。他们唯一的区别就是HashSet/LinkedHashSet保存的元素时单个的数据或对象，而HashMap/LinkedHashMap保存的元素时键值对。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架 —— LinkedHashMap源码分析]]></title>
    <url>%2F2017%2F09%2F21%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E2%80%94%E2%80%94-LinkedHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言我们知道HashMap底层是采用数组+单向线性链表/红黑树来实现的，HashMap在扩容或者链表与红黑树转换过程时可能会改变元素的位置和顺序。如果需要保存元素存入或访问的先后顺序，那就需要采用LinkedHashMap了。 LinkedHashMap结构LinkedHashMap继承自HashMap，它的所有操作和HashMap类似，底层结构也和HashMap一样，只不过为了维护元素的存入/访问顺序，增加了一个双向链表。 LinkedHashMap由数组、单向线性链表、红黑树、双向线性链表组成。如上图：灰色区域为数组，蓝色节点和蓝色箭头为单向链表的引用关系，绿色节点和绿色箭头为红黑树的引用关系，节点中的数字依次表示元素的存入/访问顺序，由橙色的双向箭头表示双向链表的引用关系。 注：在JDK1.7及之前HashMap中没有红黑树，LinkedHashMap中也不存在红黑树。另在JDK1.6及之前，HashMap中的链表为单向环形链表，LinkedHashMap中中的单向链表和双向链表都是环形链表。在JDK1.8，LinkedHashMap中可能会存在红黑树，同时单向链表和双向链表都是线性的。本文是基于JDK1.8来分析的。 LinkedHashMap源码分析基本属性：123transient LinkedHashMap.Entry&lt;K,V&gt; head; // 双向链表头节点transient LinkedHashMap.Entry&lt;K,V&gt; tail; // 双向链表尾节点final boolean accessOrder; // 是否按照访问顺序排序 head和tail分别记录了双向链表的头节点和尾节点，遍历时通过head或tail就可以按照存入/访问的顺序来取数据。 accessOrder用以表示LinkedHashMap是否按照访问顺序来排序，为true的话表示按照访问顺序排序，为false表示按照存入顺序排序，默认为false。 构造函数：12345678910111213141516171819202122// 无参构造public LinkedHashMap() &#123; super(); accessOrder = false;&#125;// 给定初始容量public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;// 给定初始容量和加载因子public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;// 给定初始容量、加载因子、是否按访问先后排序public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 构造函数都是调用父类HashMap的构造函数。前3个都默认accessOrder为false，LinkedHashMap内部按照存入顺序排序。最后一个构造函数可以指定accessOrder的值。 增： LinkedHashMap添加数据要调用了父类的HashMap的put方法，在HashMap的源码中，put方法存入元素后，调用了afterNodeAccess和afterNodeInsertion方法，这两个方法在HashMap中都是空方法，LinkedHashMap实现了这两个方法：12345678910111213141516171819202122232425void afterNodeAccess(Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; last; // 如果按照访问顺序排序，并且添加的元素e不是双向链表的尾节点 if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; afterNodeAccess方法的逻辑就是将当前节点e移动到双向链表的尾部。每次LinkedHashMap中有元素被访问时，就会按照访问先后来排序，先访问的在双向链表中靠前，越后访问的越接近尾部。当然只有当accessOrder为true时，才会执行这个操作。1234567void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; afterNodeInsertion方法意思是evict为true时删除双向链表的头节点。 通过afterNodeAccess和afterNodeInsertion这两个方法，如果当LinkedHashMap的容量达到一定量时，需要保存它的size不变，那么每次添加一个元素到双向链表的尾部，就要删除一个双向链表头部的元素，这相当于实现了LruCache的策略。 删： 删除元素同样也是调用了HashMap的remove方法，在remove方法中，调用了afterNodeRemoval方法。12345678910111213void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; afterNodeRemoval方法就是将e节点从双向链表中删除，更改e前后节点引用关系，使之重新连成完整的双向链表。 改： LinkedHashMap更改元素的value值，仍是调用put方法，涉及到的逻辑可以看上面的afterNodeAccess和afterNodeInsertion这两个方法。 查： LinkedHashMap自己实现了get方法。12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 逻辑非常简单，直接调用HashMap的getNode方法，如果需要按照访问先后排序，调用afterNodeAccess更新双向链表排序。 总结LinkedHashMap继承了HashMap的所有特性，唯一的区别就是LinkedHashMap是一个有序的映射集合，而HashMap则是无序的。LinkedHashMap实现排序的原理就是再内部增加了一个双向链表来记录元素的存入/访问顺序。LinkedHashMap内部是记录的是存入还是访问顺序取决于关键属性accessOrder，默认是按存入顺序记录。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架 —— HashMap源码分析]]></title>
    <url>%2F2017%2F09%2F18%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E2%80%94%E2%80%94-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述HashMap是基于Map的键值对映射表，底层是通过数组、链表、红黑树（JDK1.8加入）来实现的。 HashMap结构HashMap中存储元素，是将key和value封装成了一个Node，先以一个Node数组的来存储，通过key的hashCode来计算hash值，根据hash值和HashMap的大小确定存入元素在数组中的位置。当hashCode相同时，即产生了相同的数组索引位置，那么就会通过单向链表的形式来继续存储。12345678910111213141516static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; // 省略部分代码... &#125; HashMap中所有的映射都保存在节点Node中，同时为了解决发生hash碰撞的冲突，节点可以持有下一个节点的引用，以形成一个单向链表。 在JDK1.8，HashMap又做了一些改动，当数组table某个索引位置的上链表的长度大于8的话，则会将链表转化为红黑树。1234567891011121314static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // 省略部分代码... &#125; 同样地，映射的key-value就保存在TreeNode中。parent、left、right持有相应节点的引用形成红黑树。 HashMap源码分析主要属性：1234transient Node&lt;K,V&gt;[] table; // 数组transient int size; // 大小int threshold // 扩容阈值final float loadFactor; // 加载因子，默认值为0.75 构造方法：123456789101112131415161718192021222324252627282930313233// 使用默认的初始容量和加载因子public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125;// 指定初始容量，使用默认的加载因子public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;// 用现有的Map来构造一个新的HashMappublic HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125;// 根据自定义的初始容量和加载因子来构造HashMappublic HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123; initialCapacity = MAXIMUM_CAPACITY; &#125; else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123; initialCapacity = DEFAULT_INITIAL_CAPACITY; &#125; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); threshold = initialCapacity; init();&#125; 构造函数主要是设置HashMap的初始容量，以及扩容的加载因子。HashMap(Map&lt;? extends K, ? extends V&gt; m)构造函数根据已有的映射来构造新的HashMap，它同样采用的默认的加载因子，并将m中的元素添加到新构造的HashMap中。 数据存放：1234567891011121314151617181920212223public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true);&#125;final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; putAll方法直接调用putMapEntries。putMapEntries方法中先根据已有的Map中的元素数量对新构造的HashMap进行扩容，然后遍历旧的Map，取出元素存放到新的HashMap中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 存放key-valuepublic V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;// 根据key的hashCode来计算hash值static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table为null的话，进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 根据（n-1）&amp;hash来计算出元素在数组中的位置i if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果数组中该位置没有元素，即tab[i]==null,则直接构建Node存放在该位置 tab[i] = newNode(hash, key, value, null); else &#123; // tab[i]不为null Node&lt;K,V&gt; e; K k; // 如果数组中已有的节点tab[i]与需要新存入的元素的key相同，则直接替换掉tab[i] if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) // 如果tab[i]为红黑树节点，则直接存入红黑树 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // tab[i]为链表的第一个节点，遍历链表，将新的节点加入到链表的末尾 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 如果链表的长度大于阈值，则将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果链表中存在与新加入的元素key相同，则直接替换掉 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 添加完成后，检查是否需要扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; put方法的主要逻辑：根据添加节点的hash值计算计算它在数组中的位置i，判断tab[i]是否为空，为空则直接加入；不为空的话，需要判断该节点的key是否与新加入的节点的key相同，相同的话直接替换；如果不同则需要判断tab[i]节点是否是红黑树节点，如果是红黑树节点，则直接加入到红黑树中；如果不是红黑树节点，那肯定就是链表的第一个节点了，遍历链表，在遍历的过程中还需要判断是否与链表中已有节点的key相同，如果相同，同样直接替换掉，都不同的话就直接添加到链表的末尾。并且呢，加入链表后还需要判断链表的长度是否超过了阈值8，超过了的话，需要将链表转换为红黑树。 HashMap在添加数据的时候，会判断当前数据量是否超过设定的阈值，如果超过的话会进行扩容，在扩容过程中会将已添加的数据进行重新添加，以致原来添加元素的顺序和位置都改变了，所以HashMap不能保证元素的存入取出顺序。 删除数据：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 根据key删除数据public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;// 根据key-value删除数据@Overridepublic boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null;&#125;// 删除节点final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 根据hash值得到数组索引位置的节点p if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // p节点的key与需要删除的节点的key相同的话，则说明p就是需要删除的节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 赋值给node else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) // p节点为红黑树节点，从红黑树中获取匹配的删除节点 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; // p节点为链表的第一个节点，遍历链表，找到匹配的删除节点 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 匹配的删除节点node不为null的话，删除node if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) // 从红黑树中删除 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) // 从数组中删除 tab[index] = node.next; else // 从链表中删除 p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; remove的逻辑和加入元素的逻辑相似，依次从数组、红黑树、链表中找到匹配的删除节点来删除。 clear方法：123456789public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125;&#125; clear方法要简单些，直接遍历数组tab，将数组中所有元素都置空即可。 最后对于HashMap，我们只要知道了它的底层结构，要理解它的实现原理还是非常简单。在JDK1.8之后，加入了红黑树的结构，使HashMap的效率比之前的版本又优化了很多，关于链表转化为红黑树，以及红黑树转链表的具体实现等细节后续再做分析。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架 —— LinkedList源码分析]]></title>
    <url>%2F2017%2F09%2F14%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E2%80%94%E2%80%94-LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在JDK1.7之前，LinkedList是采用双向环形链表来实现的，在1.7及之后，Oracle将LinkedList做了优化，将环形链表改成了线性链表。本文对于LinkedList的源码分析基于JDK1.8。 LinkedList既然是通过一个双向线性链表来实现，那么肯定就能够很轻易的找到链表的第一个节点和最后一个节点，在源码中可以看到有这两个字段：12transient Node&lt;E&gt; first; // 链表第一个节点transient Node&lt;E&gt; last; // 链表最后一个节点 先来看一下什么是节点Node：1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 节点Node中有三个成员： item ： 存储的元素 next ： 下一个节点 prev ： 上一个节点 节点中保存有需要存储的元素，同时持有上一个节点和下一个节点的引用，各个节点依次持有前后节点的引用就形成了一个链，这样，当我们需要查找链中某一个节点保存的元素时，只需要通过第一个节点或者最后一个节点依次查找，就可以找到我们需要的节点。 需要注意的是，在JDK1.7及之后，第一个节点first的前一个节点prev为null，最后一个节点last的后一个节点next也为null。而在JDK1.6及之前，头节点header是一个不保存元素的节点，header的下一个节点next是第一个元素节点，而header的上一个节点是最后一个元素节点，这样使得它形成一个环形的双向链表。 LinkedList的构造函数有两个，一个无参，另一个可以传入一个集合：1234567public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 看下addAll方法的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查是否越界 checkPositionIndex(index); // 将集合c转化为数组a Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; // pred为插入元素位置点前一个节点，succ为插入元素位置的后一个节点 Node&lt;E&gt; pred, succ; if (index == size) &#123; // index==size的话，在链表的末尾添加元素 succ = null; pred = last; &#125; else &#123; // 否则的话，从链表中间加入 succ = node(index); pred = succ.prev; &#125; // 遍历需要加入的元素数组a for (Object o : a) &#123; // 通过元素o构造一个节点Node @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) // 插入位置的前一个节点为null，说明需要插入的是first节点 first = newNode; else // 插入位置的前一个节点不为null，即从链表中或链表末尾插入 // 将要插入的节点复制给插入位置的上一个节点的next pred.next = newNode; // 将newNode赋值给下个需要插入的节点的pred pred = newNode; &#125; if (succ == null) &#123; // succ为null，说明是从末尾添加的元素，将添加的最后一个元素赋值给last last = pred; &#125; else &#123; // 从链表中某个位置添加的，重新连接上添加元素时断开的引用链 pred.next = succ; succ.prev = pred; &#125; // 更新链表的大小 size += numNew; modCount++; return true;&#125; 在构造方法中调用addAll方法，相当于是向一个空链表中添加集合c中的元素。 如果是在已有元素的链表中调用addAll方法来添加元素的话，就需要判断指定的添加位置index是否越界，如果越界会抛出异常；如果没有越界，根据添加的位置index，断开链表中index位置的节点前后的引用，加入新元素，重新连上断开位置的前后节点的引用。过程如下图： add方法:1234public boolean add(E e) &#123; linkLast(e); return true;&#125; 直接就调用了linkLast方法，说明默认的add方法是直接将元素添加到已有的链表的末尾。1234567891011void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 新加入元素的节点赋值给last节点，然后判断了一下加入之前的last节点是否为空，为空的话，说明链表中没有元素，新加入的就是链表的first节点；不为空直接将之前的最后一个节点的next引用添加的节点即可。 还有一个add方法，指定了添加位置：12345678public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; 这里需要先判断是否越界，再看添加的位置是否在已有链表的末尾，如果在末尾就直接添加到末尾，不在末尾的话，调用linkBefore添加到index位置的节点之前。123456789101112void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; pred为null的话，说明succ是添加元素前链表的first节点，加入元素e，更新first节点，并更改引用链。 addFirst和addLast方法中分别调用了linkFirst方法和linkLast方法：1234567891011121314151617181920212223private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; linkFirst/linkLast方法即是将新节点添加到链表的头部或者尾部，更新链表的prev和next引用。 remove方法：123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 不管需要移除的元素O是否为空，都是遍历后调用unlink方法来删除节点，继续看unlink方法：1234567891011121314151617181920212223242526272829E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; // 如果prev为null的话，那么删除的是first节点，将next指定为删除后的first节点 first = next; &#125; else &#123; // prev不为null，将prev的next引用指向next，并解除x元素对prev的引用 prev.next = next; x.prev = null; &#125; if (next == null) &#123; // 如果next为null，那么删除的是last节点，将prev指定为删除后的last节点 last = prev; &#125; else &#123; // next不为null，将next的prev引用指向prev，并解除x的next引用 next.prev = prev; x.next = null; &#125; // 置空x节点中的元素 x.item = null; size--; modCount++; return element;&#125; removeFirst和removeLast方法同样是直接调用了unlinkFirst和unlinkLast，实现和unlink差不多，不做过多解释。 set方法，set方法即修改链表中指定位置的元素：1234567public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; 找到指定位置的节点x，更改该节点的item属性就行了。 看下获取节点的node方法：123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; // 靠近头部 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; // 靠近尾部 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 判断位置index是靠近头部还是尾部，靠近头部，则从first节点往后遍历，靠近尾部则从last节点往前遍历，这种方式可以使得链表查找的时候遍历次数不会超过链表长度的一半，从而提升查找效率。 get、getFirst、getLast方法：123456789101112131415161718public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; getFirst和getLast直接后去first和last节点中的元素值，get方法则直接调用了node方法，不再解释。 LinkedList源码中的其他方法不再分析了，实现都很容易理解。从LinkedList的增、删、改、查等方法的实现逻辑可以看出来，LinkedList的增和删效率相对于改和查要高，因为每次修改和查询都要从链表的头节点或尾节点开始遍历，而增加和删除，只需要在制定位置断开节点引用，添加和删除元素后，重新连上引用链即可。所以，LinkedList适合用在添加和删除比较频繁，而修改和查询较少的情况下。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架 —— ArrayList源码分析]]></title>
    <url>%2F2017%2F09%2F13%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E2%80%94%E2%80%94-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList可以说是在Java开发中最常用的集合容器了，今天就来分析一下ArrayList的源码，可以更加深入的理解ArrayList实现原理。 ArrayList的成员变量：12345678910// 初始容量:10private static final int DEFAULT_CAPACITY = 10;// 空数组，没有元素数据private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;// 空数组，默认容量为空，没有元素数据private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;// 数组，用来存储ArrayList的元素transient Object[] elementData;// size为ArrayList的大小，在elementData不为空数组的情况下，size是小于elementData.length的private int size; 根据elementData也能看出来，ArrayList的内部是通过数组来实现的，ArrayList对元素的增删改查实际上都是对数组的操作。 ArrayList的构造函数：12345678910111213141516171819202122232425public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 构造ArrayList时，可以指定容器的初始容量initialCapacity，构造一个给定初始大小的数组作为数据集；使用无参构造时，则默认容量为空的数组作为初始数据集；也可以使用其他任意的集合Collection作为构造参数，可以看到，源码中就是直接将集合c转换数组来作为数据集（如果数据集是非Object数组，比如多维数组，则将元素拷贝到数据集数组中）。ArrayList的构造实际上就是对其内部数组的初始化。 add方法：1234567891011121314151617181920public boolean add(E e) &#123; // 确保当前数据集数组能够放得下新加入的元素 ensureCapacityInternal(size + 1); // Increments modCount!! // 将列表大小size自增1，并在数据集数组中放入元素e elementData[size++] = e; return true;&#125;public void add(int index, E element) &#123; // 检查新加入的位置index是否越界 rangeCheckForAdd(index); // 确保当前数据集数组能够放得下新加入的元素，如果需要扩容的话就扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将index位置及后面的元素都向后移动一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 将index位置的元素设置为新建如的element elementData[index] = element; size++;&#125; 在添加元素时，如果不指定加入的位置，会添加到内部数组中已有元素的最后一位，也就是添加到了ArrayList的末尾。如果指定了添加位置index，判断index是否越界，是否需要扩容，最后移动index位置后的元素，并将index位置设置为新添加的元素。 需要注意的是，添加的元素并没有判空，所以ArrayList中的元素是可以为null的。 在add方法中，都调用了ensureCapacityInternal(int minCapacity)这个方法来确保数据集数组能够放得下新的元素：1234567891011121314private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code // 如果添加新元素需要的最小容量大于数组的长度，就需要扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 看下扩容的方法grow(int minCapacity)：12345678910111213private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 扩展至新的容量newCapacity为旧的容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 将之前的数组中的元素复制到扩展后的新的数组中 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 数组扩容的过程，实际上是新建了一个需要扩容的长度的数组，然后将原素组中的元素拷贝到这个新建的数组中，新的数组指定为ArrayList内部数据集数组。 总结：ArrayList在添加元素时，首先会判断添加的位置是否在内部数组中越界，如果越界，抛出异常；如果没有越界，则判断数组能否放得下新添加的元素，如果放得下，则直接存放到数组中；如果放不下，则将数组扩容，扩容后再存放到数组中。 remove方法：12345678910111213141516public E remove(int index) &#123; // 检查越界 rangeCheck(index); modCount++; // 需要移除的元素 E oldValue = elementData(index); // 需要移动位置的元素的数量 int numMoved = size - index - 1; // 将需要移除元素的位置后的所有元素复制到index位置开始后的numMoved个位置 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // size减1，并将之前的最后一个位置元素置空 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; remove还有一个重载的方法，是移除给定的元素，它的实现就是遍历数组，找到元素的索引值，然后调用remove(int index)方法，根据索引值去删除。 总结：ArrayList在删除元素时，根据删除的索引值判断是否越界，如果越界，抛出异常；如果没有越界，取出要删除的元素，然后将这个元素后面所有的元素向前移动一位。 set方法：123456public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; set方法即修改列表中指定位置的元素值。它的实现非常简单：直接修改数组指定位置的值。 get方法：12345678public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; get方法实现非常简单只需要堆获取位置判断是否越界，然后直接从数组中取值即可。 从上面分析的源码中可以看出，ArrayList的实现就是对数组的操作，在添加和删除元素的时候，会涉及到数组的扩容和数组元素位置的移动，相对查询和修改元素要复杂一些，所以ArrayList适合用在查询和修改比较频繁，而添加和删除较少的情况下。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机 —— 类的加载机制]]></title>
    <url>%2F2017%2F08%2F10%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA-%E2%80%94%E2%80%94-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[我们知道class文件中存储了类的描述信息和各种细节的数据，在运行Java程序时，虚拟机需要先将类的这些数据加载到内存中，并经过校验、转换、解析和初始化过后，最终形成可以直接使用的Java类型。 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。 类的加载机制实际上就是类的生命周期中加载、验证、准备、解析、初始化5个过程。 加载加载是类的加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 通过全限定名来获取二进制流可以有很多种方式，比如从JAR、EAR、WAR文件包中读取，从网络获取，也可以由其他文件来生成（jsp文件生成对应的Servlet类），甚至还可以通过运行时动态生成（Java动态代理）。 相比类加载过程的其他阶段，加载阶段是可控性最强的。因为开发者既可以利用系统提供的启动类加载器来完成，也可以通过自定义类加载去完成（重写loadClass方法，控制字节流的获取方式）。 关于类加载器的详细介绍将放在文章最后。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中。然后在内存中实例化一个java.lang.Class类的对象，这样就可以通过这个对象来访问方法区中的这些数据。 验证验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 文件格式验证： 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。 元数据验证： 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。这个主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。 字节码验证： 对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号验证： 对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，这个阶段发生在将符号引用转化为直接引用的时候（解析阶段中发生），目的是确保解析动作能正常执行。 准备准备阶段是正式为类变量（静态变量）分配内存并设置初始值的阶段，这些类变量所使用的内存都将在方法区中进行分配。 这里有两点需要注意： 成员变量不是在这里分配内存的，成员变量是在类实例化对象的时候在堆中分配的。 这里设置初始值是指类型的零值（比如0，null，false等），而不是代码中被显示的赋予的值。 比如：1234public class Test &#123; public int number = 111; public static int sNumber = 111; &#125; 成员变量number在这个阶段就不会进行内存分配和初始化。而类变量sNunber会在方法区中分配内存，并设置为int类型的零0而不是111，赋值为111是在初始化阶段才会执行。但是呢，如果类变量如果是被final修饰，为静态常量，那么在准备阶段也会在方法区中分配内存，并且将其值设置为显示赋予的值。 比如：123public class Test &#123; public static final int NUMBER = 111; &#125; 此时，就会在准备阶段将NUMBER的值设置为111。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用： 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 直接引用： 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 解析动作主要就是在常量池中寻找类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符等7类符号引用，把这些符号引用替换为直接引用。下面主要介绍下类或接口、字段、类方法、接口方法的解析： 类或接口解析： 假设当前的类A通过符号X引用了类B，虚拟机会把代表类B的全限定名传递给A的类加载器去加载B，B经过加载、验证、准备过程，在解析过程又可能会触发B引用的其他的类的加载过程，相当于一个类引用链的递归加载过程，整个过程只要不出现异常，B的就是一个加载成功的类或接口了，也就是可以获取到代表B的java.lang.Class对象。在验证了A具备对B的访问权限后，就将符号引用X替换为B的直接引用。 字段解析： 解析未被解析过的字段，要先解析字段所属的类或接口的符号引用。如果类本身就包含了简单的名称和字段描述与目标字段相匹配，就直接返回这个字段引用；如果实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段；如果是继承自其他类的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。 类方法解析：类方法解析和字段解析的方式类似，也是依据继承和实现关系从小到上搜索，只不过是先搜索类，后搜索接口。如果有简单名称和字段描述符都与目标相匹配的字段，就返回字段引用。 接口的方法解析： 与类方法解析类似，从小到上搜索接口（接口没有父类，只可能有父接口）。如果存在简单名称和字段描述符都与目标相匹配的字段，就返回字段引用。 初始化类的初始化类加载过程的最后一步，在前面的过中，除了在加载阶段开发者可以自定义加载器之外，其余的动作都是完全有虚拟机主导和控制完成。到了初始化阶段，才真正开始执行类中定义的Java代码。 在准备阶段，类变量已经设置了系统要求的零值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞()方法的过程。 ＜clinit＞()方法是由编译器自动收集类中所有的类变量（static变量）和静态代码块（static{}块）中的语句合并生成的。编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态代码块中只能访问到定义在静态代码块之前的变量，定义在它之后的变量，在前面的静态代码块可以赋值，但是不能访问。1234567public class Test &#123; static &#123; number = 111; // 可以赋值 System.out.println(number); // 不能读取，编辑器或报错Illegal forward reference &#125; static int number;&#125; ＜clinit＞()方法与类的构造函数（或者说实例构造器＜init＞()方法）不同，它不需要显式地调用父类的＜clinit＞()方法，虚拟机会保证在子类的＜clinit＞()方法执行之前，父类的＜clinit＞()方法已经执行完毕。所以，父类定义的静态代码块要先与子类的赋值操作。12345678910111213class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;class Sub extends Parent &#123; public static int B = A; public static void main(String[] args) &#123; System.out.println(Sub.B); &#125;&#125; ＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞()方法。但接口与类不同的是，执行接口的＜clinit＞()方法不需要先执行父接口的＜clinit＞()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞()方法。 虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。如果在一个类的＜clinit＞()方法中有耗时很长的操作，就可能造成多个进程阻塞。 类加载器在之前的加载过程中，提到了类加载器通过一个类的全限定名来获取描述此类的二进制字节流，这个过程可以让开发中自定义类加载器来决定如何获取需要的字节流。那么，什么是类加载器呢？ 对于任意一个Java类，都必须通过类加载器加载到方法区，并生成java.lang.Class对象才能使用类的各个功能，所以我们可以把类加载器理解为一个将class类文件转换为java.lang.Class对象的工具。 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，如果两个类“相等”，那么这两个类必须是被同一个虚拟机中的同一个类加载器加载，并且来自同一个class文件。 在Java当中，已经有3个预制的类加载器，分别是BootStrapClassLoader、ExtClassLoader、AppClassLoader。 BootStrapClassLoader： 启动类加载器，它是由C++来实现的，在Java程序中不能显氏的获取到。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下的类。 ExtClassLoader： 扩展类加载器，它是由sun.misc.Launcher$ExtClassLoader实现，负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库。开发者可以直接使用它。 AppClassLoader： 应用程序类加载器，由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。一般来说，开发者自定义的类就是由应用程序类加载器加载的。 ExtClassLoader作为类加载器，但它也是一个Java类，是由BootStrapClassLoader来加载的，所以，ExtClassLoader的parent是BootStrapClassLoader。但是由于BootStrapClassLoader是c++实现的，我们通过ExtClassLoader.getParent获取到的是null。同样地，AppClassLoader是由ExtClassLoader加载，AppClassLoader的parent是ExtClassLoader。123456789public class Test &#123; public static void main(String[] args) &#123; ClassLoader cl = Test.class.getClassLoader(); while (cl != null) &#123; System.out.println(cl); cl = cl.getParent(); &#125; &#125;&#125; 打印结果：12sun.misc.Launcher$AppClassLoader@232204a1sun.misc.Launcher$ExtClassLoader@74a14482 同时我们可以定义自己的类加载器CustomClassLoader，那么它的parent肯定就是AppClassLoader了。类加载器的这种层次关系称为双亲委派模型。 双亲委派模型双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系不是以继承的关系来实现，而是都使用递归的方式来调用父加载器的代码。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 ClassLoader的源码：1234567891011121314151617181920212223242526272829303132333435protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，依次向上递归。若父类加载器为空则说明递归到启动类加载器了。如果从父类加载器到启动类加载器的上层次的所有加载器都加载失败，则调用自己的findClass()方法进行加载。 使用双亲委派模型能使Java类随着加载器一起具备一种优先级的层次关系，保证同一个类只加载一次，避免了重复加载，同时也能阻止有人恶意替换加载系统类。 自定义类加载器一般地，在ClassLoader方法的loadClass方法中已经给开发者实现了双亲委派模型，在自定义类加载器的时候，只需要复写findClass方法即可。1234567891011121314151617181920212223242526272829303132333435363738public class CustomClassLoader extends ClassLoader &#123; private String root; public CustomClassLoader(String root) &#123; this.root = root; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = loadClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] loadClassData(String name) &#123; String fileName = root + File.separatorChar + name.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;; try &#123; InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length; while ((length = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 新建一个类com.xiao.U，编译成class文件，放到桌面，来测试一下：123456789101112public class Test &#123; public static void main(String[] args) &#123; CustomClassLoader customClassLoader = new CustomClassLoader(&quot;C:\\Users\\PC\\Desktop&quot;); try &#123; Class clazz = customClassLoader.loadClass(&quot;com.xiao.U&quot;); Object o = clazz.newInstance(); System.out.println(o.getClass().getClassLoader()); &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印结果：1CustomClassLoader@1540e19d 自定义类加载器在可以实现服务端的热部署，在移动端比如android也可以实现热更新。 参考： 深入理解Java虚拟机（第二版） Java 类加载机制详解]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机 —— 垃圾回收机制]]></title>
    <url>%2F2017%2F08%2F08%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA-%E2%80%94%E2%80%94-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在Java虚拟机中，对象和数组的内存都是在堆中分配的，垃圾收集器主要回收的内存就是再堆内存中。如果在Java程序运行过程中，动态创建的对象或者数组没有及时得到回收，持续积累，最终堆内存就会被占满，导致OOM。 JVM提供了一种垃圾回收机制，简称GC机制。通过GC机制，能够在运行过程中将堆中的垃圾对象不断回收，从而保证程序的正常运行。 垃圾对象的判定我们都知道，所谓“垃圾”对象，就是指我们在程序的运行过程中不再有用的对象，即不再存活的对象。那么怎么来判断堆中的对象是“垃圾”、不再存活的对象呢？ 引用计数法每个对象都有一个引用计数的属性，用来保存该对象被引用的次数。当引用次数为0时，就意味着该对象没有被引用了，也就不会在使用这个对象了，可以判定为垃圾对象。但是，这种方式有一个很大的Bug，就是无法解决对象间相互引用或者循环引用的问题：当两个对象相互引用，他们两个和其他任何对象也没有引用关系，它俩的引用次数都不为0，因此不会被回收，但实际上这两个对象已经不再有用了。 可达性分析（根搜索法）为了避免使用引用计数法带来的问题，Java采用了可达性分析法来判断垃圾对象。 这种方式可以将所有对象的引用关系想象成一棵树，从树的根节点GC Root遍历所有引用的对象，树的节点就为可达对象，其他没有处于节点的对象则为不可达对象。那么什么样的对象可以作为GC的根节点呢？ 虚拟机栈（帧栈中的本地变量表）中引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 引用状态垃圾回收机制，不管采用是引用计数法，还是可达性分析法，都与对象的引用有关，Java中存在四种引用状态： 强引用 - 我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，就表示它处于可达状态，垃圾回收器绝不会回收它，即便系统内存非常紧张，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会回收被强引用所引用的对象。因此，强引用是造成Java内存泄露的主要原因之一。 软引用 - 一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 弱引用 - 一个对象只具有弱引用，那就类似于是可有可无的。弱引用和软引用很像，但弱引用的引用级别更低。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 虚引用 - 一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动，我们平常一般不会使用。 垃圾回收算法通过可达性分析算法能够判定哪些对象是需要回收的了，那么回收具体需要怎样去执行呢？ 标记-清除算法首先需要标记可以回收的对象内存，然后在对回收的内存进行清除。但是这样的话，随着程序的运行，会不断分配释放内存，在堆中会产生很多的不连续的空闲内存区，即内存碎片。这样即使有足够多的空闲内存，也不一定能分配出足够大的内存，并且可能会造成频繁的GC，影响效率，甚至OOM。 标记-整理算法和标记-清除算法不同的是，标记-整理算法在标记后不直接清理可回收内存，而是将存活对象都移动到一端，然后清除掉可回收内存。这样做的好处就是不会产生内存碎片。 复制算法复制算法需要先将内存分为两块，先在其中一块内存上分配内存，当这块内存被分配完后，则执行垃圾回收，然后把存活对象全部复制到另一块内存上，第一块内存则全部清空。这种算法不会产生内存碎片，但是相当于只能使用一半的内存空间。同时，复制算法和存活对象的数量有关，如果存活对象的数量多，那么复制算法的效率会大大降低。 分代收集算法在Java虚拟机中，对象的生命周期有长有短，大部分对象的生命周期很短，只有少部分的对象才会在内存中存留较长时间，因此可以依据对象生命周期的长短将它们放在不同的区域。在采用分代收集算法的Java虚拟机堆中，一般分为三个区域，用来分别储存这三类对象： 新生代 - 刚创建的对象，在代码运行时一般都会持续不断地创建新的对象，这些新创建的对象有很多是局部变量，很快就会变成垃圾对象。这些对象被放在一块称为新生代的内存区域。新生代的特点是垃圾对象多，存活对象少。 老年代 - 一些对象很早被创建了，经历了多次GC也没有被回收，而是一直存活下来。这些对象被放在一块称为老年代的区域。老年代的特点是存活对象多，垃圾对象少。 永久代 - 一些伴随虚拟机生命周期永久存在的对象，比如一些静态对象，常量等。这些对象被放在一块称为永久代的区域。永久代的特点是这些对象一般不需要垃圾回收，会在虚拟机运行过程中一直存活。（在Java1.7之前，方法区中存储的是永久代对象，Java1.7方法区的永久代对象移到了堆中，而在Java1.8永久代已经从堆中移除了，这块内存给了元空间。） 分代收集算法也就根据新生代和老年代来进行垃圾回收的。 对于新生代区域，每次GC都会有很多垃圾对象被回收，只有少量存活。因此采用复制回收算法，GC时把剩余很少的存活对象复制过去即可。 在新生代区域中，并不是按照1:1的比例来进行复制回收，而是按照8:1:1的比例分为了Eden、SurvivorA、SurvivorB三个区域。其中Eden意为伊甸园，形容有很多新生对象在里面创建；Survivor区则为幸存者，即经历GC后仍然存活下来的对象。 Eden区对外提供堆内存。当Eden区快要满了，则进行Minor GC(新生代GC)，把存活对象放入SurvivorA区，清空Eden区； Eden区被清空后，继续对外提供堆内存； 当Eden区再次被填满，此时对Eden区和SurvivorA区同时进行Minor GC(新生代GC)，把存活对象放入SurvivorB区，此时同时清空Eden区和SurvivorA区； Eden区继续对外提供堆内存，并重复上述过程，即在 Eden 区填满后，把Eden区和某个Survivor区的存活对象放到另一个Survivor区； 当某个Survivor区被填满，且仍有对象未被复制完毕时，或者某些对象在反复Survive 15次左右时，则把这部分剩余对象放到老年代区域；当老年区也被填满时，进行Major GC（老年代GC），对老年代区域进行垃圾回收。老年代区域对象一般存活周期较长，每次GC时，存活的对象比较多，因此采用标记-整理算法，GC时移动少量存活对象，不会产生内存碎片。 触发GC的类型Java虚拟机会把每次触发GC的信息打印出来，可以根据日志来分析触发GC的原因。 GC_FOR_MALLOC：表示是在堆上分配对象时内存不足触发的GC。 GC_CONCURRENT：当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。 GC_EXPLICIT：表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。 GC_BEFORE_OOM：表示是在准备抛OOM异常之前进行的最后努力而触发的GC。 参考： Java内存回收机制–Java引用的种类（强引用、弱引用、软引用、虚引用） 理解Java垃圾回收机制 Java 技术之垃圾回收机制]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机 —— 运行时数据区]]></title>
    <url>%2F2017%2F08%2F07%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA-%E2%80%94%E2%80%94-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[Java虚拟机内存，是指JVM的运行时数据区域，主要分为：方法区、堆、虚拟机栈、本地方法栈、程序计数器。其中方法区和堆为索引线程的共享数据区，而虚拟机栈、本地方法栈、程序计数器为线程隔离的数据区。 程序计数器每个线程都有一个独立的计数器用来记录程序当前执行的指令，可以看成是当前线程所执行的字节码的行号指示器。如果线程正在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，计数器记录值为空(Undefined)。程序计数器占用的内存空间非常小，是线程的私有区域，此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 虚拟机栈虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈是一个后进先出的数据结构，里面存放的是栈帧，每个Java方法的调用对应一个栈帧在虚拟机栈中的入栈和出栈。当线程执行一个Java方法执行时，就会创建一个新的栈帧并压入到该线程的虚拟机栈的栈顶，Java方法执行结束后栈顶的该栈帧就会弹出栈并销毁。 栈帧里面存放的是Java方法执行的一些数据，包括局部变量表、操作数栈、动态连接、方法出口等。 局部变量表局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。 局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。 Java虚拟机是使用局部变量表完成参数值到Java方法参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。 Slot是可以重用的，下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。 操作数栈操作数栈也常被称为操作栈，同样是一个后进先出的数据结构。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。在做算术运算的时候是通过操作数栈来进行的，在调用其他方法的时候是通过操作数栈来进行参数传递的。JVM将操作数栈作为工作区。JVM没有寄存器，所有的参数传递和返回值都是基于操作数栈来完成的。 比如，执行引擎执行c = a + b时，会先被操作的参数a和b压入操作数栈，然后操作指令将他们弹出栈，并执行操作，将结果再压入栈。 Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。 动态连接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池有存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。 方法出口(返回地址)当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。 虚拟机栈ErrorJava虚拟机栈有可能出现的error就是StackOverflowError和OutOfMemoryError。当线程请求的栈深度大于Java虚拟机栈允许的深度时，就会抛出StackOverflowError错误。比如将一个方法反复递归，最终就会出现StackOverflowError。当Java虚拟机栈可以动态扩展时（大部分的 Java 虚拟机都可动态扩展，不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），如果无法申请到足够的内存来扩展栈，就会抛出OutOfMemoryError错误。 本地方法栈本地方法栈与虚拟机栈的功能类似，他们的区别在于虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务。本地方法栈就是一个C的方法栈，本地方法栈的参数顺序、返回值和典型的C程序相同，本地方法一般来说可以（依赖 JVM 的实现）反过来调用 JVM 中的 Java 方法。这种native方法调用Java会发生在栈（一般是Java栈）上，线程将离开本地方法栈，并在 Java 栈上开辟一个新的栈帧。 与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError。 堆堆是Java虚拟机中最大的一块内存区域，它是有所有的线程共享。几乎所有的实例对象和数组都是在堆中存放。只要是通过new关键字创建对象或者直接声明数组，都会在堆中开辟内存空间来存放。因为在栈帧被创建后无法调整大小，栈帧中只能存放对象和数组在堆中的引用。方法或线程结束时对象和数组不会立即被移除销毁，它只能由垃圾回收器回收。 同样地，如果在堆中没有内存来完成实例分配，并且堆也无法扩展时，将会抛出OutOfMemoryError。 方法区方法区与堆一样，是各个线程共享的内存区域，它存储已经被虚拟机加载的类信息(包括字段信息、方法信息、方法代码等)、常量、静态变量、即时编译器编译后的代码等数据。 方法区中的内存一般不会被GC回收，GC也很难回收。方法区的内存回收主要是针对针对常量池的回收和对类的卸载。根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。 运行时常量池运行时常量池是方法区的一部分，Class文件除了有关类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池可以理解为是类或接口的常量池的运行时表现形式。 参考 Java虚拟机内存区域划分详解 JAVA内存结构之运行时栈帧结构]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native —— react-navigation的使用]]></title>
    <url>%2F2017%2F07%2F21%2FReact-Native-%E2%80%94%E2%80%94-react-navigation%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在React Native中，官方已经推荐使用react-navigation来实现各个界面的跳转和不同板块的切换。react-navigation主要包括三个组件： StackNavigator 导航组件 TabNavigator 切换组件 DrawerNavigator 抽屉组件 StackNavigator用于实现各个页面之间的跳转，TabNavigator用来实现同一个页面上不同界面的切换，DrawerNavigator 可以实现侧滑的抽屉效果。 StackNavigatorStackNavigator组件采用堆栈式的页面导航来实现各个界面跳转。它的构造函数：1StackNavigator(RouteConfigs, StackNavigatorConfig) 有RouteConfigs和StackNavigatorConfig两个参数。 RouteConfigsRouteConfigs 参数表示各个页面路由配置，类似于android原生开发中的AndroidManifest.xml，它是让导航器知道需要导航的路由对应的页面。 1234567891011121314151617181920const RouteConfigs = &#123; Home: &#123; screen: HomePage, navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; title: &apos;首页&apos;, &#125;), &#125;, Find: &#123; screen: FindPage, navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; title: &apos;发现&apos;, &#125;), &#125;, Mine: &#123; screen: MinePage, navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; title: &apos;我的&apos;, &#125;), &#125;,&#125;; 这里给导航器配置了三个页面，Home、Find、Mine为路由名称，screen属性值HomePage、FindPage、MinePage为对应路由的页面。 navigationOptions为对应路由页面的配置选项： title - 可以作为头部标题headerTitle，或者Tab标题tabBarLabel header - 自定义的头部组件，使用该属性后系统的头部组件会消失 headerTitle - 头部的标题，即页面的标题 headerBackTitle - 返回标题，默认为title headerTruncatedBackTitle - 返回标题不能显示时（比如返回标题太长了）显示此标题，默认为“Back” headerRight - 头部右边组件 headerLeft - 头部左边组件 headerStyle - 头部组件的样式 headerTitleStyle - 头部标题的样式 headerBackTitleStyle - 头部返回标题的样式 headerTintColor - 头部颜色 headerPressColorAndroid - Android 5.0以上MD风格的波纹颜色 gesturesEnabled - 否能侧滑返回，iOS默认true，Android默认false StackNavigatorConfigStackNavigatorConfig参数表示导航器的配置，包括导航器的初始页面、各个页面之间导航的动画、页面的配置选项等等： 12345678910111213141516171819202122const StackNavigatorConfig = &#123; initialRouteName: &apos;Home&apos;, initialRouteParams: &#123;initPara: &apos;初始页面参数&apos;&#125;, navigationOptions: &#123; title: &apos;标题&apos;, headerTitleStyle: &#123;fontSize: 18, color: &apos;#666666&apos;&#125;, headerStyle: &#123;height: 48, backgroundColor: &apos;#fff&apos;&#125;, &#125;, paths: &apos;page/main&apos;, mode: &apos;card&apos;, headerMode: &apos;screen&apos;, cardStyle: &#123;backgroundColor: &quot;#ffffff&quot;&#125;, transitionConfig: (() =&gt; (&#123; screenInterpolator: CardStackStyleInterpolator.forHorizontal, &#125;)), onTransitionStart: (() =&gt; &#123; console.log(&apos;页面跳转动画开始&apos;); &#125;), onTransitionEnd: (() =&gt; &#123; console.log(&apos;页面跳转动画结束&apos;); &#125;),&#125;; initialRouteName - 导航器组件中初始显示页面的路由名称，如果不设置，则默认第一个路由页面为初始显示页面 initialRouteParams - 给初始路由的参数，在初始显示的页面中可以通过this.props.navigation.state.params来获取 navigationOptions - 路由页面的配置选项，它会被RouteConfigs 参数中的 navigationOptions的对应属性覆盖。 paths - 路由中设置的路径的覆盖映射配置 mode - 页面跳转方式，有card和modal两种，默认为card： card - 原生系统默认的的跳转 modal - 只针对iOS平台，模态跳转 headerMode - 页面跳转时，头部的动画模式，有float、screen、none三种： float - 渐变，类似iOS的原生效果 screen - 标题与屏幕一起淡入淡出 none - 没有动画 cardStyle - 为各个页面设置统一的样式，比如背景色，字体大小等 transitionConfig - 配置页面跳转的动画，覆盖默认的动画效果 onTransitionStart - 页面跳转动画即将开始时调用 onTransitionEnd - 页面跳转动画一旦完成会马上调用 页面的配置选项navigationOptions通常还可以在对应页面中去静态配置，比如在HomePage页面中： 123456789101112131415export default class HomePage extends Component &#123; // 配置页面导航选项 static navigationOptions = (&#123;navigation&#125;) =&gt; (&#123; title: &apos;HOME&apos;, titleStyle: &#123;color: &apos;#ff00ff&apos;&#125;, headerStyle:&#123;backgroundColor:&apos;#000000&apos;&#125; &#125;); render() &#123; return ( &lt;View&gt;&lt;/View&gt; ) &#125;;&#125; 同样地，在页面里面采用静态的方式配置navigationOptions中的属性，会覆盖StackNavigator构造函数中两个参数RouteConfigs和StackNavigatorConfig配置的navigationOptions里面的对应属性。navigationOptions中属性的优先级是：页面中静态配置 &gt; RouteConfigs &gt; StackNavigatorConfig 有了RouteConfigs和StackNavigatorConfig两个参数，就可以构造出一个导航器组件StackNavigator，直接引用该组件：123456789const Navigator = StackNavigator(RouteConfigs, StackNavigatorConfig);export default class MainComponent extends Component &#123; render() &#123; return ( &lt;Navigator/&gt; ) &#125;;&#125; 已经配置好导航器以及对应的路由页面了，但是要完成页面之间的跳转，还需要navigation。 navigation在导航器中的每一个页面，都有navigation属性，该属性有以下几个属性/方法： navigate - 跳转到其他页面 state - 当前页面导航器的状态 setParams - 更改路由的参数 goBack - 返回 dispatch - 发送一个action navigete调用这个方法可以跳转到导航器中的其他页面，此方法有三个参数：— routeName 导航器中配置的路由名称— params 传递参数到下一个页面— action action比如：this.props.navigation.navigate(&#39;Find&#39;, {param: &#39;i am the param&#39;}); statestate里面包含有传递过来的参数params、key、路由名称routeName，打印log可以看得到： 12345&#123; params: &#123; param: &apos;i am the param&apos; &#125;, key: &apos;id-1500546317301-1&apos;, routeName: &apos;Mine&apos; &#125; setParams更改当前页面路由的参数，比如可以用来更新头部的按钮或者标题。123componentDidMount() &#123; this.props.navigation.setParams(&#123;param:&apos;i am the new param&apos;&#125;)&#125; goBack回退，可以不传，也可以传参数，还可以传null。 123this.props.navigation.goBack(); // 回退到上一个页面this.props.navigation.goBack(null); // 回退到任意一个页面this.props.navigation.goBack(&apos;Home&apos;); // 回退到Home页面 TabNavigatorTabNavigator，即是Tab选项卡，类似于原生android中的TabLayout，它的构造函数： 1TabNavigator(RouteConfigs, TabNavigatorConfig) api和StackNavigator类似，参数RouteConfigs是路由配置，参数TabNavigatorConfig是Tab选项卡配置。 RouteConfigs路由配置和StackNavigator中是一样的，配置路由以及对应的screen页面，navigationOptions为对应路由页面的配置选项： title - Tab标题，可用作headerTitle和tabBarLabel回退标题 tabBarVisible - Tab的是否可见，没有设置的话默认为true tabBarIcon - Tab的icon组件，可以根据{focused: boolean, tintColor: string}方法来返回一个icon组件 tabBarLabel - Tab中显示的标题字符串或者组件，也可以根据{ focused: boolean, tintColor: string }方法返回一个组件 TabNavigatorConfig tabBarComponent - Tab选项卡组件，有TabBarBottom和TabBarTop两个值，在iOS中默认为TabBarBottom，在Android中默认为TabBarTop。 TabBarTop - 在页面的顶部 TabBarBottom - 在页面的底部 tabBarPosition - Tab选项卡的位置，有 top 或 bottom两个值 swipeEnabled - 是否可以滑动切换Tab选项卡 animationEnabled - 点击Tab选项卡切换界面是否需要动画 lazy - 是否懒加载页面 initialRouteName - 初始显示的Tab对应的页面路由名称 order - 用路由名称数组来表示Tab选项卡的顺序，默认为路由配置顺序 paths - 路径配置 backBehavior - androd点击返回键时的处理，有initialRoute和none两个值 initailRoute - 返回初始界面 none - 退出 tabBarOptions - Tab配置属性，用在TabBarTop和TabBarBottom时有些属性不一致： 用于TabBarTop时： activeTintColor - 选中的文字颜色 inactiveTintColor - 未选中的文字颜色 showIcon - 是否显示图标，默认显示 showLabel - 是否显示标签，默认显示 upperCaseLabel - 是否使用大写字母，默认使用 pressColor - android 5.0以上的MD风格波纹颜色 pressOpacity - android 5.0以下或者iOS按下的透明度 scrollEnabled - 是否可以滚动 tabStyle - 单个Tab的样式 indicatorStyle - 指示器的样式 labelStyle - 标签的样式 iconStyle - icon的样式 style - 整个TabBar的样式 用于TabBarBottom时： activeTintColor - 选中Tab的文字颜色 activeBackgroundColor - 选中Tab的背景颜色 inactiveTintColor - 未选中Tab的的文字颜色 inactiveBackgroundColor - 未选中Tab的背景颜色 showLabel - 是否显示标题，默认显示 style - 整个TabBar的样式 labelStyle - 标签的样式 tabStyle - 单个Tab的样式 底部Tab导航示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import React, &#123;Component&#125; from &apos;react&apos;;import &#123;StackNavigator, TabBarBottom, TabNavigator&#125; from &quot;react-navigation&quot;;import HomeScreen from &quot;./index18/HomeScreen&quot;;import NearByScreen from &quot;./index18/NearByScreen&quot;;import MineScreen from &quot;./index18/MineScreen&quot;;import TabBarItem from &quot;./index18/TabBarItem&quot;;export default class MainComponent extends Component &#123; render() &#123; return ( &lt;Navigator/&gt; ); &#125;&#125;const TabRouteConfigs = &#123; Home: &#123; screen: HomeScreen, navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; tabBarLabel: &apos;首页&apos;, tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_homepage_2x.png&apos;)&#125; selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_homepage_selected_2x.png&apos;)&#125; /&gt; ), &#125;), &#125;, NearBy: &#123; screen: NearByScreen, navigationOptions: &#123; tabBarLabel: &apos;附近&apos;, tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_merchant_2x.png&apos;)&#125; selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_merchant_selected_2x.png&apos;)&#125; /&gt; ), &#125;, &#125; , Mine: &#123; screen: MineScreen, navigationOptions: &#123; tabBarLabel: &apos;我的&apos;, tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_mine_2x.png&apos;)&#125; selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_mine_selected_2x.png&apos;)&#125; /&gt; ), &#125;, &#125;&#125;;const TabNavigatorConfigs = &#123; initialRouteName: &apos;Home&apos;, tabBarComponent: TabBarBottom, tabBarPosition: &apos;bottom&apos;, lazy: true,&#125;;const Tab = TabNavigator(TabRouteConfigs, TabNavigatorConfigs);const StackRouteConfigs = &#123; Tab: &#123; screen: Tab, &#125;&#125;;const StackNavigatorConfigs = &#123; initialRouteName: &apos;Tab&apos;, navigationOptions: &#123; title: &apos;标题&apos;, headerStyle: &#123;backgroundColor: &apos;#5da8ff&apos;&#125;, headerTitleStyle: &#123;color: &apos;#333333&apos;&#125;, &#125;&#125;;const Navigator = StackNavigator(StackRouteConfigs, StackNavigatorConfigs); 顶部Tab选项卡示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React, &#123;Component&#125; from &quot;react&quot;;import &#123;StackNavigator, TabBarTop, TabNavigator&#125; from &quot;react-navigation&quot;;import HomeScreen from &quot;./index18/HomeScreen&quot;;import NearByScreen from &quot;./index18/NearByScreen&quot;;import MineScreen from &quot;./index18/MineScreen&quot;;export default class MainComponent extends Component &#123; render() &#123; return ( &lt;Navigator/&gt; ); &#125;&#125;const TabRouteConfigs = &#123; Home: &#123; screen: HomeScreen, navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; tabBarLabel: &apos;首页&apos;, &#125;), &#125;, NearBy: &#123; screen: NearByScreen, navigationOptions: &#123; tabBarLabel: &apos;附近&apos;, &#125;, &#125; , Mine: &#123; screen: MineScreen, navigationOptions: &#123; tabBarLabel: &apos;我的&apos;, &#125;, &#125;&#125;;const TabNavigatorConfigs = &#123; initialRouteName: &apos;Home&apos;, tabBarComponent: TabBarTop, tabBarPosition: &apos;top&apos;, lazy: true, tabBarOptions: &#123;&#125;&#125;;const Tab = TabNavigator(TabRouteConfigs, TabNavigatorConfigs);const StackRouteConfigs = &#123; Tab: &#123; screen: Tab, &#125;&#125;;const StackNavigatorConfigs = &#123; initialRouteName: &apos;Tab&apos;, navigationOptions: &#123; title: &apos;标题&apos;, headerStyle: &#123;backgroundColor: &apos;#5da8ff&apos;&#125;, headerTitleStyle: &#123;color: &apos;#333333&apos;&#125;, &#125;&#125;;const Navigator = StackNavigator(StackRouteConfigs, StackNavigatorConfigs); DrawerNavigator在原生Android MD 风格里面很多app都会采用侧滑抽屉来做主页面的导航，利用DrawerNavigator在RN中可以很方便来实现抽屉导航。 1DrawerNavigator(RouteConfigs, DrawerNavigatorConfig) 和DrawerNavigator的构造函数一样，参数配置也类似。 RouteConfigs抽屉导航的路由配置RouteConfigs，和TabNavigator的路由配置完全一样，screen配置对应路由页面，navigationOptions为对应页面的抽屉配置选项： title - 抽屉标题，和headerTitle、drawerLabel一样 drawerLabel - 标签字符串，或者自定义组件， 可以根据{ focused: boolean, tintColor: string }函数来返回一个自定义组件作为标签 drawerIcon - 抽屉icon，可以根据{ focused: boolean, tintColor: string }函数来返回一个自定义组件作为icon DrawerNavigatorConfig抽屉配置项属性： drawerWidth - 抽屉宽度，可以使用Dimensions获取屏幕的宽度，动态计算 drawerPosition - 抽屉位置，可以是left或者right contentComponent - 抽屉内容组件，可以自定义侧滑抽屉中的所有内容，默认为DrawerItems contentOptions - 用来配置抽屉内容的属性。当用来配置DrawerItems是配置属性选项： items - 抽屉栏目的路由名称数组，可以被修改 activeItemKey - 当前选中页面的key id activeTintColor - 选中条目状态的文字颜色 activeBackgroundColor - 选中条目的背景色 inactiveTintColor - 未选中条目状态的文字颜色 inactiveBackgroundColor - 未选中条目的背景色 onItemPress(route) - 条目按下时会调用此方法 style - 抽屉内容的样式 labelStyle - 抽屉的条目标题/标签样式 initialRouteName - 初始化展示的页面路由名称 order - 抽屉导航栏目顺序，用路由名称数组表示 paths - 路径 backBehavior - androd点击返回键时的处理，有initialRoute和none两个值，initailRoute：返回初始界面，none：退出 抽屉导航示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import React, &#123;Component&#125; from &apos;react&apos;;import &#123;DrawerNavigator, StackNavigator, TabBarBottom, TabNavigator&#125; from &quot;react-navigation&quot;;import HomeScreen from &quot;./index18/HomeScreen&quot;;import NearByScreen from &quot;./index18/NearByScreen&quot;;import MineScreen from &quot;./index18/MineScreen&quot;;import TabBarItem from &quot;./index18/TabBarItem&quot;;export default class MainComponent extends Component &#123; render() &#123; return ( &lt;Navigator/&gt; ); &#125;&#125;const DrawerRouteConfigs = &#123; Home: &#123; screen: HomeScreen, navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; drawerLabel : &apos;首页&apos;, drawerIcon : (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_homepage_2x.png&apos;)&#125; selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_homepage_selected_2x.png&apos;)&#125; /&gt; ), &#125;), &#125;, NearBy: &#123; screen: NearByScreen, navigationOptions: &#123; drawerLabel : &apos;附近&apos;, drawerIcon : (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_merchant_2x.png&apos;)&#125; selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_merchant_selected_2x.png&apos;)&#125; /&gt; ), &#125;, &#125;, Mine: &#123; screen: MineScreen, navigationOptions: &#123; drawerLabel : &apos;我的&apos;, drawerIcon : (&#123;focused, tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_mine_2x.png&apos;)&#125; selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_mine_selected_2x.png&apos;)&#125; /&gt; ), &#125;, &#125;&#125;;const DrawerNavigatorConfigs = &#123; initialRouteName: &apos;Home&apos;, tabBarComponent: TabBarBottom, tabBarPosition: &apos;bottom&apos;, lazy: true, tabBarOptions: &#123;&#125;&#125;;const Drawer = DrawerNavigator(DrawerRouteConfigs, DrawerNavigatorConfigs);const StackRouteConfigs = &#123; Drawer: &#123; screen: Drawer, &#125;&#125;;const StackNavigatorConfigs = &#123; initialRouteName: &apos;Drawer&apos;, navigationOptions: &#123; title: &apos;标题&apos;, headerStyle: &#123;backgroundColor: &apos;#5da8ff&apos;&#125;, headerTitleStyle: &#123;color: &apos;#333333&apos;&#125;, &#125;&#125;;const Navigator = StackNavigator(StackRouteConfigs, StackNavigatorConfigs); 源码：https://gitee.com/xiaojianjun/DD.git （index20.js、index21.js、index22.js） 参考https://reactnavigation.org/docs/ReactNative导航新宠儿react-navigation]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native —— flex（弹性布局）]]></title>
    <url>%2F2017%2F07%2F10%2FReact-Native-%E2%80%94%E2%80%94-flex%EF%BC%88%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[flex，是flexible box的简称，意为弹性布局，在RN中是用来描述子组件在父组件中的对齐方式和相对位置，使其能够适应不同的屏幕，为界面布局带来更大的灵活性。 flex布局由flex container 和flex item组成。flex container分为主轴（main axis）和交叉轴（across axis）。主轴默认是竖直方向。 flexflex为弹性容器的属性，在css3中由flex-grow、flex-shrink、flex-basis三个属性组合起来，其中后面两个是可选参数。在RN中flex默认为flexGrow属性。 flexGrow 元素主轴尺寸占当前容器主轴尺寸的比重，默认值为0。 flexDirectionflexDirection属性为主轴方向，取值为column、column-reverse、row、row-reverse。默认值为column。 column 竖直方向，起点在顶部，子组件从上到下排列。 column-reverse 竖直方向，起点在底部，子组件从下到上排列。 row 水平方向，起点在左侧，子组件从左到右排列。 row-reverse 水平方向，起点在右侧，子组件从右到左排列。 flexWrapflexWrap表示沿主轴方向放不下是否需要换行。取值为：wrap、nowrap，默认值为wrap。 wrap 主轴方向放不下要换行。 nowrap 主轴方向放不下不换行。 justifyContentjustifyContent表示容器中的子组件在主轴方向上的对齐方式，取值为flex-start、flex-end、center、space-between、space-around，默认值为flex-start。 flex-start 在主轴方向上和主轴的起点对齐。 flex-end 在主轴方向上和主轴的终点对齐。 center 在主轴方向上居中对齐。 space-between 在主轴方向上两端对齐，每个item的间隔相等，第一个item和主轴起点、最后一个item和主轴终点没有间隔。 space-around 在主轴方向上分散对齐，每个item的两边都有相同的间隔。主轴起点和终点与邻近的两个item的间隔只有中间item之间的间隔的一半。 alignItemsalignItems表示容器中子组件在交叉轴方向上的对齐方式，取值为：flex-start、flex-end、center、stretch、baseline，默认值为flex-start。 flex-start 在交叉轴方向上和交叉轴的起点对齐。 flex-end 在交叉轴方向上和交叉轴的终点对齐。 center 在交叉轴方向上居中对齐。 stretch 如果子组件未设置交叉轴方向的大小或设为auto，将会在交叉轴方向占满整个容器。 baseline 与子组件第一行文字的基线对齐。 alignContentalignContent定义了多根轴线时，交叉轴方向的对齐方式，如果只有一根轴，该属性是没有效果的。取值为：flex-start、flex-end、center、space-between、space-around、stretch。默认值为flex-start。 flex-start 在交叉轴方向上和交叉轴的起点对齐。 flex-end 在交叉轴方向上和交叉轴的终点对齐。 center 在交叉轴方向上居中对齐。 space-between 与交叉轴两端对齐，轴线之间的间距间隔相等，第一根轴线上的item与交叉轴起点、最后一根轴线上的item与交叉轴终点没有间隔。 space-around 与交叉轴两端对齐，轴线之间的间距间隔相等，第一根轴线上的item与交叉轴起点、最后一根轴线上的item与交叉轴终点的间隔只有中间轴线上item间隔的一半。 stretch 如果子组件未设置交叉轴方向的大小或设为auto，将会在交叉轴方向占满整个容器。 alignSelfalignSelf定义了子组件自身对齐方式，该属性会覆盖父组件的alignItems属性。取值为：auto、flex-start、flex-end、center、stretch，默认值为auto。 auto 继承了它的父组件的 alignItems属性，如父组件没有，则为stretch。 flex-start 子组件在交叉轴方向与交叉轴起点对齐。 flex-end 子组件在交叉轴方向与交叉轴终点对齐。 center 子组件在交叉轴方向居中对齐。 stretch 如果没有在交叉轴方向没有设置大小，则会拉伸在交叉轴方向占满整个容器。]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native —— Component（组件）]]></title>
    <url>%2F2017%2F07%2F03%2FReact-Native-%E2%80%94%E2%80%94-Component%EF%BC%88%E7%BB%84%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[React利用JSX语法将html标签封装成组件的形式，来插入到DOM中，可以很方便的构建出网页UI。在React Native中，组件仍是其最核心的东西，各个界面UI都是通过基础组件的拼装来实现的。 JSXReact 的核心机制就是创建虚拟DOM，在虚拟DOM与实际DOM之间通过强大的Diff算法来减少对实际DOM的渲染操作以提升性能。虚拟DOM可以用原生的JS来创建，但是这样的方式让代码的可读性不够友好，Facebook就利用大家熟悉的XML语法结合JS创造了JSX语法。JSX既是原生的JS，又能直观易懂的展示这些语意化的组件。 使用JSX语法定义组件V： 12345678910111213141516171819202122232425262728import React, &#123;Component&#125; from &quot;react&quot;;import &#123;Alert, StyleSheet, Text, View&#125; from &quot;react-native&quot;;export default class V extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.visite&#125; onPress=&#123;() =&gt; this.press()&#125;&gt;访问&lt;/Text&gt; &lt;/View&gt; ); &#125; press = () =&gt; &#123; Alert.alert(&quot;标题&quot;, &quot;内容&quot;); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos; &#125;, visite: &#123; width: 40, height: 40, backgroundColor: &apos;#00ff00&apos; &#125;&#125;); 在组件的JS文件中，可以直接使用ES6语法，组件的层次结构都是在render方法中采用JSX语法来定义，可以将JSX语法看做是JS和XML混写的语法，当遇到&lt;，JSX就当HTML解析，遇到{就当JS解析。 props（属性）UI的各种展示效果，需要用到它的属性props。大多数的组件在定义的时候就可以使用各种参数来定制，这些参数就是组件的属性props。props中的某个属性的值通常是在父组件中指定，而且一经指定，一般都不会再改变，除非父组件去重新指定它。 12345678910111213141516171819202122232425262728293031import React, &#123;Component&#125; from &quot;react&quot;;import &#123;Text, View&#125; from &quot;react-native&quot;;class C extends Component &#123; // 定义并初始化属性，es6写法 static defaultProps = &#123;name: &quot;Jack&quot;, age: 25&#125;; static propTypes = &#123;name: React.PropTypes.string, age: React.PropTypes.number&#125;; render() &#123; return ( &lt;Text&gt;&#123;this.props.name + &quot; &quot; + this.props.age + &quot; &quot; + this.props.sex&#125;&lt;/Text&gt; ); &#125;&#125;export default class V extends Component &#123; render() &#123; let cName1 = &apos;Smith&apos;; let cName2 = &apos;Mark&apos;; let cAge1 = 30; let cAge2 = 20; let cSex1 = &apos;男&apos;; let cSex2 = &apos;女&apos;; return ( &lt;View&gt; &lt;C name=&#123;cName1&#125; age=&#123;cAge1&#125; sex=&#123;cSex1&#125;/&gt; &lt;C name=&#123;cName2&#125; age=&#123;cAge2&#125; sex=&#123;cSex2&#125;/&gt; &lt;/View&gt; ); &#125;&#125; 在上面的代码中，组件C中定义了两个默认的属性name和age，并给定了类型和初始值。在组件V中，引用了组件C，因此组件V为组件C的父组件。父组件V给组件C的name和age属性指定新的属性值，同时新增了一个sex的属性并给定属性值。那么在组件C中是不能改变组件V给它指定的name、age和sex的值。 state（状态）如果需要改变组件的参数来实现交互，需要用到它的状态state。通常在组件的构造函数中初始化state，在需要修改的时候调用setState()方法。 举一个例子，一段文本点击后改变它的背景，那么我们将bgColor定义为组件V3的状态，在constructor函数中初始化，点击后改变该状态的值：1234567891011121314151617181920212223242526272829303132import React, &#123;Component&#125; from &quot;react&quot;;import &#123;Text, View&#125; from &quot;react-native&quot;;export default class V3 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;bgColor: &quot;#ffffff&quot;&#125;; &#125; render() &#123; return ( &lt;View style=&#123;&#123; backgroundColor: this.state.bgColor, height: 30, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos; &#125;&#125;&gt; &lt;Text onPress=&#123;() =&gt; this.press()&#125;&gt;点击改变背景颜色&lt;/Text&gt; &lt;/View&gt; ); &#125; press = () =&gt; &#123; if (this.state.bgColor === &quot;#ffffff&quot;) &#123; this.setState(&#123;bgColor: &quot;#00ff00&quot;&#125;); &#125; else if (this.state.bgColor === &quot;#00ff00&quot;) &#123; this.setState(&#123;bgColor: &quot;#ff00ff&quot;&#125;); &#125; else &#123; this.setState(&#123;bgColor: &quot;#ffffff&quot;&#125;); &#125; &#125;&#125; 组件生命周期 上流程图描述了组件从创建、运行到销毁的整个过程，可以看到如果一个组件在被创建，从开始一直到运行会依次调用getDefaultProps到render这五个函数；在运行过程中，如果有属性和状态的改变，又会触发左侧的其他函数的调用，并在此回到运行状态；当组件即将会被销毁时，会调用函数conponentWillUnmount来通知组件，到最终组件销毁，生命周期结束。 getDefaultProps 获取默认属性，并初始化props; getInitialState 获取初始化的组件状态state； componentWillMount 组件将会被装载，在渲染render前调用； componentWillReceiveProps 如果接收到属性就会调用该方法，旧的属性仍然可以通过this.props来获取，也可以调用this.setState来更新组件的状态，这里更新状态是安全的，不会触发render。 shouldComponentUpdate 决定是否更新组件； componentWillUpdate 如果组件的状态或者属性改变了，并且shouldComponentUpdate为true，就会调用侧方法准备更新组件； render渲染，即初次渲染和更新组件的方法； componentDidUpdate 组件更新完成后会调用此方法； conponentWillUnmount 当组件要销毁，即从界面移除时，就会调用此方法。 在ES6中已经废除了getDefaultProps和getInitialState的方式，直接通过this.props和this.state来获取。]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native —— 搭建开发环境、创建Hello World]]></title>
    <url>%2F2017%2F07%2F01%2FReact-Native-%E2%80%94%E2%80%94-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%81%E5%88%9B%E5%BB%BAHello-World%2F</url>
    <content type="text"><![CDATA[前言React Native(简称RN)从诞生以来，就受到了广大开发者的追捧。相比于Native开发，RN开发更为灵活，而且支持跨平台（Android和iOS同时支持），也更方便热更新，最重要的是它基本上能够达到与Native App一样的渲染和体验效果。虽然RN目前还有许多功能不够完善，同时也存在一些兼容性问题，作为Native开发者，我们还是可以通过混合开发（RN+原生开发）的模式来规避这些坑，这样也能兼具RN和原生开发的共同优势。 准备对于前端工程师来说，学习RN要容易得多，但是对于原生开发者来说，学习成本还是相对较大： 首先，你需要有一定的JavaScript基础，对于没有js基础的同学，想直接就从RN开始，那估计是相当痛苦的。其次，React作为RN的核心，在开始学习RN之前，至少要对React相关的基础知识有所了解。 如果完全没有接触过前端，想学习RN的话，建议还是可以先学习一下html/css、js等基础知识，再开始React、RN的学习，这样可能前期花费的时间和精力比较多，但是后期就要轻松很多，不用在学习RN的中途还要去恶补一些前端的基础知识。 搭建开发环境因为我使用的是Windows系统，所以下面就介绍下如何在Windows系统下搭建RN开发环境。 参考ReactNative中文网，首先我们需要装Python2和Node，考虑到可能chocolatey国外网站可能访问较慢，我们就直接冲Python官网下载Python2，下载地址：https://www.python.org/downloads/ 选择2.7.13版本，注意不要选Python2以上的版本，目前RN还不支持。然后在Node.js中文网下载最新的Node.js的msi安装包，注意根据自己的系统位数选择。下载地址：http://nodejs.cn/download/ 下载完成后直接安装，安装完成后建议设置npm镜像以加速后面的过程： 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 安装Yarn、RN的命令行工具（react-native-cli），Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 1npm install -g yarn react-native-cli 安装完yarn后也要设置镜像源： 12yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 安装开发工具我是做安卓开发，已经有了AndroidStudio开发工具，AndroidStudio安装和android-sdk的配置我就不介绍了，需要注意的是android-sdk路径的环境变量ANDROID_HOME必须要配置，如果之前没有的需要加上。 RN的开发工具有很多，像是Atom、Sublime、WebStorm等前端开发工具都能进行RN的开发。由于笔者长期使用AndroidStudio，所以我就用WebStrom了，因为它们都是由JetBrains出品，操作界面、快捷键、插件都是一致的，不需要进行二次学习。 WebStrom下载地址：http://www.jetbrains.com/webstorm/download/下载安装后，只有30天的免费使用，需要破解的话，网上有很多方式。 创建HelloWorld打开WebStorm，点击Create New Project创建一个新的RN工程： 选择左侧的React Native标签，location选项为你的工程目录和工程名称HelloWorld，Node interpreter和React Native选项为默认的就行。 点击create后，就开始构建工程了，第一次构建过程中要去下载RN的依赖包，可能时间比较长，耐心等待。构建完成后，可以看到RN项目的工程目录结构： 其中有几个比较关键的文件： -test-，为测试文件，里面存放一些测试用的js文件。 android，就是一个原生的android工程项目，可以用androidStudio打开进行原生开发。 ios，就是一个原生的ios工程项目，可以用xcode打开进行原生开发。 node_module，下载的依赖库都存放在里面，包括React和React Native，相当于* AndroidStudio的External Libraries。 package.json，RN工程的远程依赖，通常是在根目录通过命令行npm install xxxxxx --savet添加一个库，添加完成后，会把依赖信息自动写在package.json里面，相当于AndroidStudio的build.gradle。 index.android.js，这是android的React Native入口文件。 index.ios.js，这是ios的React Native入口文件。 点击WebStorm右上角的下拉按钮，选择Android： 界面上就会出现运行和调试按钮了： 连接到真机，点击执行。执行的过程中会添加react和react-native的依赖。同时如果默认的gradle版本是你没有使用过的话，也会自动去下载，所以耐心等待。当然最好是在执行之前通过AdnroidStudio打开RN工程下的android项目，将gradle版本修改到本地已有的版本。 运行时，在真机上可能遇到白屏情况，需要开启悬浮窗权限。也极有可能会出现下图左边的错误，点击RELOAD后，又会出现右边的fix方案： 一般的最有可能的还是最后一种情况，即是运行设备（真机或模拟器）与packager server没在同一个ip，就不能用localhost了。 摇一摇手机，出现对话框： 点击Dev Settings，进入设置界面，点击Debug server hoset &amp;port for device，弹出对话框，输入自己电脑所在的局域网的ip:8081 点击确定后，回到主界面，摇一摇手机，再次点击对话框中的reload，就运行成功了： 参考：React Native 中文网从Android到React Native开发（一、入门）]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义实现MIUI的拖动视差效果（阻尼效果）]]></title>
    <url>%2F2017%2F06%2F18%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0MIUI%E7%9A%84%E6%8B%96%E5%8A%A8%E8%A7%86%E5%B7%AE%E6%95%88%E6%9E%9C%EF%BC%88%E9%98%BB%E5%B0%BC%E6%95%88%E6%9E%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在MIUI上有一些界面在拖动的时候有一个视差效果：在可以滚动的视图中，内容滚动到顶部时继续下拉，整个视图就有一个竖直方向拉伸的视差效果。滚动到底部继续上拉，也有同样的效果。 滚动视图可能是ScrollView、RecyclerView，要实现这样的效果，需要自定义并拦截Touch事件，重新处理事件逻辑。 以RecyclerView为例，我们自定义一个ParallaxRecyclerView，复写onInterceptTouchEvent方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Overridepublic boolean onInterceptTouchEvent(MotionEvent event) &#123; int action = MotionEventCompat.getActionMasked(event); if (isRestoring &amp;&amp; action == MotionEvent.ACTION_DOWN) &#123; isRestoring = false; &#125; if (!isEnabled() || isRestoring || (!isScrollToTop() &amp;&amp; !isScrollToBottom())) &#123; return super.onInterceptTouchEvent(event); &#125; switch (action) &#123; case MotionEvent.ACTION_DOWN: &#123; mActivePointerId = event.getPointerId(0); isBeingDragged = false; float initialMotionY = getMotionEventY(event); if (initialMotionY == -1) &#123; return super.onInterceptTouchEvent(event); &#125; mInitialMotionY = initialMotionY; break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (mActivePointerId == MotionEvent.INVALID_POINTER_ID) &#123; return super.onInterceptTouchEvent(event); &#125; final float y = getMotionEventY(event); if (y == -1f) &#123; return super.onInterceptTouchEvent(event); &#125; if (isScrollToTop() &amp;&amp; !isScrollToBottom()) &#123; // 在顶部不在底部 float yDiff = y - mInitialMotionY; if (yDiff &gt; mTouchSlop &amp;&amp; !isBeingDragged) &#123; isBeingDragged = true; &#125; &#125; else if (!isScrollToTop() &amp;&amp; isScrollToBottom()) &#123; // 在底部不在顶部 float yDiff = mInitialMotionY - y; if (yDiff &gt; mTouchSlop &amp;&amp; !isBeingDragged) &#123; isBeingDragged = true; &#125; &#125; else if (isScrollToTop() &amp;&amp; isScrollToBottom()) &#123; // 在底部也在顶部 float yDiff = y - mInitialMotionY; if (Math.abs(yDiff) &gt; mTouchSlop &amp;&amp; !isBeingDragged) &#123; isBeingDragged = true; &#125; &#125; else &#123; // 不在底部也不在顶部 return super.onInterceptTouchEvent(event); &#125; break; &#125; case MotionEventCompat.ACTION_POINTER_UP: onSecondaryPointerUp(event); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mActivePointerId = MotionEvent.INVALID_POINTER_ID; isBeingDragged = false; break; &#125; return isBeingDragged || super.onInterceptTouchEvent(event);&#125; 滚动RecyclerView到达顶部或者底部继续拖动时，需要拦截Touch事件。所以在MotionEvent.ACTION_MOVE时需要判断当前RecyclerView是否在顶部或者底部。需要注意的是，当RecyclerView中的item没有填充满整视图时，RecyclerView的状态既是在顶部也是在底部。 1234567private boolean isScrollToTop() &#123; return !ViewCompat.canScrollVertically(this, -1);&#125;private boolean isScrollToBottom() &#123; return !ViewCompat.canScrollVertically(this, 1);&#125; mActivePointerId表示在多点触控是当前活动手指的id，mInitialMotionY为手指按下时的Y坐标。 当达到顶部或底部继续拖动时，根据当前的位置（isScrollToTop()、isScrollToBottom()）和ACTION_MOVE时的移动距离yDiff来判断是否需要拦截：在顶部时向上拖动并且yDiff&gt;mTouchSlop就需要拦截，底部时向下拖动同样yDiff&gt;mTouchSlop也需要拦截，同时在顶部和底部时满足Math.abs(yDiff)&gt;mTouchSlop也需要拦截。需要拦截都是在没有被拖动（!isBeingDragged）的情况下。 RecyclerViev既没有在顶部也没有在底部时，说明item滚动到中间，可以上下继续滚动，不需要拦截，交给super.onInterceptTouchEvent(event)来处理。同时其它不需要拦截的情况也都交给super来处理。 onSecondaryPointerUp(event)为当第二个手指离开屏幕是需要重新设置mActivePointerId: 12345678private void onSecondaryPointerUp(MotionEvent event) &#123; final int pointerIndex = MotionEventCompat.getActionIndex(event); final int pointerId = event.getPointerId(pointerIndex); if (pointerId == mActivePointerId) &#123; int newPointerIndex = pointerIndex == 0 ? 1 : 0; mActivePointerId = event.getPointerId(newPointerIndex); &#125;&#125; 拦截到TouchEvent，在onTouchEven中处理，实现拖动视差效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (MotionEventCompat.getActionMasked(event)) &#123; case MotionEvent.ACTION_DOWN: mActivePointerId = event.getPointerId(0); isBeingDragged = false; break; case MotionEvent.ACTION_MOVE: &#123; float y = getMotionEventY(event); if (isScrollToTop() &amp;&amp; !isScrollToBottom()) &#123; // 在顶部不在底部 mDistance = y - mInitialMotionY; if (mDistance &lt; 0) &#123; return super.onTouchEvent(event); &#125; mScale = calculateRate(mDistance); pull(mScale); return true; &#125; else if (!isScrollToTop() &amp;&amp; isScrollToBottom()) &#123; // 在底部不在顶部 mDistance = mInitialMotionY - y; if (mDistance &lt; 0) &#123; return super.onTouchEvent(event); &#125; mScale = calculateRate(mDistance); push(mScale); return true; &#125; else if (isScrollToTop() &amp;&amp; isScrollToBottom()) &#123; // 在底部也在顶部 mDistance = y - mInitialMotionY; if (mDistance &gt; 0) &#123; mScale = calculateRate(mDistance); pull(mScale); &#125; else &#123; mScale = calculateRate(-mDistance); push(mScale); &#125; return true; &#125; else &#123; // 不在底部也不在顶部 return super.onTouchEvent(event); &#125; &#125; case MotionEventCompat.ACTION_POINTER_DOWN: mActivePointerId = event.getPointerId(MotionEventCompat.getActionIndex(event)); break; case MotionEventCompat.ACTION_POINTER_UP: onSecondaryPointerUp(event); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: &#123; if (isScrollToTop() &amp;&amp; !isScrollToBottom()) &#123; animateRestore(true); &#125; else if (!isScrollToTop() &amp;&amp; isScrollToBottom()) &#123; animateRestore(false); &#125; else if (isScrollToTop() &amp;&amp; isScrollToBottom()) &#123; if (mDistance &gt; 0) &#123; animateRestore(true); &#125; else &#123; animateRestore(false); &#125; &#125; else &#123; return super.onTouchEvent(event); &#125; break; &#125; &#125; return super.onTouchEvent(event);&#125; 代码虽然有点长，但是逻辑很简单，在拦截到ACTION_MOVE事件后，同样根据顶部或底部位置以及滚动的距离mDistance来确定是否消费掉该事件。不需要消费的直接给`super.onTouchEvent(event)来处理，需要消费的话根据mDistance来计算出缩放的比例mScale，再通过pull(mScale)和push(mScale)来缩放。 1234567private float calculateRate(float distance) &#123; int screenHeight = getResources().getDisplayMetrics().heightPixels; float originalDragPercent = distance / screenHeight; float dragPercent = Math.min(1f, originalDragPercent); float rate = 2f * dragPercent - (float) Math.pow(dragPercent, 2f); return 1 + rate / 5f;&#125; mScale的计算是一个二次函数，当拖动距离越大时，mScale的变化程度越小，这样使得拖动时有一个张力效果。 123456789private void pull(float scale) &#123; this.setPivotY(0); this.setScaleY(scale);&#125;private void push(float scale) &#123; this.setPivotY(this.getHeight()); this.setScaleY(scale);&#125; 在ACTION_UP时，需要将缩放的视图通过动画还原到初始状态。这里也需要判断位置，因为不同位置的的缩放中心点不一样。同时即在顶部也在底部时是根mDistance的正负值来判断拖动的方向。 1234567891011121314151617181920212223242526272829303132333435363738private void animateRestore(final boolean isPullRestore) &#123; ValueAnimator animator = ValueAnimator.ofFloat(mScale, 1f); animator.setDuration(300); animator.setInterpolator(new DecelerateInterpolator(2f)); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float value = (float) animation.getAnimatedValue(); if (isPullRestore) &#123; pull(value); &#125; else &#123; push(value); &#125; &#125; &#125;); animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; isRestoring = true; &#125; @Override public void onAnimationEnd(Animator animation) &#123; isRestoring = false; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); animator.start();&#125; 这样就OK了，如果需要实现ScrollView、ListView、GridView也是一样的逻辑，源码中已经有了ParallaxScrollView的实现，看下最终效果图： 源码：https://github.com/xiaoyanger0825/Parallax]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用MediaPlayer+TextureView封装一个完美实现全屏、小窗口的视频播放器]]></title>
    <url>%2F2017%2F05%2F22%2F%E7%94%A8MediaPlayer-TextureView%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F%E3%80%81%E5%B0%8F%E7%AA%97%E5%8F%A3%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[项目已添加IjkPlayer支持，后续逐渐完善其他功能。地址：https://github.com/xiaoyanger0825/NiceVieoPlayer 为什么使用TextureView在Android总播放视频可以直接使用VideoView，VideoView是通过继承自SurfaceView来实现的。SurfaceView的大概原理就是在现有View的位置上创建一个新的Window，内容的显示和渲染都在新的Window中。这使得SurfaceView的绘制和刷新可以在单独的线程中进行，从而大大提高效率。但是呢，由于SurfaceView的内容没有显示在View中而是显示在新建的Window中， 使得SurfaceView的显示不受View的属性控制，不能进行平移，缩放等变换，也不能放在其它RecyclerView或ScrollView中，一些View中的特性也无法使用。 TextureView是在4.0(API level 14)引入的，与SurfaceView相比，它不会创建新的窗口来显示内容。它是将内容流直接投放到View中，并且可以和其它普通View一样进行移动，旋转，缩放，动画等变化。TextureView必须在硬件加速的窗口中使用。 TextureView被创建后不能直接使用，必须要在它被它添加到ViewGroup后，待SurfaceTexture准备就绪才能起作用（看TextureView的源码，TextureView是在绘制的时候创建的内部SurfaceTexture）。通常需要给TextureView设置监听器SurfaceTextuListener： 12345678910111213141516171819202122mTextureView.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() &#123; @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) &#123; // SurfaceTexture准备就绪 &#125; @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) &#123; // SurfaceTexture缓冲大小变化 &#125; @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) &#123; // SurfaceTexture即将被销毁 return false; &#125; @Override public void onSurfaceTextureUpdated(SurfaceTexture surface) &#123; // SurfaceTexture通过updateImage更新 &#125;&#125;); SurfaceTexture的准备就绪、大小变化、销毁、更新等状态变化时都会回调相对应的方法。当TextureView内部创建好SurfaceTexture后，在监听器的onSurfaceTextureAvailable方法中，用SurfaceTexture来关联MediaPlayer，作为播放视频的图像数据来源。 SurfaceTexture作为数据通道，把从数据源（MediaPlayer）中获取到的图像帧数据转为GL外部纹理，交给TextureVeiw作为View heirachy中的一个硬件加速层来显示，从而实现视频播放功能。 MediaPlayer介绍MediaPlayer是Android原生的多媒体播放器，可以用它来实现本地或者在线音视频的播放，同时它支持https和rtsp。 MediaPlayer定义了各种状态，可以理解为是它的生命周期。 这个状态图描述了MediaPlayer的各种状态，以及主要方法调用后的状态变化。 MediaPlayer的相关方法及监听接口： 方法 介绍 状态 setDataSource 设置数据源 Initialized prepare 准备播放，同步 Preparing —&gt; Prepared prepareAsync 准备播放，异步 Preparing —&gt; Prepared start 开始或恢复播放 Started pause 暂停 Paused stop 停止 Stopped seekTo 到指定时间点位置 PrePared/Started reset 重置播放器 Idle setAudioStreamType 设置音频流类型 – setDisplay 设置播放视频的Surface – setVolume 设置声音 – getBufferPercentage 获取缓冲半分比 – getCurrentPosition 获取当前播放位置 – getDuration 获取播放文件总时间 – 内部回调接口 介绍 状态 OnPreparedListener 准备监听 Preparing ——&gt;Prepared OnVideoSizeChangedListener 视频尺寸变化监听 – OnInfoListener 指示信息和警告信息监听 – OnCompletionListener 播放完成监听 PlaybackCompleted OnErrorListener 播放错误监听 Error OnBufferingUpdateListener 缓冲更新监听 – MediaPlayer在直接new出来之后就进入了Idle状态，此时可以调用多个重载的setDataSource()方法从idle状态进入Initialized状态（如果调用setDataSource()方法的时候，MediaPlayer对象不是出于Idle状态，会抛异常，可以调用reset()方法回到Idle状态）。 调用prepared()方法和preparedAsync()方法进入Prepared状态，prepared()方法直接进入Parpared状态，preparedAsync()方法会先进入PreParing状态，播放引擎准备完毕后会通过OnPreparedListener.onPrepared()回调方法通知Prepared状态。 在Prepared状态下就可以调用start()方法进行播放了，此时进入started()状态，如果播放的是网络资源，Started状态下也会自动调用客户端注册的OnBufferingUpdateListener.OnBufferingUpdate()回调方法，对流播放缓冲的状态进行追踪。 pause()方法和start()方法是对应的，调用pause()方法会进入Paused状态，调用start()方法重新进入Started状态，继续播放。 stop()方法会使MdiaPlayer从Started、Paused、Prepared、PlaybackCompleted等状态进入到Stoped状态，播放停止。 当资源播放完毕时，如果调用了setLooping(boolean)方法，会自动进入Started状态重新播放，如果没有调用则会自动调用客户端播放器注册的OnCompletionListener.OnCompletion()方法，此时MediaPlayer进入PlaybackCompleted状态，在此状态里可以调用start()方法重新进入Started状态。 封装考虑MediaPlayer的方法和接口比较多，不同的状态调用各个方法后状态变化情况也比较复杂。播放相关的逻辑只与MediaPlayer的播放状态和调用方法相关，而界面展示和UI操作很多时候都需要根据自己项目来定制。参考原生的VideoView，为了解耦和方便定制，把MediaPlayer的播放逻辑和UI界面展示及操作相关的逻辑分离。我是把MediaPlayer直接封装到NiceVideoPlayer中，各种UI状态和操作反馈都封装到NiceVideoPlayerController里面。如果需要根据不同的项目需求来修改播放器的功能，就只重写NiceVideoPlayerController就可以了。 NiceVideoPlayer首先，需要一个FrameLayout容器mContainer，里面有两层内容，第一层就是展示播放视频内容的TextureView，第二层就是播放器控制器mController。那么自定义一个NiceVideoPlayer继承自FrameLayout,将mContainer添加到当前控件： 12345678910111213141516171819202122232425public class NiceVideoPlayer extends FrameLayout&#123; private Context mContext; private NiceVideoController mController; private FrameLayout mContainer; public NiceVideoPlayer(Context context) &#123; this(context, null); &#125; public NiceVideoPlayer(Context context, AttributeSet attrs) &#123; super(context, attrs); mContext = context; init(); &#125; private void init() &#123; mContainer = new FrameLayout(mContext); mContainer.setBackgroundColor(Color.BLACK); LayoutParams params = new LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); this.addView(mContainer, params); &#125;&#125; 添加setUp方法来配置播放的视频资源路径（本地/网络资源）： 1234public void setUp(String url, Map&lt;String, String&gt; headers) &#123; mUrl = url; mHeaders = headers; &#125; 用户要在mController中操作才能播放，因此需要在播放之前设置好mController: 12345678public void setController(NiceVideoPlayerController controller) &#123; mController = controller; mController.setNiceVideoPlayer(this); LayoutParams params = new LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); mContainer.addView(mController, params);&#125; 用户在自定义好自己的控制器后通过setController这个方法设置给播放器进行关联。 触发播放时，NiceVideoPlayer将展示视频图像内容的mTextureView添加到mContainer中（在mController的下层），同时初始化mMediaPlayer，待mTextureView的数据通道SurfaceTexture准备就绪后就可以打开播放器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public void start() &#123; initMediaPlayer(); // 初始化播放器 initTextureView(); // 初始化展示视频内容的TextureView addTextureView(); // 将TextureView添加到容器中&#125;private void initTextureView() &#123; if (mTextureView == null) &#123; mTextureView = new TextureView(mContext); mTextureView.setSurfaceTextureListener(this); &#125;&#125;private void addTextureView() &#123; mContainer.removeView(mTextureView); LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); mContainer.addView(mTextureView, 0, params);&#125;private void initMediaPlayer() &#123; if (mMediaPlayer == null) &#123; mMediaPlayer = new MediaPlayer(); mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC); mMediaPlayer.setScreenOnWhilePlaying(true); mMediaPlayer.setOnPreparedListener(mOnPreparedListener); mMediaPlayer.setOnVideoSizeChangedListener(mOnVideoSizeChangedListener); mMediaPlayer.setOnCompletionListener(mOnCompletionListener); mMediaPlayer.setOnErrorListener(mOnErrorListener); mMediaPlayer.setOnInfoListener(mOnInfoListener); mMediaPlayer.setOnBufferingUpdateListener(mOnBufferingUpdateListener); &#125;&#125;@Overridepublic void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) &#123; // surfaceTexture数据通道准备就绪，打开播放器 openMediaPlayer(surface);&#125;private void openMediaPlayer(SurfaceTexture surface) &#123; try &#123; mMediaPlayer.setDataSource(mContext.getApplicationContext(), Uri.parse(mUrl), mHeaders); mMediaPlayer.setSurface(new Surface(surface)); mMediaPlayer.prepareAsync(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;@Overridepublic void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) &#123;&#125;@Overridepublic boolean onSurfaceTextureDestroyed(SurfaceTexture surface) &#123; return false;&#125;@Overridepublic void onSurfaceTextureUpdated(SurfaceTexture surface) &#123;&#125; 打开播放器调用prepareAsync()方法后，mMediaPlayer进入准备状态，准备就绪后就可以开始： 1234567private MediaPlayer.OnPreparedListener mOnPreparedListener = new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; mp.start(); &#125;&#125;; NiceVideoPlayer的这些逻辑已经实现视频播放了，操作相关以及UI展示的逻辑需要在控制器NiceVideoPlayerController中来实现。但是呢，UI的展示和反馈都需要依据播放器当前的播放状态，所以需要给播放器定义一些常量来表示它的播放状态： 1234567891011public static final int STATE_ERROR = -1; // 播放错误public static final int STATE_IDLE = 0; // 播放未开始public static final int STATE_PREPARING = 1; // 播放准备中public static final int STATE_PREPARED = 2; // 播放准备就绪public static final int STATE_PLAYING = 3; // 正在播放public static final int STATE_PAUSED = 4; // 暂停播放// 正在缓冲(播放器正在播放时，缓冲区数据不足，进行缓冲，缓冲区数据足够后恢复播放)public static final int STATE_BUFFERING_PLAYING = 5;// 正在缓冲(播放器正在播放时，缓冲区数据不足，进行缓冲，此时暂停播放器，继续缓冲，缓冲区数据足够后恢复暂停)public static final int STATE_BUFFERING_PAUSED = 6;public static final int STATE_COMPLETED = 7; // 播放完成 播放视频时，mMediaPlayer准备就绪(Prepared)后没有马上进入播放状态，中间有一个时间延迟时间段，然后开始渲染图像。所以将Prepared——&gt;“开始渲染”中间这个时间段定义为STATE_PREPARED。 如果是播放网络视频，在播放过程中，缓冲区数据不足时mMediaPlayer内部会停留在某一帧画面以进行缓冲。正在缓冲时，mMediaPlayer可能是在正在播放也可能是暂停状态，因为在缓冲时如果用户主动点击了暂停，就是处于STATE_BUFFERING_PAUSED，所以缓冲有STATE_BUFFERING_PLAYING和STATE_BUFFERING_PAUSED两种状态，缓冲结束后，恢复播放或暂停。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485private MediaPlayer.OnPreparedListener mOnPreparedListener = new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; mp.start(); mCurrentState = STATE_PREPARED; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;onPrepared ——&gt; STATE_PREPARED&quot;); &#125;&#125;;private MediaPlayer.OnVideoSizeChangedListener mOnVideoSizeChangedListener = new MediaPlayer.OnVideoSizeChangedListener() &#123; @Override public void onVideoSizeChanged(MediaPlayer mp, int width, int height) &#123; LogUtil.d(&quot;onVideoSizeChanged ——&gt; width：&quot; + width + &quot;，height：&quot; + height); &#125;&#125;;private MediaPlayer.OnCompletionListener mOnCompletionListener = new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; mCurrentState = STATE_COMPLETED; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;onCompletion ——&gt; STATE_COMPLETED&quot;); &#125;&#125;;private MediaPlayer.OnErrorListener mOnErrorListener = new MediaPlayer.OnErrorListener() &#123; @Override public boolean onError(MediaPlayer mp, int what, int extra) &#123; mCurrentState = STATE_ERROR; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;onError ——&gt; STATE_ERROR ———— what：&quot; + what); return false; &#125;&#125;;private MediaPlayer.OnInfoListener mOnInfoListener = new MediaPlayer.OnInfoListener() &#123; @Override public boolean onInfo(MediaPlayer mp, int what, int extra) &#123; if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) &#123; // 播放器渲染第一帧 mCurrentState = STATE_PLAYING; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_VIDEO_RENDERING_START：STATE_PLAYING&quot;); &#125; else if (what == MediaPlayer.MEDIA_INFO_BUFFERING_START) &#123; // MediaPlayer暂时不播放，以缓冲更多的数据 if (mCurrentState == STATE_PAUSED || mCurrentState == STATE_BUFFERING_PAUSED) &#123; mCurrentState = STATE_BUFFERING_PAUSED; LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_BUFFERING_START：STATE_BUFFERING_PAUSED&quot;); &#125; else &#123; mCurrentState = STATE_BUFFERING_PLAYING; LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_BUFFERING_START：STATE_BUFFERING_PLAYING&quot;); &#125; mController.setControllerState(mPlayerState, mCurrentState); &#125; else if (what == MediaPlayer.MEDIA_INFO_BUFFERING_END) &#123; // 填充缓冲区后，MediaPlayer恢复播放/暂停 if (mCurrentState == STATE_BUFFERING_PLAYING) &#123; mCurrentState = STATE_PLAYING; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_BUFFERING_END： STATE_PLAYING&quot;); &#125; if (mCurrentState == STATE_BUFFERING_PAUSED) &#123; mCurrentState = STATE_PAUSED; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_BUFFERING_END： STATE_PAUSED&quot;); &#125; &#125; else &#123; LogUtil.d(&quot;onInfo ——&gt; what：&quot; + what); &#125; return true; &#125;&#125;;private MediaPlayer.OnBufferingUpdateListener mOnBufferingUpdateListener = new MediaPlayer.OnBufferingUpdateListener() &#123; @Override public void onBufferingUpdate(MediaPlayer mp, int percent) &#123; mBufferPercentage = percent; &#125;&#125;; mController.setControllerState(mPlayerState, mCurrentState)，mCurrentState表示当前播放状态，mPlayerState表示播放器的全屏、小窗口，正常三种状态。 123public static final int PLAYER_NORMAL = 10; // 普通播放器public static final int PLAYER_FULL_SCREEN = 11; // 全屏播放器public static final int PLAYER_TINY_WINDOW = 12; // 小窗口播放器 定义好播放状态后，开始暂停等操作逻辑也需要根据播放状态调整： 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic void start() &#123; if (mCurrentState == STATE_IDLE || mCurrentState == STATE_ERROR || mCurrentState == STATE_COMPLETED) &#123; initMediaPlayer(); initTextureView(); addTextureView(); &#125;&#125;@Overridepublic void restart() &#123; if (mCurrentState == STATE_PAUSED) &#123; mMediaPlayer.start(); mCurrentState = STATE_PLAYING; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;STATE_PLAYING&quot;); &#125; if (mCurrentState == STATE_BUFFERING_PAUSED) &#123; mMediaPlayer.start(); mCurrentState = STATE_BUFFERING_PLAYING; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;STATE_BUFFERING_PLAYING&quot;); &#125;&#125;@Overridepublic void pause() &#123; if (mCurrentState == STATE_PLAYING) &#123; mMediaPlayer.pause(); mCurrentState = STATE_PAUSED; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;STATE_PAUSED&quot;); &#125; if (mCurrentState == STATE_BUFFERING_PLAYING) &#123; mMediaPlayer.pause(); mCurrentState = STATE_BUFFERING_PAUSED; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;STATE_BUFFERING_PAUSED&quot;); &#125;&#125; reStart()方法是暂停时继续播放调用。 全屏、小窗口播放的实现可能最能想到实现全屏的方式就是把当前播放器的宽高给放大到屏幕大小，同时隐藏除播放器以外的其他所有UI，并设置成横屏模式。但是这种方式有很多问题，比如在列表（ListView或RecyclerView）中，除了放大隐藏外，还需要去计算滑动多少距离才刚好让播放器与屏幕边缘重合，退出全屏的时候还需要滑动到之前的位置，这样实现逻辑不但繁琐，而且和外部UI偶合严重，后面改动维护起来非常困难（我曾经就用这种方式被坑了无数道）。 分析能不能有其他更好的实现方式呢？ 整个播放器由mMediaPalyer+mTexutureView+mController组成，要实现全屏或小窗口播放，我们只需要挪动播放器的展示界面mTexutureView和控制界面mController即可。并且呢我们在上面定义播放器时，已经把mTexutureView和mController一起添加到mContainer中了，所以只需要将mContainer从当前视图中移除，并添加到全屏和小窗口的目标视图中即可。 那么怎么确定全屏和小窗口的目标视图呢？ 我们知道每个Activity里面都有一个android.R.content，它是一个FrameLayout，里面包含了我们setContentView的所有控件。既然它是一个FrameLayout，我们就可以将它作为全屏和小窗口的目标视图。 我们把从当前视图移除的mContainer重新添加到android.R.content中，并且设置成横屏。这个时候还需要注意android.R.content是不包括ActionBar和状态栏的，所以要将Activity设置成全屏模式，同时隐藏ActionBar。 123456789101112131415161718192021@Overridepublic void enterFullScreen() &#123; if (mPlayerState == PLAYER_FULL_SCREEN) return; // 隐藏ActionBar、状态栏，并横屏 NiceUtil.hideActionBar(mContext); NiceUtil.scanForActivity(mContext) .setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); this.removeView(mContainer); ViewGroup contentView = (ViewGroup) NiceUtil.scanForActivity(mContext) .findViewById(android.R.id.content); LayoutParams params = new LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); contentView.addView(mContainer, params); mPlayerState = PLAYER_FULL_SCREEN; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;PLAYER_FULL_SCREEN&quot;);&#125; 退出全屏也就很简单了，将mContainer从android.R.content中移除，重新添加到当前视图，并恢复ActionBar、清除全屏模式就行了。 123456789101112131415161718192021public boolean exitFullScreen() &#123; if (mPlayerState == PLAYER_FULL_SCREEN) &#123; NiceUtil.showActionBar(mContext); NiceUtil.scanForActivity(mContext) .setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); ViewGroup contentView = (ViewGroup) NiceUtil.scanForActivity(mContext) .findViewById(android.R.id.content); contentView.removeView(mContainer); LayoutParams params = new LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); this.addView(mContainer, params); mPlayerState = PLAYER_NORMAL; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;PLAYER_NORMAL&quot;); return true; &#125; return false;&#125; 切换横竖屏时为了避免Activity重新走生命周期，别忘了需要在Manifest.xml的activity标签下添加如下配置： 1android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; 进入小窗口播放和退出小窗口的实现原理就和全屏功能一样了，只需要修改它的宽高参数： 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic void enterTinyWindow() &#123; if (mPlayerState == PLAYER_TINY_WINDOW) return; this.removeView(mContainer); ViewGroup contentView = (ViewGroup) NiceUtil.scanForActivity(mContext) .findViewById(android.R.id.content); // 小窗口的宽度为屏幕宽度的60%，长宽比默认为16:9，右边距、下边距为8dp。 FrameLayout.LayoutParams params = new FrameLayout.LayoutParams( (int) (NiceUtil.getScreenWidth(mContext) * 0.6f), (int) (NiceUtil.getScreenWidth(mContext) * 0.6f * 9f / 16f)); params.gravity = Gravity.BOTTOM | Gravity.END; params.rightMargin = NiceUtil.dp2px(mContext, 8f); params.bottomMargin = NiceUtil.dp2px(mContext, 8f); contentView.addView(mContainer, params); mPlayerState = PLAYER_TINY_WINDOW; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;PLAYER_TINY_WINDOW&quot;);&#125;@Overridepublic boolean exitTinyWindow() &#123; if (mPlayerState == PLAYER_TINY_WINDOW) &#123; ViewGroup contentView = (ViewGroup) NiceUtil.scanForActivity(mContext) .findViewById(android.R.id.content); contentView.removeView(mContainer); LayoutParams params = new LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); this.addView(mContainer, params); mPlayerState = PLAYER_NORMAL; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;PLAYER_NORMAL&quot;); return true; &#125; return false;&#125; 这里有个特别需要注意的一点： 当mContainer移除重新添加后，mContainer及其内部的mTextureView和mController都会重绘，mTextureView重绘后，会重新new一个SurfaceTexture，并重新回调onSurfaceTextureAvailable方法，这样mTextureView的数据通道SurfaceTexture发生了变化，但是mMediaPlayer还是持有原先的mSurfaceTexut，所以在切换全屏之前要保存之前的mSufaceTexture，当切换到全屏后重新调用onSurfaceTextureAvailable时，将之前的mSufaceTexture重新设置给mTexutureView。这样就保证了切换时视频播放的无缝衔接。 123456789@Overridepublic void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int width, int height) &#123; if (mSurfaceTexture == null) &#123; mSurfaceTexture = surfaceTexture; openMediaPlayer(); &#125; else &#123; mTextureView.setSurfaceTexture(mSurfaceTexture); &#125;&#125; NiceVideoPlayerControl为了解除NiceVideoPlayer和NiceVideoPlayerController的耦合，把NiceVideoPlayer的一些功能性和判断性方法抽象到NiceVideoPlayerControl接口中。 1234567891011121314151617181920212223242526272829303132public interface NiceVideoPlayerControl &#123; void start(); void restart(); void pause(); void seekTo(int pos); boolean isIdle(); boolean isPreparing(); boolean isPrepared(); boolean isBufferingPlaying(); boolean isBufferingPaused(); boolean isPlaying(); boolean isPaused(); boolean isError(); boolean isCompleted(); boolean isFullScreen(); boolean isTinyWindow(); boolean isNormal(); int getDuration(); int getCurrentPosition(); int getBufferPercentage(); void enterFullScreen(); boolean exitFullScreen(); void enterTinyWindow(); boolean exitTinyWindow(); void release();&#125; NiceVideoPlayer实现这个接口即可。 NiceVideoPlayerManager同一界面上有多个视频，或者视频放在ReclerView或者ListView的容器中，要保证同一时刻只有一个视频在播放，其他的都是初始状态，所以需要一个NiceVideoPlayerManager来管理播放器，主要功能是保存当前已经开始了的播放器。 1234567891011121314151617181920212223242526272829303132333435363738394041public class NiceVideoPlayerManager &#123; private NiceVideoPlayer mVideoPlayer; private NiceVideoPlayerManager() &#123; &#125; private static NiceVideoPlayerManager sInstance; public static synchronized NiceVideoPlayerManager instance() &#123; if (sInstance == null) &#123; sInstance = new NiceVideoPlayerManager(); &#125; return sInstance; &#125; public void setCurrentNiceVideoPlayer(NiceVideoPlayer videoPlayer) &#123; mVideoPlayer = videoPlayer; &#125; public void releaseNiceVideoPlayer() &#123; if (mVideoPlayer != null) &#123; mVideoPlayer.release(); mVideoPlayer = null; &#125; &#125; public boolean onBackPressd() &#123; if (mVideoPlayer != null) &#123; if (mVideoPlayer.isFullScreen()) &#123; return mVideoPlayer.exitFullScreen(); &#125; else if (mVideoPlayer.isTinyWindow()) &#123; return mVideoPlayer.exitTinyWindow(); &#125; else &#123; mVideoPlayer.release(); return false; &#125; &#125; return false; &#125;&#125; 采用单例，同时，onBackPressed供Activity中用户按返回键时调用。NiceVideoPlayer的start方法以及onCompleted需要修改一下，保证开始播放一个视频时要先释放掉之前的播放器；同时自己播放完毕，要将NiceVideoPlayerManager中的mNiceVideoPlayer实例置空，避免内存泄露。 12345678910111213141516171819202122232425// NiceVideoPlayer的start()方法。@Overridepublic void start() &#123; NiceVideoPlayerManager.instance().releaseNiceVideoPlayer(); NiceVideoPlayerManager.instance().setCurrentNiceVideoPlayer(this); if (mCurrentState == STATE_IDLE || mCurrentState == STATE_ERROR || mCurrentState == STATE_COMPLETED) &#123; initMediaPlayer(); initTextureView(); addTextureView(); &#125;&#125;// NiceVideoPlayer中的onCompleted监听。private MediaPlayer.OnCompletionListener mOnCompletionListener = new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; mCurrentState = STATE_COMPLETED; mController.setControllerState(mPlayerState, mCurrentState); LogUtil.d(&quot;onCompletion ——&gt; STATE_COMPLETED&quot;); NiceVideoPlayerManager.instance().setCurrentNiceVideoPlayer(null); &#125;&#125;; NiceVideoPlayerController播放控制界面上，播放、暂停、播放进度、缓冲动画、全屏/小屏等触发都是直接调用播放器对应的操作的。需要注意的就是调用之前要判断当前的播放状态，因为有些状态下调用播放器的操作可能引起错误（比如播放器还没准备就绪，就去获取当前的播放位置）。 播放器在触发相应功能的时候都会调用NiceVideoPlayerController的setControllerState(int playerState, int playState)这个方法来让用户修改UI。 不同项目都可能定制不同的控制器（播放操作界面），这里我就不详细分析实现逻辑了，大致功能就类似腾讯视频的热点列表中的播放器。其中横向滑动改变播放进度、左侧上下滑动改变亮度，右侧上下滑动改变亮度等功能在代码中都有实现。代码有点长，就不贴了，需要的直接下载源码。 使用12345mNiceVideoPlayer.setUp(url, null);NiceVideoPlayerController controller = new NiceVideoPlayerController(this);controller.setTitle(title);controller.setImage(imageUrl);mNiceVideoPlayer.setController(controller); 在RecyclerView或者ListView中使用时，需要监听itemView的detached： 1234567891011121314mRecyclerView.addOnChildAttachStateChangeListener(new RecyclerView.OnChildAttachStateChangeListener() &#123; @Override public void onChildViewAttachedToWindow(View view) &#123; &#125; @Override public void onChildViewDetachedFromWindow(View view) &#123; NiceVideoPlayer niceVideoPlayer = (NiceVideoPlayer) view.findViewById(R.id.nice_video_player); if (niceVideoPlayer != null) &#123; niceVideoPlayer.release(); &#125; &#125;&#125;); 在ItemViewdetach窗口时，需要释放掉itemView内部的播放器。 效果图 最后整个功能有参考节操播放器，但是自己这样封装和节操播放器还是有很大差异：一是分离了播放功能和控制界面，定制只需修改控制器即可。二是全屏/小窗口没有新建一个播放器，只是挪动了播放界面和控制器，不用每个视频都需要新建两个播放器，也不用同步状态。 MediaPlayer有很多格式不支持，项目已添加IjkPlayer的扩展支持，可以切换IjkPlayer和原生MediaPlayer，后续还会考虑添加ExoPlayer，同时也会扩展更多功能。 如果有错误和更好的建议都请提出，源码已上传GitHub，欢迎Star，谢谢！。 源码：https://github.com/xiaoyanger0825/NiceVieoPlayer 参考：Android TextureView简易教程视频画面帧的展示控件SurfaceView及TextureView对比Android 5.0(Lollipop)中的SurfaceTexture，TextureView, SurfaceView和GLSurfaceViewAndroid MediaPlayer生命周期详解节操播放器 https://github.com/lipangit/JieCaoVideoPlayer]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>视频播放</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus封装]]></title>
    <url>%2F2017%2F05%2F11%2FEventBus%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[EventBus是一款针对Android优化的发布/订阅事件总线。可以替代广播、startActivityForResult、Handler、异步回调等来实现各组件间、组件与后台线程间的通信。它的优点是开销小，代码更优雅，以及将发送者和接收者解耦。 通常我们在使用EventBus的时候都是直接需要接收通信的Activity/Fragment中通过EventBus.getDefault().register(this)订阅事件，在需要发起通信的逻辑直接调用EventBus.getDefault().post(Object event)来发布事件。但是要是一个项目中有很多地方都使用EventBus来通信，比如重新登录后更新各个页面的登录状态，或者是接收到通知更新消息提示等，都这样直接使用的话代码重复率很高，并且呢，如果以后升级或者更换EventBus时，各个地方都要修改，这就比较麻烦了。因此我一般是将EventBus的发布和订阅封装到BaseActivity/BaseFragment中。 在Gradle中添加EventBus依赖： 1compile &apos;org.greenrobot:eventbus:3.0.0&apos; 封装一下EventBus的订阅、取消订阅、发布等方法： 1234567891011121314151617181920public class EventBusUtil &#123; public static void register(Object subscriber) &#123; EventBus.getDefault().register(subscriber); &#125; public static void unregister(Object subscriber) &#123; EventBus.getDefault().unregister(subscriber); &#125; public static void sendEvent(Event event) &#123; EventBus.getDefault().post(event); &#125; public static void sendStickyEvent(Event event) &#123; EventBus.getDefault().postSticky(event); &#125; // 其他&#125; 在BaseActivity/BaseFragment中的onCreate和onDestroy方法中订阅和取消订阅，这里添加了一个isRegisterEventBus()方法，默认返回false，即不订阅EventBus，子类Activity/Fragment如果需要订阅的话复写这个方法并返回true即可。 12345678910111213141516171819202122232425@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (isRegisterEventBus()) &#123; EventBusUtil.register(this); &#125;&#125;/** * 是否注册事件分发 * * @return true绑定EventBus事件分发，默认不绑定，子类需要绑定的话复写此方法返回true. */protected boolean isRegisterEventBus() &#123; return false;&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); if (isRegisterEventBus()) &#123; EventBusUtil.unregister(this); &#125;&#125; 定义事件Event： 1234567891011121314151617181920212223242526272829public class Event&lt;T&gt; &#123; private int code; private T data; public Event(int code) &#123; this.code = code; &#125; public Event(int code, T data) &#123; this.code = code; this.data = data; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 通过泛型&lt;T&gt;指定事件通信过程中的数据类型，code为事件码，使用的时候给不同的事件类型指定不同的code。 在BaseActivity\BaseFragment中添加接收到EventBus的方法： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 是否注册事件分发 * * @return true绑定EventBus事件分发，默认不绑定，子类需要绑定的话复写此方法返回true. */protected boolean isRegisterEventBus() &#123; return false;&#125;@Subscribe(threadMode = ThreadMode.MAIN)public void onEventBusCome(Event event) &#123; if (event != null) &#123; receiveEvent(event); &#125;&#125;@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)public void onStickyEventBusCome(Event event) &#123; if (event != null) &#123; receiveStickyEvent(event); &#125;&#125;/** * 接收到分发到事件 * * @param event 事件 */protected void receiveEvent(Event event) &#123;&#125;/** * 接受到分发的粘性事件 * * @param event 粘性事件 */protected void receiveStickyEvent(Event event) &#123;&#125; 根据自己项目的需求，在订阅了EventBus的Activity/Fragment中复写receiveEvent(Event event)或receiveStickyEvent(Event event)来处理接收到事件后的逻辑。 这里也可以不用在BaseActivty/BaseFragment中添加接受事件的方法（因为添加了过后不能确定的子类的Event泛型）。那么就直接在订阅的Activity/Fragment中给接收事件的方法添加EventBus对应的事件接受注解，并指定参数Event的泛型。 123456@Subscribe(threadMode = ThreadMode.MAIN)public void onEventReceived(Event&lt;User&gt; event) &#123; if (event != null &amp;&amp; event.getCode() == C.EventCode.C) &#123; User user = event.getData(); &#125;&#125; 在给定Event的code的时候最好在常量池中定义一个类专门用来定义不同类型的EventBus的code，这样在接收到EventBus的地方可以根据这些code值来判断Event的来源。 12345678910public final class C &#123; // EventBus Code public static final class EventCode &#123; public static final int A = 0x111111; public static final int B = 0x222222; public static final int C = 0x333333; public static final int D = 0x444444; // other more &#125;&#125; 使用示例：在MainActivity中复写isRegisterEventBus()并返回true注册EventBus，复写receiveEvent(Event event)接收发布的事件。 12345678910111213141516171819202122232425@Overrideprotected boolean isRegisterEventBus() &#123; return true;&#125;@Overrideprotected void receiveEvent(Event event) &#123; // 接受到Event后的相关逻辑 switch (event.getCode()) &#123; case C.EventCode.A: Log.d(&quot;EventBus&quot;, &quot;接收到A类型的Event&quot;); break; case C.EventCode.B: Log.d(&quot;EventBus&quot;, &quot;接收到B类型的Event&quot;); break; case C.EventCode.C: Log.d(&quot;EventBus&quot;, &quot;接收到B类型的Event，携带User&quot;); User user = (User) event.getData(); break; case C.EventCode.D: Log.d(&quot;EventBus&quot;, &quot;接收到D类型的Event，携带News&quot;); News news = (News) event.getData(); break; &#125;&#125; 在receiveEvent(Event event)根据对应的事件的code，判断通信的数据来源和传递的数据类型，以完成对应的逻辑。 在InfoActivity中发送事件，InfoActivity只发送不需要接收Event的话就不注册，也不用复写isRegisterEventBus()和receiveEvent(Event event)方法了。 1234567891011121314151617public void sendEventA(View view) &#123; EventBusUtil.sendEvent(new Event(C.EventCode.A));&#125;public void sendEventB(View view) &#123; EventBusUtil.sendEvent(new Event(C.EventCode.B));&#125;public void sendEventC(View view) &#123; Event&lt;User&gt; event = new Event&lt;&gt;(C.EventCode.C, new User()); EventBusUtil.sendEvent(event);&#125;public void sendEventD(View view) &#123; Event&lt;News&gt; event = new Event&lt;&gt;(C.EventCode.D, new News()); EventBusUtil.sendEvent(event);&#125; 通过上面的方式，将EventBus封装到BaseActivity/BaseFragment中，使得EventBus和项目解耦更加彻底，同时在需要使用的子Activity/Fragment中只需要复写isRegisterEventBus()和receiveEvent(Event event)即可，不用每个地方都去订阅和取消订阅。并且给Event给定code和泛型能够很好的区分不同的事件来源和数据类型。 源码：https://github.com/xiaoyanger0825/EventBusExample]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存优化——内存泄露检测分析方法]]></title>
    <url>%2F2017%2F04%2F25%2FAndroid%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[上一篇文章总结了一些常见的内存泄露场景及优化方案，这篇文章继续总结内存泄露的一些常用的检测和分析方法。 Lint代码检查AndroidStudio自动Lint代码检查工具，一些常见的代码警告Lint工具都会给我们提示。使用也比较简单： Analyze —&gt; Inspect Code 然后选择检查范围： 比如如果存在非静态内部类的Handler，可能会导致内存泄露，检查结果就会显示在AndroidStudio的控制台。 其实，只要我们在设置里面勾选了Lint代码检查（AnroidStudio默认是勾选了的），在写代码的时候就会自动提示可能发生内存泄露。 通常在写Handler、静态字段、标记对象等可能存在的内存泄露时，Lint检查工具都会有一个警告提示信息，我们可以根据Lint检查的提示信息来避免这些有可能发生的内存泄露。 Android Monitor在AndroidStudio中，可以通过Monitors来监控Memory、CPU、Network、GPU等。在Monitors监控中，我们可以获取内存的各种信息来分析内存泄露。 首先运行工程后，打开控制台的Android Monitor： 在运行设备中使用app（各个页面的跳转，使用相应的各种功能），就可以看到内存使用的不断变化： 淡蓝色和浅灰色区域就是内存分配的变化过程，浅灰色表示空闲内存，淡蓝色表示使用内存。 通常，我们在打开一个新的页面后，使用的内存就会增加，相应的，关闭一个页面后，系统执行了GC，使用的内存应该下降。如果我们在退出界面并执行GC后，内存使用并未下降明显，或者使用内存没有下降初始的使用大小，那么有可能就发生了内存泄露。 运行工程，在设备上操作app，观察Monitor中内存的变化，点击 initiate GC 触发GC，然后点击Dump Java Heap转出堆信息，稍等片刻，生成hprof文件，生成后会在Studio中自动打开。 点击右侧的Analyzer Tasks，再点击Perform Analyzer，展开下面分析结果中的 Leaked Activities 就可以看到发生内存泄露的Activity了。 可以根据左侧的引用树，来查找持有Activity引用的位置，从而判断出哪个地方导致了内存泄露。 Mat使用第三方的Mat工具来分析内存泄露，需要在官网下载独立版的Mat。 将Android Monitor生成的hprof文件导出为标准的hprof文件（必须这样导出，直接copy出来会报错的）： 使用Mat打开导出的hprof文件： 点击Histogram（直方图），可以看到类对应的实例数量的统计。 在Class Name下面输入需要匹配的类名，根据类来查看它的实例的引用，进而分析是否存在内存泄露。 可以看到TestActivity和MyHandler都只有一个实例被引用。 TestActivity点击右键—&gt;Merge Shortest Paths to GC Roots —&gt;exclude all phantom/weak/soft etc.references。 Merge Shortest Paths to GC Roots 可以查看一个对象到RC Roots是否存在引用链相连接， 在JAVA中是通过可达性（Reachability Analysis)来判断对象是否存活，这个算法的基本思想是通过一系列的称谓”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走得路径称为引用链，当一个对象到GC Roots没有任何引用链相连则该对象被判定为可以被回收的对象，反之不能被回收，我们可以选择 exclude all phantom/weak/soft etc.references(排查虚引用/弱引用/软引用等）因为被虚引用/弱引用/软引用的对象可以直接被GC给回收。 参考自Android 性能优化之使用MAT分析内存泄露问题。 可以看到TestActivity实例存在GC Roots链，TextActivity实例被mMessageQueue.mMessae.target.this$0持有，那么发生了内存泄露，我们可以根据引用链来在代码中找到内存泄露的位置。 LeakCanaryLeakCanary是square开源的检测内存泄露的第三方库。它最大的有点就是开发者只需要添加简单代码，app在运行时如果发生了内存泄露，就会很直观的将内存泄露的详细信息展示在通知栏上，这样避免了Android Monitor或者Mat等工具的繁琐的分析过程。 项目地址：https://github.com/square/leakcanary 在Gradle文件中添加依赖：12345dependencies &#123; debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5&apos; releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos; testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos;&#125; 在入口的Application中进行初始化： 1234567891011121314151617public class App extends Application &#123; // 模拟内存泄露场景 public static ArrayList&lt;Activity&gt; sActivities = new ArrayList&lt;&gt;(); @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; &#125; LeakCanary.install(this); // Normal app init code... &#125;&#125; 在Application中新建一个静态List，里面存储Activity，来模拟内存泄露案例： 12345678910111213public class TestActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); App.sActivities.add(this); &#125; public void back(View view) &#123; finish(); &#125;&#125; 运行app后，在控制台可以看到LeakCanary的日志：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814904-25 10:20:46.793 D/LeakCanary: In com.xiao.memoryleakexample:1.0:1.04-25 10:20:46.793 D/LeakCanary: * com.xiao.memoryleakexample.TestActivity has leaked:04-25 10:20:46.793 D/LeakCanary: * GC ROOT static com.xiao.memoryleakexample.app.App.sActivities04-25 10:20:46.793 D/LeakCanary: * references java.util.ArrayList.array04-25 10:20:46.793 D/LeakCanary: * references array java.lang.Object[].[0]04-25 10:20:46.793 D/LeakCanary: * leaks com.xiao.memoryleakexample.TestActivity instance04-25 10:20:46.793 D/LeakCanary: * Retaining: 88 KB.04-25 10:20:46.793 D/LeakCanary: * Reference Key: 915bf11a-db9f-468e-8064-d6fb103710e904-25 10:20:46.793 D/LeakCanary: * Device: OPPO OPPO OPPO R9 Plusm A R9PlusmA04-25 10:20:46.793 D/LeakCanary: * Android Version: 5.1.1 API: 22 LeakCanary: 1.5 00f37f504-25 10:20:46.793 D/LeakCanary: * Durations: watch=5049ms, gc=207ms, heap dump=979ms, analysis=122889ms04-25 10:20:46.793 D/LeakCanary: * Details:04-25 10:20:46.793 D/LeakCanary: * Class com.xiao.memoryleakexample.app.App04-25 10:20:46.793 D/LeakCanary: | static $staticOverhead = byte[24]@314667009 (0x12c17001)04-25 10:20:46.793 D/LeakCanary: | static sActivities = java.util.ArrayList@315492800 (0x12ce09c0)04-25 10:20:46.793 D/LeakCanary: | static serialVersionUID = -92032464954470712704-25 10:20:46.793 D/LeakCanary: | static $change = null04-25 10:20:46.793 D/LeakCanary: * Instance of java.util.ArrayList04-25 10:20:46.793 D/LeakCanary: | static $staticOverhead = byte[16]@1893824473 (0x70e177d9)04-25 10:20:46.793 D/LeakCanary: | static MIN_CAPACITY_INCREMENT = 1204-25 10:20:46.793 D/LeakCanary: | static serialVersionUID = 868345258112289218904-25 10:20:46.793 D/LeakCanary: | array = java.lang.Object[12]@318048768 (0x12f50a00)04-25 10:20:46.793 D/LeakCanary: | size = 104-25 10:20:46.793 D/LeakCanary: | modCount = 104-25 10:20:46.793 D/LeakCanary: * Array of java.lang.Object[]04-25 10:20:46.793 D/LeakCanary: | [0] = com.xiao.memoryleakexample.TestActivity@316091520 (0x12d72c80)04-25 10:20:46.793 D/LeakCanary: | [1] = null04-25 10:20:46.793 D/LeakCanary: | [2] = null04-25 10:20:46.793 D/LeakCanary: | [3] = null04-25 10:20:46.793 D/LeakCanary: | [4] = null04-25 10:20:46.793 D/LeakCanary: | [5] = null04-25 10:20:46.793 D/LeakCanary: | [6] = null04-25 10:20:46.793 D/LeakCanary: | [7] = null04-25 10:20:46.793 D/LeakCanary: | [8] = null04-25 10:20:46.793 D/LeakCanary: | [9] = null04-25 10:20:46.793 D/LeakCanary: | [10] = null04-25 10:20:46.793 D/LeakCanary: | [11] = null04-25 10:20:46.793 D/LeakCanary: * Instance of com.xiao.memoryleakexample.TestActivity04-25 10:20:46.793 D/LeakCanary: | static $staticOverhead = byte[16]@316125185 (0x12d7b001)04-25 10:20:46.793 D/LeakCanary: | static serialVersionUID = 83699886327408699704-25 10:20:46.793 D/LeakCanary: | static $change = null04-25 10:20:46.793 D/LeakCanary: | mHandler = com.xiao.memoryleakexample.TestActivity$MyHandler@318005952 (0x12f462c0)04-25 10:20:46.793 D/LeakCanary: | mDelegate = android.support.v7.app.AppCompatDelegateImplV14@314816320 (0x12c3b740)04-25 10:20:46.793 D/LeakCanary: | mEatKeyUpEvent = false04-25 10:20:46.793 D/LeakCanary: | mResources = null04-25 10:20:46.793 D/LeakCanary: | mThemeId = 213123088404-25 10:20:46.793 D/LeakCanary: | mCreated = true04-25 10:20:46.793 D/LeakCanary: | mFragments = android.support.v4.app.FragmentController@317876896 (0x12f26aa0)04-25 10:20:46.793 D/LeakCanary: | mHandler = android.support.v4.app.FragmentActivity$1@318005920 (0x12f462a0)04-25 10:20:46.793 D/LeakCanary: | mNextCandidateRequestIndex = 004-25 10:20:46.793 D/LeakCanary: | mOptionsMenuInvalidated = false04-25 10:20:46.793 D/LeakCanary: | mPendingFragmentActivityResults = android.support.v4.util.SparseArrayCompat@318008352 (0x12f46c20)04-25 10:20:46.793 D/LeakCanary: | mReallyStopped = true04-25 10:20:46.793 D/LeakCanary: | mRequestedPermissionsFromFragment = false04-25 10:20:46.793 D/LeakCanary: | mResumed = false04-25 10:20:46.793 D/LeakCanary: | mRetaining = false04-25 10:20:46.793 D/LeakCanary: | mStopped = true04-25 10:20:46.793 D/LeakCanary: | mStartedActivityFromFragment = false04-25 10:20:46.793 D/LeakCanary: | mStartedIntentSenderFromFragment = false04-25 10:20:46.793 D/LeakCanary: | mExtraDataMap = android.support.v4.util.SimpleArrayMap@318005888 (0x12f46280)04-25 10:20:46.793 D/LeakCanary: | mActionBar = null04-25 10:20:46.793 D/LeakCanary: | mActivityInfo = android.content.pm.ActivityInfo@318009472 (0x12f47080)04-25 10:20:46.793 D/LeakCanary: | mActivityTransitionState = android.app.ActivityTransitionState@317937344 (0x12f356c0)04-25 10:20:46.793 D/LeakCanary: | mAllLoaderManagers = android.util.ArrayMap@318081312 (0x12f58920)04-25 10:20:46.793 D/LeakCanary: | mApplication = com.xiao.memoryleakexample.app.App@315492832 (0x12ce09e0)04-25 10:20:46.793 D/LeakCanary: | mCalled = true04-25 10:20:46.793 D/LeakCanary: | mChangeCanvasToTranslucent = false04-25 10:20:46.793 D/LeakCanary: | mChangingConfigurations = false04-25 10:20:46.793 D/LeakCanary: | mCheckedForLoaderManager = true04-25 10:20:46.793 D/LeakCanary: | mComponent = android.content.ComponentName@314990768 (0x12c660b0)04-25 10:20:46.793 D/LeakCanary: | mConfigChangeFlags = 004-25 10:20:46.793 D/LeakCanary: | mContainer = android.app.Activity$1@317876848 (0x12f26a70)04-25 10:20:46.793 D/LeakCanary: | mCurrentConfig = android.content.res.Configuration@317856672 (0x12f21ba0)04-25 10:20:46.793 D/LeakCanary: | mDecor = null04-25 10:20:46.793 D/LeakCanary: | mDefaultKeyMode = 004-25 10:20:46.793 D/LeakCanary: | mDefaultKeySsb = null04-25 10:20:46.793 D/LeakCanary: | mDestroyed = true04-25 10:20:46.793 D/LeakCanary: | mDoReportFullyDrawn = false04-25 10:20:46.793 D/LeakCanary: | mEmbeddedID = null04-25 10:20:46.793 D/LeakCanary: | mEnableDefaultActionBarUp = false04-25 10:20:46.793 D/LeakCanary: | mEnterTransitionListener = android.app.SharedElementCallback$1@1893595344 (0x70ddf8d0)04-25 10:20:46.793 D/LeakCanary: | mExitTransitionListener = android.app.SharedElementCallback$1@1893595344 (0x70ddf8d0)04-25 10:20:46.793 D/LeakCanary: | mFinished = true04-25 10:20:46.793 D/LeakCanary: | mFragments = android.app.FragmentManagerImpl@317856448 (0x12f21ac0)04-25 10:20:46.793 D/LeakCanary: | mHandler = android.os.Handler@318005856 (0x12f46260)04-25 10:20:46.793 D/LeakCanary: | mIdent = 57802512304-25 10:20:46.793 D/LeakCanary: | mInstanceTracker = android.os.StrictMode$InstanceTracker@317876864 (0x12f26a80)04-25 10:20:46.793 D/LeakCanary: | mInstrumentation = android.app.Instrumentation@315352176 (0x12cbe470)04-25 10:20:46.793 D/LeakCanary: | mIntent = android.content.Intent@317362304 (0x12ea9080)04-25 10:20:46.793 D/LeakCanary: | mLastNonConfigurationInstances = null04-25 10:20:46.793 D/LeakCanary: | mLoaderManager = null04-25 10:20:46.793 D/LeakCanary: | mLoadersStarted = false04-25 10:20:46.793 D/LeakCanary: | mMainThread = android.app.ActivityThread@314856000 (0x12c45240)04-25 10:20:46.803 D/LeakCanary: | mManagedCursors = java.util.ArrayList@318005792 (0x12f46220)04-25 10:20:46.803 D/LeakCanary: | mManagedDialogs = null04-25 10:20:46.803 D/LeakCanary: | mMenuInflater = null04-25 10:20:46.803 D/LeakCanary: | mParent = null04-25 10:20:46.803 D/LeakCanary: | mReferrer = java.lang.String@314984512 (0x12c64840)04-25 10:20:46.803 D/LeakCanary: | mResultCode = 004-25 10:20:46.803 D/LeakCanary: | mResultData = null04-25 10:20:46.803 D/LeakCanary: | mResumed = false04-25 10:20:46.803 D/LeakCanary: | mSearchManager = null04-25 10:20:46.803 D/LeakCanary: | mStartedActivity = false04-25 10:20:46.803 D/LeakCanary: | mStopped = true04-25 10:20:46.803 D/LeakCanary: | mTemporaryPause = false04-25 10:20:46.803 D/LeakCanary: | mTitle = java.lang.String@316164352 (0x12d84900)04-25 10:20:46.803 D/LeakCanary: | mTitleColor = 004-25 10:20:46.803 D/LeakCanary: | mTitleReady = true04-25 10:20:46.803 D/LeakCanary: | mToken = android.os.BinderProxy@314983040 (0x12c64280)04-25 10:20:46.803 D/LeakCanary: | mTranslucentCallback = null04-25 10:20:46.803 D/LeakCanary: | mUiThread = java.lang.Thread@1967775656 (0x7549dfa8)04-25 10:20:46.803 D/LeakCanary: | mVisibleBehind = false04-25 10:20:46.803 D/LeakCanary: | mVisibleFromClient = true04-25 10:20:46.803 D/LeakCanary: | mVisibleFromServer = true04-25 10:20:46.803 D/LeakCanary: | mVoiceInteractor = null04-25 10:20:46.803 D/LeakCanary: | mWindow = com.android.internal.policy.impl.PhoneWindow@315631936 (0x12d02940)04-25 10:20:46.803 D/LeakCanary: | mWindowAdded = true04-25 10:20:46.803 D/LeakCanary: | mWindowManager = android.view.WindowManagerImpl@318006848 (0x12f46640)04-25 10:20:46.803 D/LeakCanary: | mInflater = com.android.internal.policy.impl.PhoneLayoutInflater@317929312 (0x12f33760)04-25 10:20:46.803 D/LeakCanary: | mOverrideConfiguration = null04-25 10:20:46.803 D/LeakCanary: | mResources = android.content.res.Resources@314591360 (0x12c04880)04-25 10:20:46.803 D/LeakCanary: | mTheme = android.content.res.Resources$Theme@318006400 (0x12f46480)04-25 10:20:46.803 D/LeakCanary: | mThemeResource = 213123088404-25 10:20:46.803 D/LeakCanary: | mBase = android.app.ContextImpl@317145792 (0x12e742c0)04-25 10:20:46.803 D/LeakCanary: * Excluded Refs:04-25 10:20:46.803 D/LeakCanary: | Field: android.view.inputmethod.InputMethodManager.mNextServedView04-25 10:20:46.803 D/LeakCanary: | Field: android.view.inputmethod.InputMethodManager.mServedView04-25 10:20:46.803 D/LeakCanary: | Field: android.view.inputmethod.InputMethodManager.mServedInputConnection04-25 10:20:46.803 D/LeakCanary: | Field: android.view.inputmethod.InputMethodManager.mCurRootView04-25 10:20:46.803 D/LeakCanary: | Field: android.animation.LayoutTransition$1.val$parent04-25 10:20:46.803 D/LeakCanary: | Field: android.view.textservice.SpellCheckerSession$1.this$004-25 10:20:46.803 D/LeakCanary: | Field: android.support.v7.internal.widget.ActivityChooserModel.mActivityChoserModelPolicy04-25 10:20:46.803 D/LeakCanary: | Field: android.widget.ActivityChooserModel.mActivityChoserModelPolicy04-25 10:20:46.803 D/LeakCanary: | Field: android.accounts.AccountManager$AmsTask$Response.this$104-25 10:20:46.803 D/LeakCanary: | Field: android.media.MediaScannerConnection.mContext04-25 10:20:46.803 D/LeakCanary: | Field: android.os.UserManager.mContext04-25 10:20:46.803 D/LeakCanary: | Field: android.media.AudioManager$1.this$004-25 10:20:46.803 D/LeakCanary: | Field: android.widget.Editor$Blink.this$004-25 10:20:46.803 D/LeakCanary: | Field: android.net.ConnectivityManager.sInstance04-25 10:20:46.803 D/LeakCanary: | Field: android.view.Choreographer$FrameDisplayEventReceiver.mMessageQueue (always)04-25 10:20:46.803 D/LeakCanary: | Static field: android.text.TextLine.sCached04-25 10:20:46.803 D/LeakCanary: | Thread:FinalizerWatchdogDaemon (always)04-25 10:20:46.803 D/LeakCanary: | Thread:main (always)04-25 10:20:46.803 D/LeakCanary: | Thread:LeakCanary-Heap-Dump (always)04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.WeakReference (always)04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.SoftReference (always)04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.PhantomReference (always)04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.Finalizer (always)04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.FinalizerReference (always) 日志当中展示了详细的内存泄露信息。同时，在运行设备上，会以通知的形式展示内存泄露： 点击通知栏后会展示消息的内存泄露信息，包括泄露的具体实例、以及发生在哪个类中的具体引用位置： 最后Lint、Android Monitor、Mat，以及LeakCanary都能让我们在平常的开发过程中非常有效的避免内存泄露，至于选择哪个工具，那种方式，就看自己平常的习惯了。个人还是更喜欢使用LeakCanary，只需要简单的集成，就可以更加快速，直观展示内存泄露的信息。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存优化——常见内存泄露及优化方案]]></title>
    <url>%2F2017%2F04%2F13%2FAndroid%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[如果一个无用对象（不需要再使用的对象）仍然被其他对象持有引用，造成该对象无法被系统回收，以致该对象在堆中所占用的内存单元无法被释放而造成内存空间浪费，这中情况就是内存泄露。 在Android开发中，一些不好的编程习惯会导致我们的开发的app存在内存泄露的情况。下面介绍一些在Android开发中常见的内存泄露场景及优化方案。 单例导致内存泄露单例模式在Android开发中会经常用到，但是如果使用不当就会导致内存泄露。因为单例的静态特性使得它的生命周期同应用的生命周期一样长，如果一个对象已经没有用处了，但是单例还持有它的引用，那么在整个应用程序的生命周期它都不能正常被回收，从而导致内存泄露。12345678910111213141516public class AppSettings &#123; private static AppSettings sInstance; private Context mContext; private AppSettings(Context context) &#123; this.mContext = context; &#125; public static AppSettings getInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new AppSettings(context); &#125; return sInstance; &#125;&#125; 像上面代码中这样的单例，如果我们在调用getInstance(Context context)方法的时候传入的context参数是Activity、Service等上下文，就会导致内存泄露。 以Activity为例，当我们启动一个Activity，并调用getInstance(Context context)方法去获取AppSettings的单例，传入Activity.this作为context，这样AppSettings类的单例sInstance就持有了Activity的引用，当我们退出Activity时，该Activity就没有用了，但是因为sIntance作为静态单例（在应用程序的整个生命周期中存在）会继续持有这个Activity的引用，导致这个Activity对象无法被回收释放，这就造成了内存泄露。 为了避免这样单例导致内存泄露，我们可以将context参数改为全局的上下文：123private AppSettings(Context context) &#123; this.mContext = context.getApplicationContext();&#125; 全局的上下文Application Context就是应用程序的上下文，和单例的生命周期一样长，这样就避免了内存泄漏。 单例模式对应应用程序的生命周期，所以我们在构造单例的时候尽量避免使用Activity的上下文，而是使用Application的上下文。 静态变量导致内存泄露静态变量存储在方法区，它的生命周期从类加载开始，到整个进程结束。一旦静态变量初始化后，它所持有的引用只有等到进程结束才会释放。 比如下面这样的情况，在Activity中为了避免重复的创建info，将sInfo作为静态变量：123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private static Info sInfo; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (sInfo != null) &#123; sInfo = new Info(this); &#125; &#125;&#125;class Info &#123; public Info(Activity activity) &#123; &#125;&#125; Info作为Activity的静态成员，并且持有Activity的引用，但是sInfo作为静态变量，生命周期肯定比Activity长。所以当Activity退出后，sInfo仍然引用了Activity，Activity不能被回收，这就导致了内存泄露。 在Android开发中，静态持有很多时候都有可能因为其使用的生命周期不一致而导致内存泄露，所以我们在新建静态持有的变量的时候需要多考虑一下各个成员之间的引用关系，并且尽量少地使用静态持有的变量，以避免发生内存泄露。当然，我们也可以在适当的时候讲静态量重置为null，使其不再持有引用，这样也可以避免内存泄露。 非静态内部类导致内存泄露非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。 非静态内部类导致的内存泄露在Android开发中有一种典型的场景就是使用Handler，很多开发者在使用Handler是这样写的：123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); start(); &#125; private void start() &#123; Message msg = Message.obtain(); msg.what = 1; mHandler.sendMessage(msg); &#125; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == 1) &#123; // 做相应逻辑 &#125; &#125; &#125;;&#125; 也许有人会说，mHandler并未作为静态变量持有Activity引用，生命周期可能不会比Activity长，应该不一定会导致内存泄露呢，显然不是这样的！ 熟悉Handler消息机制的都知道，mHandler会作为成员变量保存在发送的消息msg中，即msg持有mHandler的引用，而mHandler是Activity的非静态内部类实例，即mHandler持有Activity的引用，那么我们就可以理解为msg间接持有Activity的引用。msg被发送后先放到消息队列MessageQueue中，然后等待Looper的轮询处理（MessageQueue和Looper都是与线程相关联的，MessageQueue是Looper引用的成员变量，而Looper是保存在ThreadLocal中的）。那么当Activity退出后，msg可能仍然存在于消息对列MessageQueue中未处理或者正在处理，那么这样就会导致Activity无法被回收，以致发生Activity的内存泄露。 通常在Android开发中如果要使用内部类，但又要规避内存泄露，一般都会采用静态内部类+弱引用的方式。12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity &#123; private Handler mHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandler = new MyHandler(this); start(); &#125; private void start() &#123; Message msg = Message.obtain(); msg.what = 1; mHandler.sendMessage(msg); &#125; private static class MyHandler extends Handler &#123; private WeakReference&lt;MainActivity&gt; activityWeakReference; public MyHandler(MainActivity activity) &#123; activityWeakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = activityWeakReference.get(); if (activity != null) &#123; if (msg.what == 1) &#123; // 做相应逻辑 &#125; &#125; &#125; &#125;&#125; mHandler通过弱引用的方式持有Activity，当GC执行垃圾回收时，遇到Activity就会回收并释放所占据的内存单元。这样就不会发生内存泄露了。 上面的做法确实避免了Activity导致的内存泄露，发送的msg不再已经没有持有Activity的引用了，但是msg还是有可能存在消息队列MessageQueue中，所以更好的是在Activity销毁时就将mHandler的回调和发送的消息给移除掉。12345@Overrideprotected void onDestroy() &#123; super.onDestroy(); mHandler.removeCallbacksAndMessages(null);&#125; 非静态内部类造成内存泄露还有一种情况就是使用Thread或者AsyncTask。 比如在Activity中直接new一个子线程Thread：12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; // 模拟相应耗时逻辑 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125; 或者直接新建AsyncTask异步任务：1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... params) &#123; // 模拟相应耗时逻辑 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125;.execute(); &#125;&#125; 很多初学者都会像上面这样新建线程和异步任务，殊不知这样的写法非常地不友好，这种方式新建的子线程Thread和AsyncTask都是匿名内部类对象，默认就隐式的持有外部Activity的引用，导致Activity内存泄露。要避免内存泄露的话还是需要像上面Handler一样使用静态内部类+弱应用的方式（代码就不列了，参考上面Hanlder的正确写法）。 未取消注册或回调导致内存泄露比如我们在Activity中注册广播，如果在Activity销毁后不取消注册，那么这个刚播会一直存在系统中，同上面所说的非静态内部类一样持有Activity引用，导致内存泄露。因此注册广播后在Activity销毁后一定要取消注册。12345678910111213141516171819202122public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.registerReceiver(mReceiver, new IntentFilter()); &#125; private BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // 接收到广播需要做的逻辑 &#125; &#125;; @Override protected void onDestroy() &#123; super.onDestroy(); this.unregisterReceiver(mReceiver); &#125;&#125; 在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用Retrofit+RxJava注册网络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候取消注册。 Timer和TimerTask导致内存泄露Timer和TimerTask在Android中通常会被用来做一些计时或循环任务，比如实现无限轮播的ViewPager：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; private ViewPager mViewPager; private PagerAdapter mAdapter; private Timer mTimer; private TimerTask mTimerTask; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); mTimer.schedule(mTimerTask, 3000, 3000); &#125; private void init() &#123; mViewPager = (ViewPager) findViewById(R.id.view_pager); mAdapter = new ViewPagerAdapter(); mViewPager.setAdapter(mAdapter); mTimer = new Timer(); mTimerTask = new TimerTask() &#123; @Override public void run() &#123; MainActivity.this.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; loopViewpager(); &#125; &#125;); &#125; &#125;; &#125; private void loopViewpager() &#123; if (mAdapter.getCount() &gt; 0) &#123; int curPos = mViewPager.getCurrentItem(); curPos = (++curPos) % mAdapter.getCount(); mViewPager.setCurrentItem(curPos); &#125; &#125; private void stopLoopViewPager() &#123; if (mTimer != null) &#123; mTimer.cancel(); mTimer.purge(); mTimer = null; &#125; if (mTimerTask != null) &#123; mTimerTask.cancel(); mTimerTask = null; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); stopLoopViewPager(); &#125;&#125; 当我们Activity销毁的时，有可能Timer还在继续等待执行TimerTask，它持有Activity的引用不能被回收，因此当我们Activity销毁的时候要立即cancel掉Timer和TimerTask，以避免发生内存泄漏。 集合中的对象未清理造成内存泄露这个比较好理解，如果一个对象放入到ArrayList、HashMap等集合中，这个集合就会持有该对象的引用。当我们不再需要这个对象时，也并没有将它从集合中移除，这样只要集合还在使用（而此对象已经无用了），这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那些没有用的对象更会造成内存泄露了。所以在使用集合时要及时将不用的对象从集合remove，或者clear集合，以避免内存泄漏。 资源未关闭或释放导致内存泄露在使用IO、File流或者Sqlite、Cursor等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果及时不关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。因此我们在不需要使用它们的时候就及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。 属性动画造成内存泄露动画同样是一个耗时任务，比如在Activity中启动了属性动画（ObjectAnimator），但是在销毁的时候，没有调用cancle方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用Activity，这就造成Activity无法正常释放。因此同样要在Activity销毁的时候cancel掉属性动画，避免发生内存泄漏。12345@Overrideprotected void onDestroy() &#123; super.onDestroy(); mAnimator.cancel();&#125; WebView造成内存泄露关于WebView的内存泄露，因为WebView在加载网页后会长期占用内存而不能被释放，因此我们在Activity销毁后要调用它的destory()方法来销毁它以释放内存。 另外在查阅WebView内存泄露相关资料时看到这种情况： Webview下面的Callback持有Activity引用，造成Webview内存无法释放，即使是调用了Webview.destory()等方法都无法解决问题（Android5.1之后）。 最终的解决方案是：在销毁WebView之前需要先将WebView从父容器中移除，然后在销毁WebView。详细分析过程请参考这篇文章：WebView内存泄漏解决方法。1234567891011@Overrideprotected void onDestroy() &#123; super.onDestroy(); // 先从父控件中移除WebView mWebViewContainer.removeView(mWebView); mWebView.stopLoading(); mWebView.getSettings().setJavaScriptEnabled(false); mWebView.clearHistory(); mWebView.removeAllViews(); mWebView.destroy();&#125; 总结内存泄露在Android内存优化是一个比较重要的一个方面，很多时候程序中发生了内存泄露我们不一定就能注意到，所有在编码的过程要养成良好的习惯。总结下来只要做到以下这几点就能避免大多数情况的内存泄漏： 构造单例的时候尽量别用Activity的引用；静态引用时注意应用对象的置空或者少用静态引用；使用静态内部类+软引用代替非静态内部类；及时取消广播或者观察者注册；耗时任务、属性动画在Activity销毁时记得cancel；文件流、Cursor等资源及时关闭；Activity销毁时WebView的移除和销毁。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存优化——概述]]></title>
    <url>%2F2017%2F04%2F11%2FAndroid%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Android 应用运行在 Java 虚拟机上，每打开一个 Android app 都会打开一个独立的虚拟机。运行虚拟机时会在设备的寄存器上开辟一块内存空间作为虚拟机的内存区域。虚拟机的内存区域一般划分为堆、栈、方法区/静态存储区、运行时常量池、本地方法栈等。 堆、栈堆是不连续的内存区域（因为系统是用链表来存储堆中的空闲内存地址）。堆上分配内存的过程为动态分配过程，在堆中存放由 new 关键字创建的对象或数组。堆的内存管理是由 Java 的 GC（垃圾回收机制）来管理的。通常我们所说的内存优化即是堆内存的优化。 栈是针对线程来说的，每个线程都有一个栈。栈中主要存放基本类型的变量和对象的引用，并且对象本身是没有存放在栈中，而是存放在堆中的。 当方法执行时，方法内部的局部变量被创建，基本类型的变量会直接存放在栈中，引用类型的变量则会将该引用变量在堆中的内存地址存放在栈中。方法执行结束时，这些局部变量在栈中所占的内存空间就会被释放。 举个例子：12345678910public class Person &#123; int i = 1; Girl g1 = new Girl(); public void x() &#123; int j = 1; Girl g2 = new Girl(); Girl g3 = g1; &#125;&#125; i、g1为成员变量，j、g2、g3为方法x()中的局部变量，i和g1字段属于类，类最终是要被new出来。所以i和g1存放在堆中的。j为基本类型，作为局部变量肯定是存放在栈中的。g2和g3都为引用类型，它们引用的对象实体是存放在堆中的，在栈中只存有他们的引用（堆中的内存地址），当方法执行结束后，栈中的引用被释放。 总结： 成员变量（基本类型和引用类型）全部存储在堆中；基本类型的局部变量存储在栈中；引用类型的局部变量的对象实体是存在堆中，栈中只存有它的引用。 垃圾回收器 GC栈内存的特点是效率高、速度快，并且在方法结束时就自动释放，但是它的容量有限。而堆内存空间的释放完全依赖于 GC 。在程序的运行过程中，GC 会不定时的被唤醒检查是否有没有被引用的对象，并释放他们的空间。 一般在堆内存占用较多（内存不足）的空闲时候系统可能会自动执行垃圾回收。但是垃圾回收机制只针对“垃圾”有效。所谓垃圾，是指存在于堆中，并且程序不能再访问到的对象（不可达的对象）。GC 在执行垃圾回收时，会将不可达的对象放入垃圾回收器中，而对于那些还处于引用状态即可达对象 GC 会根据该对象的引用状态来决定是否回收。 Java中对象的引用状态有强引用、软引用、弱引用、虚引用4种。 强引用强引用是使用最普遍的引用方式，我们平常使用的大部分引用都是强引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠回收具有强引用的对象来解决内存不足的问题。 软引用一个对象具有软引用，如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。12345678910111213public class Test &#123; public static void main(String[] args) &#123; Person person = new Person(); SoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person); person = null; if (sr != null) &#123; person = sr.get(); &#125; else &#123; person = new Person(); sr = new SoftReference&lt;Person&gt;(person); &#125; &#125;&#125; 弱引用在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。12345678910111213public class Test &#123; public static void main(String[] args) &#123; Person person = new Person(); WeakReference&lt;Person&gt; wr = new WeakReference&lt;Person&gt;(person); person = null; if (wr != null) &#123; person = wr.get(); &#125; else &#123; person = new Person(); wr = new WeakReference&lt;Person&gt;(person); &#125; &#125;&#125; 虚引用如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动，我们平常一般不会使用。 需要注意的是，GC 什么时候回收垃圾是无法控制的，垃圾回收时间也是无法预料的。 GC 内存管理机制虽然能帮助我们自动管理内存，避免了程序员主动释放内存的繁琐工作，但它不能解决所有的问题。GC不能回收的对象可能会导致内存泄露，甚至使整个程序发生OOM。 内存泄露当一个对象在程序执行过后已经不需要再使用了，但是有其他的对象仍然持有该对象的引用，以致该对象不能被 GC 回收，那么这个对象会一直占据内存，从而导致该内存不可用。这种本该被GC回收（不再需要用了）而又不能被回收（被其他对象持有引用）以致停留在堆内存中的对象就造成了内存泄露。 内存溢出内存溢出，OutOfMemory ，即 我们通常所说的OOM，是指程序在申请内存时，没有足够的内存空间供其使用。 在Android中，有以下几种情况可能发生内存溢出：1.内存泄露可能导致内存溢出的发生；2.一次加载的数据量过大，如一次从数据库读取过多数据；3.保存了许多耗用内存过大的对象（如Bitmap）或加载单个超大的图片，造成内存超出限制；4.代码中存在死循环或循环产生过多重复的对象实体。 GC能自动回收并释放无用的对象，但是如果程序频繁的GC也会导致一些问题。 频繁GC程序在执行GC操作的时候，任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。故而如果Andorid应用频繁GC，UI线程有可能会暂停，从而导致导致界面卡顿。 导致频繁GC主要有两个方面的原因：1.内存抖动， 即大量的对象被创建又在短时间内马上被释放。2.瞬间产生大量对象会严重占用内存区域，当达到阀值， 剩余空间不够的时候，就会触发GC。即使每次分配的对象需要占用很少的内存，但是他们叠加在一起会增加堆内存的压力， 从而触发更多的GC。 OK，Android内存优化的概述就到此为止。后面会详细介绍Android中的内存泄露及相关优化。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画总结——布局动画、转场动画]]></title>
    <url>%2F2017%2F03%2F29%2FAndroid%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%B8%83%E5%B1%80%E5%8A%A8%E7%94%BB%E3%80%81%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[之前一篇文章总结了View动画、属性动画、帧动画，这篇文章继续总结布局动画、转场动画。 布局动画布局动画的作用于ViewGroup，执行动画效果的是内部的子View。布局动画在android中可以通过LayoutAnimation或LayoutTransition来实现。 LayoutAnimationLayoutAnimation实际上是一个View动画，用来控制子View显示时的动画效果。可以通过Java代码或者Xml文件来定义LayoutAnimation动画。 通过Java代码来定义LayoutAnimation定义子View的显示动画layout_item_anim_set.xml：12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:shareInterpolator=&quot;true&quot;&gt; &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt; &lt;translate android:fromXDelta=&quot;500&quot; android:toXDelta=&quot;0&quot;/&gt;&lt;/set&gt; 以ListView为例，给ListView设置item的显示动画：1234567private void setLayoutAnimation() &#123; Animation animation = AnimationUtils.loadAnimation(this, R.anim.layout_item_anim_set); LayoutAnimationController controller = new LayoutAnimationController(animation); controller.setDelay(0.5f); controller.setOrder(LayoutAnimationController.ORDER_NORMAL); mListView.setLayoutAnimation(controller);&#125; 通过Xml代码来定义LayoutAnimation：layout_anim.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:animation=&quot;@anim/layout_item_anim_set&quot; android:animationOrder=&quot;normal&quot; android:delay=&quot;0.5&quot;&gt;&lt;/layoutAnimation&gt; 在ListView所在布局中调用：12345678&lt;ListView android:id=&quot;@+id/list_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:divider=&quot;#f1f1f1&quot; android:dividerHeight=&quot;1dp&quot; android:layoutAnimation=&quot;@anim/layout_anim&quot; android:listSelector=&quot;?android:attr/selectableItemBackground&quot;/&gt; setDelay()方法以及android:delay属性表示子View动画显示的延迟时间比例。比如动画执行时间是300ms，延迟比例是0.5，那么延迟时间就是150ms，在Listview中，第一个item在延迟150ms开始动画后，第二个在300ms后开始动画，第三个在450ms后开始，以此类推。setOder()方法以及android:animationOrder表示动画执行的顺序类型，共有三种：normal表示子View按顺序显示，reverse表示子View按逆序显示，random表示子View随机先后显示。 LayoutTransitionLayoutTransition用于在ViewGroup中有子View添加、删除、隐藏、显示时所有子View动画效果。LayoutTransition有5中动画变化形式 LayoutTransition.APPEARING：子View添加到容器中时的动画效果LayoutTransition.CHANGE_APPEARING：子View添加到容器中时，其他子View位置改变的动画效果LayoutTransition.DISAPPEARING：子View被移除时的动画效果LayoutTransition.CHANGE_DISAPPEARING：子View被移除时，其他子View的动画效果LayoutTransition.CHANGING：子View在容器中位置变化时其他子View的动画效果 使用默认的动画样式只需要在使用的LinearLayout、FrameLayout、RelativeLayout等ViewGroup容器的布局文件中添加android:animateLayoutChanges=&quot;true&quot;即可，系统会使用默认的LayoutTransition来实现子View添加、删除或变化是的动画效果。 使用自定义动画样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void init() &#123; mContainer = (LinearLayout) findViewById(R.id.container); setLayoutTransition();&#125;private void setLayoutTransition() &#123; LayoutTransition transition = new LayoutTransition(); // 子View添加到mContainer时的动画 Animator appearAnim = ObjectAnimator .ofFloat(null, &quot;rotationX&quot;, 90, 0) .setDuration(transition.getDuration(LayoutTransition.APPEARING)); transition.setAnimator(LayoutTransition.APPEARING, appearAnim); // 子Veiw从mContainer中移除时的动画 Animator disappearAnim = ObjectAnimator .ofFloat(null, &quot;rotationX&quot;, 0, 90) .setDuration(transition.getDuration(LayoutTransition.DISAPPEARING)); transition.setAnimator(LayoutTransition.DISAPPEARING, disappearAnim); // 子Veiw添加到mContainer中时其他子View的动画 PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;, 0, 0); PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;, 0, 0); PropertyValuesHolder pvhTranslationY = PropertyValuesHolder .ofFloat(&quot;translationX&quot;, 0, 150, 0); Animator changeAppearAnim = ObjectAnimator .ofPropertyValuesHolder(mContainer, pvhLeft, pvhTop, pvhTranslationY) .setDuration(transition.getDuration(LayoutTransition.CHANGE_APPEARING)); transition.setAnimator(LayoutTransition.CHANGE_APPEARING, changeAppearAnim); // 子View从mContainer中移除时其他子View的动画 PropertyValuesHolder outLeft = PropertyValuesHolder.ofInt(&quot;left&quot;, 0, 0); PropertyValuesHolder outTop = PropertyValuesHolder.ofInt(&quot;top&quot;, 0, 0); PropertyValuesHolder pvhTranslationYDis = PropertyValuesHolder .ofFloat(&quot;translationX&quot;, 0, -150, 0); ObjectAnimator changeDisAppearAnim = ObjectAnimator .ofPropertyValuesHolder(mContainer, outLeft, outTop, pvhTranslationYDis) .setDuration(transition.getDuration(LayoutTransition.CHANGE_DISAPPEARING)); transition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, changeDisAppearAnim); mContainer.setLayoutTransition(transition);&#125;// 添加子View到第0个位置public void addData(View view) &#123; View child = LayoutInflater.from(this) .inflate(R.layout.item, mContainer, false); mContainer.addView(child, 0);&#125;// 移除第0个子Viewpublic void deleteData(View view) &#123; if (mContainer.getChildCount() != 0) mContainer.removeViewAt(0);&#125; 在使用PropertyValuesHolder时，需要注意一下几点：1.LayoutTransition.CHANGE_APPEARING和LayoutTransition.CHANGE_DISAPPEARING必须使用PropertyValuesHolder构造动画才会有效果，其他任何方式构造动画都不会有效果。2.在使用PropertyValuesHolder时，”left”、”top”属性就算不需要变化也必须要写，如果不需要变化可以写成：12PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;, 0, 0);PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;, 0, 0); 3.ofInt，ofFloat中的参数值，第一个值和最后一个值必须相同，不然此属性所对应的的动画将被放弃，在此属性值上将不会有效果：12PropertyValuesHolder pvhTranslationY = PropertyValuesHolder .ofFloat(&quot;translationX&quot;, 0, 150, 0); 4.使用的ofInt，ofFloat中，如果所有参数值都相同，也将不会有动画效果。1PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;, 0, 0); 动画的参数全部相同，left这个属性的动画不会有任何效果。 说明：关于PropertyValuesHolder几个注意点参考自文章animateLayoutChanges与LayoutTransition。 转场动画Android 5.0之前转场动画在Android 5.0以前实现转场动画是通过补间动画来实现，通常是在Activity中是overridePendingTransition(int enterAnim, int exitAnim)方法。enterAnim和exitAnim两个参数对应的是两个View动画：12345678910@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_anim); setStartActivityAnim();&#125;private void setStartActivityAnim() &#123; overridePendingTransition(R.anim.activity_right_in, R.anim.activity_left_out);&#125; 入场动画activity_right_in.xml：123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; android:fromXDelta=&quot;100%p&quot; android:toXDelta=&quot;0&quot;/&gt; 出场动画activity_left_out.xml：123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;-100%p&quot;/&gt; 在Activity的onCreate中调用overridePendingTransition方法只对主动启动Activity有效，如果我们返回上一个Activity也需要同样的转场动画，就需要在finish方法也添加上这个方法。123456789@Overridepublic void finish() &#123; super.finish(); setEndActivityAnim();&#125;private void setEndActivityAnim() &#123; overridePendingTransition(R.anim.activity_left_in, R.anim.activity_right_out);&#125; finish时入场动画activity_left_in.xml：123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; android:fromXDelta=&quot;-100%p&quot; android:toXDelta=&quot;0&quot;/&gt; finish时出场动画activity_right_out.xml：123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;100%p&quot;/&gt; Android 5.0之后转场动画 Activity TransitionAndroid 5.0之后，谷歌引入了 Activity Transition 来实现交互更加友好的转场动画效果。 Tansition的类型共有三种：进入 —— 决定Activity中的所有视图怎么进入屏幕退出 —— 决定Activity中的所有视图怎么退出屏幕共享元素 —— 决定两个Activity之间的过渡时怎么共享它们的视图 进入和退出包含如下动画效果：explode(分解) —— 从屏幕中间进或出slide(滑动) —— 从屏幕边缘进或出地fade(淡出) —— 改变屏幕上视图的不透明度实现添加或移除视图的效果 共享元素包含如下动画效果：changeBounds —— 改变目标视图的布局边界changeClipBounds —— 裁剪目标视图边界changeTransform —— 改变目标视图的缩放比例和旋转角度changeImageTransform —— 改变目标图片的大小和缩放比例 说明：Tansition分类及动画效果说明参考《Android群英传》 先来看下Explode（分解）、Slide（滑动）、Fade（淡出）三种转场动画的使用。 第一个Activity中：1234567891011121314151617181920public void explode(View view) &#123; Intent intent = new Intent(this, NextTransitionActivity.class); intent.putExtra(&quot;flag&quot;, &quot;explode&quot;); startActivity(intent, ActivityOptionsCompat.makeSceneTransitionAnimation(this).toBundle());&#125;public void slide(View view) &#123; Intent intent = new Intent(this, NextTransitionActivity.class); intent.putExtra(&quot;flag&quot;, &quot;slide&quot;); startActivity(intent, ActivityOptionsCompat.makeSceneTransitionAnimation(this).toBundle());&#125;public void fade(View view) &#123; Intent intent = new Intent(this, NextTransitionActivity.class); intent.putExtra(&quot;flag&quot;, &quot;fade&quot;); startActivity(intent, ActivityOptionsCompat.makeSceneTransitionAnimation(this).toBundle());&#125; 启动的第二个Activity中：1234567891011121314151617181920@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); switch (getIntent().getStringExtra(&quot;flag&quot;)) &#123; case &quot;explode&quot;: getWindow().setEnterTransition(new Explode()); getWindow().setExitTransition(new Explode()); break; case &quot;slide&quot;: getWindow().setEnterTransition(new Slide()); getWindow().setExitTransition(new Slide()); break; case &quot;fade&quot;: getWindow().setEnterTransition(new Fade()); getWindow().setExitTransition(new Fade()); break; &#125; setContentView(R.layout.activity_next_transition);&#125; 在第二个Activity中可以通过在style中配置&lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt;就不需要调用getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)。共享元素转场动画，使用也比较简单：12345678910111213@Overridepublic void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; TransitionAdapter.TransitionViewHolder holder = (TransitionAdapter.TransitionViewHolder) view.getTag(); View shareViewImg = holder.civImg; View shareViewName = holder.tvName; Intent intent = new Intent(this, NextTransitionActivity.class); intent.putExtra(&quot;flag&quot;, &quot;share&quot;); startActivity(intent, ActivityOptionsCompat .makeSceneTransitionAnimation(this, Pair.create(shareViewImg, &quot;shareView_img&quot;), Pair.create(shareViewName, &quot;shareView_name&quot;)) .toBundle());&#125; 这里使用ListView实现一个列表，列表中的头像和名字作为共享元素。在ListView的item的布局以及第二个启动的Activity的布局中，被共享的View都需要在布局文件中添加上相同android:transitionName属性，当然也可以在Java代码中通过ViewCompat.setTransitionName(View view, String transitionName)方法来设置共享View的transitionName。我们给头像和名称分别指定android:transitionName=&quot;shareView_img&quot;和android:transitionName=&quot;shareView_name&quot;。点击item后启动目标Activity时，指定的options参数为：1234ActivityOptionsCompat.makeSceneTransitionAnimation(this, Pair.create(shareViewImg,&quot;shareView_img&quot;), Pair.create(shareViewName, &quot;shareView_name&quot;)).toBundle()); 通过options参数，可以利用Pair构造多个共享元素，但是共享元素View的共享名称transitionName必须一一对应。 源码：https://github.com/xiaoyanger0825/AnimationSummary]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android实现底部对话框BottomDialog]]></title>
    <url>%2F2017%2F03%2F17%2FAndroid%E5%AE%9E%E7%8E%B0%E5%BA%95%E9%83%A8%E5%AF%B9%E8%AF%9D%E6%A1%86BottomDialog%2F</url>
    <content type="text"><![CDATA[最近项目上需要实现一个底部对话框，要实现这样的功能其实很简单，先看代码：1234567891011private void show1() &#123; Dialog bottomDialog = new Dialog(this, R.style.BottomDialog); View contentView = LayoutInflater.from(this).inflate(R.layout.dialog_content_normal, null); bottomDialog.setContentView(contentView); ViewGroup.LayoutParams layoutParams = contentView.getLayoutParams(); layoutParams.width = getResources().getDisplayMetrics().widthPixels; contentView.setLayoutParams(layoutParams); bottomDialog.getWindow().setGravity(Gravity.BOTTOM); bottomDialog.getWindow().setWindowAnimations(R.style.BottomDialog_Animation); bottomDialog.show();&#125; 对话框的样式style：1234&lt;style name=&quot;BottomDialog&quot; parent=&quot;@style/Base.V7.Theme.AppCompat.Light.Dialog&quot;&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 在对话框中的按钮需要MD风格的波纹效果的话，对话框的style的parent需要设定parent=&quot;@style/Base.V7.Theme.AppCompat.Light.Dialog&quot;，否则没有效果。同时将对话框所在window的标题去掉。android:windowBackground属性一定要设置成透明，否则自定义形状的对话框背景就是默认的白色了。如果不设置为透明，比如我们通常要设置的圆角对话框就没有效果。 对话框显示时从底部进入，关闭时从底部滑出。动画样式：1234&lt;style name=&quot;BottomDialog.Animation&quot; parent=&quot;Animation.AppCompat.Dialog&quot;&gt; &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/translate_dialog_in&lt;/item&gt; &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/translate_dialog_out&lt;/item&gt;&lt;/style&gt; tranlate_dialog_in.xml:12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;100%&quot; android:toXDelta=&quot;0&quot; android:toYDelta=&quot;0&quot;&gt;&lt;/translate&gt; tranlate_dialog_out.xml:12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;0&quot; android:toYDelta=&quot;100%&quot;&gt;&lt;/translate&gt; 实现底部对话框的原理就是修改对话框的内容布局contentView的参数，使它的宽度刚好等于屏幕的宽度，并且设置对话框所在Window的gravity属性为bottom。 需要注意的是，上面代码中需要在调用contentView.getLayoutParams()需要在setContentView方法后，否则获取到的LayoutParams为null，当然也可以自己new一个LayoutParams设置给contentView。 如果是要实现底部圆角对话框，原理也相似，只需要给contentView添加一个圆角的背景shape，并减小contentView的宽度给左右两边留一定的距离，同时给底部设置边距。123456789101112private void show2() &#123; Dialog bottomDialog = new Dialog(this, R.style.BottomDialog); View contentView = LayoutInflater.from(this).inflate(R.layout.dialog_content_circle, null); bottomDialog.setContentView(contentView); ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) contentView.getLayoutParams(); params.width = getResources().getDisplayMetrics().widthPixels - DensityUtil.dp2px(this, 16f); params.bottomMargin = DensityUtil.dp2px(this, 8f); contentView.setLayoutParams(params); bottomDialog.getWindow().setGravity(Gravity.BOTTOM); bottomDialog.getWindow().setWindowAnimations(R.style.BottomDialog_Animation); bottomDialog.show();&#125; 源码：https://github.com/xiaoyanger0825/BottomDialog]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>对话框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android沉浸式(透明)状态栏适配]]></title>
    <url>%2F2017%2F03%2F07%2FAndroid%E6%B2%89%E6%B5%B8%E5%BC%8F-%E9%80%8F%E6%98%8E-%E7%8A%B6%E6%80%81%E6%A0%8F%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[在Android系统4.4以前，状态栏的背景色和字体颜色都是不能改变的。但是4.4以后Google增加了改变状态栏背景透明的方法，可以通过两种方式来设置。直接在Activity中设置Window属性：1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; super.onCreate(savedInstanceState);&#125; 在xml的style文件中设置：123&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 使用android:windowTranslucentStatus属性需要在res目录下新建values-v19文件夹，style文件要放在里面。尽量使用第一种方式类实现，据说是第二种方式在某些国产手机上没有效果。 两种方式都是让状态背景栏透明。但是在实际测试后发现，在android4.4系统上状态栏的背景是渐变半透明。而在android5.0+的系统上又有所不同又有差异： 在Genymotion模拟器、vivo、nexus6p的android5.0+系统上是半透明。在xiaomi、oppo、huawei、leshi等5.0+系统是全透明的。从效果图也可以看出，上面两种方式使得内容区域延伸到状态栏下面去了。我们可以添加android:fitsSystemWindows来避免这样的情况。在Activity的根布局文件中添加1android:fitsSystemWindows=&quot;true&quot; 或者在主题style文件中添加1&lt;item name=&quot;android:fitsSystemWindows&quot;&gt;true&lt;/item&gt; 上图为了方便观察状态栏的背景颜色，就将Activity的布局文件的背景色设置成了红色。可以看出Toolbar所在的内容区域没有沉浸到状态栏下面了，并且状态栏的背景颜色还是之前一样，只是将内容区域向下偏移了状态栏高度的距离。这是因为fitsSystemWindows属性使得布局的paddingTop被重新改写了（paddingTop增加了状态栏的高度）。要实现沉浸式的状态栏，其实就是状态栏的背景颜色和Toolbar的颜色一样。那么我们将Activity的背景色改为Toolbar紫色（内容区域的背景颜色设置为白色）看下效果：除了通过fitsSystemWindows这个属性，我们可以自己给在Toolbar的上方添加一个和状态栏高度一样的Veiw，并将这个View的背景色设置成和Toolbar的背景色一样。也可以直接给Toobar设置paddingTop等于状态栏高度值。为了方便，我一般是采用重写Toolbar，改写它的paddingTop值来实现。12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Created by xiaoyanger on 2017/3/1. * 沉浸式、版本兼容的Toolbar，状态栏透明. */public class CompatToolbar extends Toolbar &#123; public CompatToolbar(Context context) &#123; this(context, null); &#125; public CompatToolbar(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CompatToolbar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); setup(); &#125; public void setup() &#123; int compatPadingTop = 0; // android 4.4以上将Toolbar添加状态栏高度的上边距，沉浸到状态栏下方 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; compatPadingTop = getStatusBarHeight(); &#125; this.setPadding(getPaddingLeft(), getPaddingTop() + compatPadingTop, getPaddingRight(), getPaddingBottom()); &#125; public int getStatusBarHeight() &#123; int statusBarHeight = 0; int resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; statusBarHeight = getResources().getDimensionPixelSize(resourceId); &#125; Log.d(&quot;CompatToolbar&quot;, &quot;状态栏高度：&quot; + px2dp(statusBarHeight) + &quot;dp&quot;); return statusBarHeight; &#125; public float px2dp(float pxVal) &#123; final float scale = getContext().getResources().getDisplayMetrics().density; return (pxVal / scale); &#125;&#125; 需要注意的是，网上有很多文章说状态栏的高度是25dp，但实际测试后发现并不是所有的机型都是25dp。使用getStatusBarHeight()可以准确的获取状态栏的高度值，看下获取到高度的日志：各个机型获取到的状态栏高度很多都不一样，所以最好还是重写Toolbar，动态获取到系统状态栏的高度来改写它的上边距。 国产的大部分手机在android5.0+的系统都将原生的半透明状态栏改成了全透明，因此通过上面的方式基本达到了沉浸式体验。其实在原生android5.0+系统上可以通过这个方法使状态栏背景色完全透明：1234567891011121314@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; // 5.0以上系统状态栏透明 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; Window window = getWindow(); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.setStatusBarColor(Color.TRANSPARENT); &#125; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);&#125; 可以将上面两个方法封装到BaseActivity中，以便在各个界面直接调用：12345678910111213protected void setTranslucentStatus() &#123; // 5.0以上系统状态栏透明 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; Window window = getWindow(); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.setStatusBarColor(Color.TRANSPARENT); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125;&#125; 通过setTranslucentStatus()方法，4.4的系统状态栏背景色渐变半透明，绝大多数5.0+的系统状态栏背景色全透明(测试时发现有部分华为手机状态栏背景是浅紫色，估计是定制系统给修改了)。需要注意的是，不管是&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;还是setTranslucentStatus()方法，这两种方式都会使这个设置&lt;itemname=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;不会有任何效果。 状态栏的背景色按照上面的方式适配基本上满足沉浸式体验，但是有时候会遇到这样的需求，状态栏和Toolbar背景色都是白底黑字，比如简书消息界面：状态栏的白色背景可以通过上面的方式来实现，但是修改状态栏的文字和图标颜色就比较麻烦了，原生的android系统只有在6.0+才有官方的api，但是在MIUI和FlymeUI提供了相应的方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 设置Android状态栏的字体颜色，状态栏为亮色的时候字体和图标是黑色，状态栏为暗色的时候字体和图标为白色 * * @param dark 状态栏字体和图标是否为深色 */protected void setStatusBarFontDark(boolean dark) &#123; // 小米MIUI try &#123; Window window = getWindow(); Class clazz = getWindow().getClass(); Class layoutParams = Class.forName(&quot;android.view.MiuiWindowManager$LayoutParams&quot;); Field field = layoutParams.getField(&quot;EXTRA_FLAG_STATUS_BAR_DARK_MODE&quot;); int darkModeFlag = field.getInt(layoutParams); Method extraFlagField = clazz.getMethod(&quot;setExtraFlags&quot;, int.class, int.class); if (dark) &#123; //状态栏亮色且黑色字体 extraFlagField.invoke(window, darkModeFlag, darkModeFlag); &#125; else &#123; //清除黑色字体 extraFlagField.invoke(window, 0, darkModeFlag); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 魅族FlymeUI try &#123; Window window = getWindow(); WindowManager.LayoutParams lp = window.getAttributes(); Field darkFlag = WindowManager.LayoutParams.class.getDeclaredField(&quot;MEIZU_FLAG_DARK_STATUS_BAR_ICON&quot;); Field meizuFlags = WindowManager.LayoutParams.class.getDeclaredField(&quot;meizuFlags&quot;); darkFlag.setAccessible(true); meizuFlags.setAccessible(true); int bit = darkFlag.getInt(null); int value = meizuFlags.getInt(lp); if (dark) &#123; value |= bit; &#125; else &#123; value &amp;= ~bit; &#125; meizuFlags.setInt(lp, value); window.setAttributes(lp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // android6.0+系统 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (dark) &#123; getWindow().getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125; &#125;&#125; 状态栏和Toobar白底黑字只能适配到android6.0+以及小米和魅族手机，其他手机的只能调整UI设计了。可以看一下简书和掘金，在小米、魅族和android6.0+的系统上都是白底黑字，但是在其他的系统上一般是将状态栏的背景色设置为浅灰色。其实状态栏显示的颜色是灰色，但是有多种方式来实现，参考下简书、掘金、今日头条，他们都使用了右滑返回上一界面，在滑动过程中就能看出状态背景色的实现。简书的效果可以不用上面的方式使内容区域沉浸到状态栏下面，直接使用的&lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;直接修改的状态栏的颜色。 掘金的状态栏是半透明的，内容区域已经沉浸到状态栏下方，可以使用上面的方法，对于不是android6.0+、MIUI、FlymeUI的系统通过window.setStatusbarColor方法将状态栏颜色改为半透明的灰色。 今日头条的效果可以采用上面的方法实现沉浸式，状态栏全透明，Toolbar没有增加paddingTop，而是在第二个界面中状态栏的下方(Toolbar上方)加了一块同状态栏高度一样的View，颜色为灰色。 其实，从上面三个app的状态栏适配效果来看，要达到真正的沉浸式，今日头条的效果要好一些。但是今日头条并没有在各个机型上适配状态栏的字体和图标颜色。下面自己来实现不同机型的状态栏背景色和字体图标颜色的适配。首先，新建一个CompatStartusbarActivity，继承自BaseActivity：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class CompatStatusBarActivity extends BaseActivity &#123; private FrameLayout mFrameLayoutContent; private View mViewStatusBarPlace; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); super.setContentView(R.layout.activity_compat_status_bar); mViewStatusBarPlace = findViewById(R.id.view_status_bar_place); mFrameLayoutContent = (FrameLayout) findViewById(R.id.frame_layout_content_place); ViewGroup.LayoutParams params = mViewStatusBarPlace.getLayoutParams(); params.height = getStatusBarHeight(); mViewStatusBarPlace.setLayoutParams(params); &#125; @Override public void setContentView(@LayoutRes int layoutResID) &#123; View contentView = LayoutInflater.from(this).inflate(layoutResID, null); mFrameLayoutContent.addView(contentView); &#125; /** * 设置沉浸式状态栏 * * @param fontIconDark 状态栏字体和图标颜色是否为深色 */ protected void setImmersiveStatusBar(boolean fontIconDark, int statusBarColor) &#123; setTranslucentStatus(); if (fontIconDark) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M || OsUtil.isMIUI() || OsUtil.isFlyme()) &#123; setStatusBarFontIconDark(true); &#125; else &#123; if (statusBarColor == Color.WHITE) &#123; statusBarColor = 0xffcccccc; &#125; &#125; &#125; setStatusBarPlaceColor(statusBarColor); &#125; private void setStatusBarPlaceColor(int statusColor) &#123; if (mViewStatusBarPlace != null) &#123; mViewStatusBarPlace.setBackgroundColor(statusColor); &#125; &#125; public int getStatusBarHeight() &#123; int statusBarHeight = 0; int resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; statusBarHeight = getResources().getDimensionPixelSize(resourceId); &#125; return statusBarHeight; &#125; /** * 设置状态栏透明 */ private void setTranslucentStatus() &#123; // 5.0以上系统状态栏透明 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; Window window = getWindow(); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.setStatusBarColor(Color.TRANSPARENT); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; &#125; /** * 设置Android状态栏的字体颜色，状态栏为亮色的时候字体和图标是黑色，状态栏为暗色的时候字体和图标为白色 * * @param dark 状态栏字体是否为深色 */ private void setStatusBarFontIconDark(boolean dark) &#123; // 小米MIUI try &#123; Window window = getWindow(); Class clazz = getWindow().getClass(); Class layoutParams = Class.forName(&quot;android.view.MiuiWindowManager$LayoutParams&quot;); Field field = layoutParams.getField(&quot;EXTRA_FLAG_STATUS_BAR_DARK_MODE&quot;); int darkModeFlag = field.getInt(layoutParams); Method extraFlagField = clazz.getMethod(&quot;setExtraFlags&quot;, int.class, int.class); if (dark) &#123; //状态栏亮色且黑色字体 extraFlagField.invoke(window, darkModeFlag, darkModeFlag); &#125; else &#123; //清除黑色字体 extraFlagField.invoke(window, 0, darkModeFlag); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 魅族FlymeUI try &#123; Window window = getWindow(); WindowManager.LayoutParams lp = window.getAttributes(); Field darkFlag = WindowManager.LayoutParams.class.getDeclaredField(&quot;MEIZU_FLAG_DARK_STATUS_BAR_ICON&quot;); Field meizuFlags = WindowManager.LayoutParams.class.getDeclaredField(&quot;meizuFlags&quot;); darkFlag.setAccessible(true); meizuFlags.setAccessible(true); int bit = darkFlag.getInt(null); int value = meizuFlags.getInt(lp); if (dark) &#123; value |= bit; &#125; else &#123; value &amp;= ~bit; &#125; meizuFlags.setInt(lp, value); window.setAttributes(lp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // android6.0+系统 // 这个设置和在xml的style文件中用这个&lt;item name=&quot;android:windowLightStatusBar&quot;&gt;true&lt;/item&gt;属性是一样的 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; if (dark) &#123; getWindow().getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125; &#125; &#125;&#125; 布局文件activity_compat_status_bar.xml：12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.xiao.compatstatusbar.MainActivity&quot;&gt; &lt;View android:id=&quot;@+id/view_status_bar_place&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;25dp&quot;/&gt; &lt;FrameLayout android:id=&quot;@+id/frame_layout_content_place&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt; setImmersiveStatusBar方法中中判断了不能修改状态栏字体和图标颜色则将白色的状态栏底色改成灰色，能修改状态栏字体和图标的颜色则改为给定的颜色statusBarColor。使用的时候直接调用这个方法即可。 下面是使用示例：MainActivity继承自CompatStatusBarActivity：1234567891011121314151617public class MainActivity extends CompatStatusBarActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar_main); int color = 0xffaa66cc; toolbar.setBackgroundColor(color); setImmersiveStatusBar(false, color); &#125; public void go(View view) &#123; startActivity(new Intent(this, NextActivity.class)); &#125;&#125; 布局文件activity_main.xml：12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.xiao.compatstatusbar.MainActivity&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;@color/colorPrimary&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;标题&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#99FF4081&quot; android:onClick=&quot;go&quot; android:text=&quot;页面1&quot; android:textSize=&quot;44sp&quot;/&gt;&lt;/LinearLayout&gt; NextActivity同样继承自CompatStatusBarActivity:12345678910111213public class NextActivity extends CompatStatusBarActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_next); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar_next); int color = 0xffffffff; toolbar.setBackgroundColor(color); setImmersiveStatusBar(true, color); &#125;&#125; 布局文件activity_next.xml：123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.xiao.compatstatusbar.MainActivity&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar_next&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;@color/colorPrimary&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;标题&quot; android:textColor=&quot;#353535&quot; android:textSize=&quot;18sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#99FF4081&quot; android:text=&quot;页面2&quot; android:textSize=&quot;44sp&quot;/&gt;&lt;/LinearLayout&gt; 最终适配效果：源码：https://github.com/xiaoyanger0825/CompatStatusBar]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>沉浸式状态栏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画总结——View动画、属性动画、帧动画]]></title>
    <url>%2F2017%2F02%2F27%2FAndroid%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94View%E5%8A%A8%E7%94%BB%E3%80%81%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E3%80%81%E5%B8%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[在App中合理地使用动画能够获得友好愉悦的用户体验，Android中的动画有View动画、属性动画、帧动画、布局动画、转场动画等，在5.x以后有又新增了矢量动画，这些动画在平常开发中使用较为普遍，所以有必要做一次完整的总结。 View动画View动画定义了渐变Alpha、旋转Rotate、缩放Scale、平移Translate四种基本动画，并且通过这四种基本动画的组合使用，可以实现多种交互效果。View动画使用非常简单，不仅可以通过XML文件来定义动画，同样可以通过Java代码来实现动画过程。 Xml文件定义View动画通过xml来定义View动画涉及到一些公有的属性（在AndroidStudio上不能提示）：123456android:duration 动画持续时间android:fillAfter 为true动画结束时，View将保持动画结束时的状态android:fillBefore 为true动画结束时，View将还原到开始开始时的状态android:repeatCount 动画重复执行的次数android:repeatMode 动画重复模式 ，重复播放时restart重头开始，reverse重复播放时倒叙回放，该属性需要和android:repeatCount一起使用android:interpolator 插值器，相当于变速器，改变动画的不同阶段的执行速度 这些属性是从Animation中继承下来的，在alpha、rotate、scale、translate标签中都可以直接使用。利用xml文件定义View动画需要在工程的res目录下创建anim文件夹，所有的xml定义的View动画都要放在anim目录下。渐变view_anim_alpha.xml：123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0&quot;&gt;&lt;/alpha&gt; 旋转view_anim_rotate.xml：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fillAfter=&quot;true&quot; android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;360&quot;&gt;&lt;/rotate&gt; 缩放view_anim_scale.xml：12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;0.5&quot; android:toYScale=&quot;0.5&quot;&gt;&lt;/scale&gt; 平移view_anim_translate.xml：12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:fromXDelta=&quot;0&quot; android:fromYDelta=&quot;0&quot; android:toXDelta=&quot;100%&quot; android:toYDelta=&quot;100%&quot;&gt;&lt;/translate&gt; rotate、scale动画的android:pivotX和android:pivotY属性、translate动画的android:toXDelta和android:toYDelta属性的取值都可以是都可以数值、百分数、百分数p，比如：50、50%、50%p，他们取值的代表的意义各不相同：50表示以View左上角为原点沿坐标轴正方向(x轴向右，y轴向下)偏移50px的位置；50%表示以View左上角为原点沿坐标轴正方向(x轴向右，y轴向下)偏移View宽度或高度的50%处的位置；50%p表示以View左上角为原点沿坐标轴正方向(x轴向右，y轴向下)偏移父控件宽度或高度的50%处的位置（p表示相对于ParentView的位置）。通过定义xml动画资源文件，在Activity中调用：123456789101112131415161718192021222324public void clickToAlpha(View view) &#123; Animation alphaAnim = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.view_anim_alpha); mTargetView.startAnimation(alphaAnim);&#125;public void clickToRotate(View view) &#123; Animation rotateAnim = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.view_anim_rotate); mTargetView.startAnimation(rotateAnim);&#125;public void clickToScale(View view) &#123; Animation scaleAnim = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.view_anim_scale); mTargetView.startAnimation(scaleAnim);&#125;public void clickToTranslate(View view) &#123; Animation translateAnim = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.view_anim_translate); mTargetView.startAnimation(translateAnim);&#125;public void clickToSet(View view) &#123; Animation setAnim = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.view_anim_set); mTargetView.startAnimation(setAnim);&#125; Java代码实现View动画在平常的业务逻辑中也可以直接用Java代码来实现Veiw动画，Android系统给我们提供了AlphaAnimation、RotateAnimation、ScaleAnimation、TranslateAnimation四个动画类分别来实现View的渐变、旋转、缩放、平移动画。渐变：12345public void clickToAlpha(View view) &#123; AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0); alphaAnimation.setDuration(2000); mTargetView.startAnimation(alphaAnimation);&#125; 旋转：12345678public void clickToRotate(View view) &#123; RotateAnimation rotateAnimation = new RotateAnimation( 0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); rotateAnimation.setDuration(2000); mTargetView.startAnimation(rotateAnimation);&#125; 缩放：123456789public void clickToScale(View view) &#123; ScaleAnimation scaleAnimation = new ScaleAnimation( 1, 0.5f, 1, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); scaleAnimation.setDuration(2000); mTargetView.startAnimation(scaleAnimation);&#125; 平移：123456789public void clickToTranslate(View view) &#123; TranslateAnimation translateAnimation = new TranslateAnimation( Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 1, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 1); translateAnimation.setDuration(2000); mTargetView.startAnimation(translateAnimation);&#125; 组合：1234567891011121314151617181920212223242526272829303132public void clickToSet(View view) &#123; AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0); alphaAnimation.setDuration(2000); RotateAnimation rotateAnimation = new RotateAnimation( 0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); rotateAnimation.setDuration(2000); ScaleAnimation scaleAnimation = new ScaleAnimation( 1, 0.5f, 1, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); scaleAnimation.setDuration(2000); TranslateAnimation translateAnimation = new TranslateAnimation( Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 1, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 1); translateAnimation.setDuration(2000); AnimationSet animationSet = new AnimationSet(true); animationSet.addAnimation(alphaAnimation); animationSet.addAnimation(rotateAnimation); animationSet.addAnimation(scaleAnimation); animationSet.addAnimation(translateAnimation); mTargetView.startAnimation(animationSet);&#125; View动画可以设置一个动画执行的监听器：12345678910111213141516animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; // 动画开始 &#125; @Override public void onAnimationEnd(Animation animation) &#123; // 动画结束 &#125; @Override public void onAnimationRepeat(Animation animation) &#123; //动画重复 &#125;&#125;); 通过设置监听器可以在动画执行的开始、结束、重复时做一些其他的业务逻辑。 属性动画所谓属性动画，就是改变对象Object的属性来实现动画过程。属性动画是对View的动画的扩展，通过它可以实现更多漂亮的动画效果。同时属性动画的作用对象不仅仅是View，任何对象都可以。属性动画的作用效果就是：在一个指定的时间段内将对象的一个属性的属性值动态地变化到另一个属性值。 ObjectAnimatorObjectAnimator是最常用的属性动画执行类。123456private void startJavaPropertyAnimator() &#123; ObjectAnimator .ofFloat(mImageView, &quot;rotationY&quot;, 0f, 360f) .setDuration(2000) .start();&#125; 上面的代码就是通过ObjectAnimator在2000ms内将mImageView的rotationY属性的属性值从0f变化的360f。ObjectAnimtor可以用ofInt、ofFloat、ofObject等静态方法，传入动画作用的目标Object、属性字段、属性开始值、属性中间值、属性结束值等参数来构造动画对象。在动画更新的过程中，通过不断去调用对象属性的setter方法改变属性值，不断重绘实现动画过程。如果没有给定动画开始属性值，那么系统会通过反射去获取Object对象的初始值作为动画的开始值。属性动画也同样可以通过xml文件来定义，同样在工程的res目录下创建animator文件夹，xml文件定义的objectAnimator动画要放在该文件夹下。 property_animator.xml：12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;2000&quot; android:propertyName=&quot;rotationY&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;360&quot; android:valueType=&quot;floatType&quot;&gt;&lt;/objectAnimator&gt; Java代码调用：123456private void startXmlPropertyAnimator() &#123; Animator animator = AnimatorInflater.loadAnimator(getApplicationContext(), R.animator.property_animator); animator.setTarget(mImageView); animator.start();&#125; 最终效果如上图。属性动画也同样可以组合使用，通过AnimatorSet类和xml文件的set标签都可以同时改变对象的多个属性，实现更加丰富的动画效果。通过AnimatorSet创建动画集：12345678910111213141516private void startJavaPropertyAnimatorSet() &#123; Animator scaleXAnimator = ObjectAnimator.ofFloat(mImageView, &quot;scaleX&quot;, 1, 0.5f); scaleXAnimator.setDuration(2000); Animator scaleYAnimator = ObjectAnimator.ofFloat(mImageView, &quot;scaleY&quot;, 1, 0.5f); scaleYAnimator.setDuration(2000); Animator rotationXAnimator = ObjectAnimator.ofFloat(mImageView, &quot;rotationX&quot;, 0, 360); rotationXAnimator.setDuration(2000); Animator rotationYAnimator = ObjectAnimator.ofFloat(mImageView, &quot;rotationY&quot;, 0, 360); rotationYAnimator.setDuration(2000); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.play(scaleXAnimator) .with(scaleYAnimator) .before(rotationXAnimator) .after(rotationYAnimator); animatorSet.start();&#125; AnimatorSet通过before、with、after三个方法可以组合多个属性动画，with表示与给定动画同时执行，before在给定动画执行之前执行，after表示在给定动画执行之后执行。通过xml文件定义属性动画集：property_animator_set.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;objectAnimator android:duration=&quot;2000&quot; android:propertyName=&quot;scaleX&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;0.5&quot; android:valueType=&quot;floatType&quot;/&gt; &lt;objectAnimator android:duration=&quot;2000&quot; android:propertyName=&quot;scaleY&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;0.5&quot; android:valueType=&quot;floatType&quot;/&gt; &lt;objectAnimator android:duration=&quot;2000&quot; android:propertyName=&quot;alpha&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;0.5&quot; android:valueType=&quot;floatType&quot;/&gt;&lt;/set&gt; 在Java代码中调用属性动画集：123456private void startxmlPropertyAnimatorSet() &#123; Animator animator = AnimatorInflater.loadAnimator(getApplicationContext(), R.animator.property_animator_set); animator.setTarget(mImageView); animator.start();&#125; 同样，属性动画也可以添加动画执行监听器：123456789101112131415161718192021animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; // 动画开始 &#125; @Override public void onAnimationEnd(Animator animation) &#123; // 动画结束 &#125; @Override public void onAnimationCancel(Animator animation) &#123; // 动画取消 &#125; @Override public void onAnimationRepeat(Animator animation) &#123; // 动画重复 &#125;&#125;); 在监听到属性动画开始、结束、取消、重复时可以去做一些其他的逻辑业务。 ValueAnimatorValueAnimator是ObjectAnimator的父类，它继承自Animator。ValueAnimaotor同样提供了ofInt、ofFloat、ofObject等静态方法，传入的参数是动画过程的开始值、中间值、结束值来构造动画对象。可以将ValueAnimator看着一个值变化器，即在给定的时间内将一个目标值从给定的开始值变化到给定的结束值。在使用ValueAnimator时通常需要添加一个动画更新的监听器，在监听器中能够获取到执行过程中的每一个动画值。12345678910111213private void startValueAnimator() &#123; ValueAnimator valueAnimator = ValueAnimator.ofFloat(0, 1); valueAnimator.setDuration(300); valueAnimator.start(); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; // 动画更新过程中的动画值，可以根据动画值的变化来关联对象的属性，实现属性动画 float value = (float) animation.getAnimatedValue(); Log.d(&quot;ValueAnimator&quot;, &quot;动画值：&quot; + value); &#125; &#125;);&#125; 在300ms内将数值0变化到1的动画值的变化log：1234567891011121314151617181902-25 23:16:57.586 D/ValueAnimator: 动画值：0.002-25 23:16:57.596 D/ValueAnimator: 动画值：0.00790217502-25 23:16:57.616 D/ValueAnimator: 动画值：0.02955961202-25 23:16:57.636 D/ValueAnimator: 动画值：0.06698727602-25 23:16:57.646 D/ValueAnimator: 动画值：0.11810201402-25 23:16:57.666 D/ValueAnimator: 动画值：0.1812879702-25 23:16:57.686 D/ValueAnimator: 动画值：0.254548202-25 23:16:57.706 D/ValueAnimator: 动画值：0.3306310202-25 23:16:57.716 D/ValueAnimator: 动画值：0.416615702-25 23:16:57.736 D/ValueAnimator: 动画值：0.505235902-25 23:16:57.746 D/ValueAnimator: 动画值：0.593690602-25 23:16:57.766 D/ValueAnimator: 动画值：0.6791839602-25 23:16:57.786 D/ValueAnimator: 动画值：0.754520802-25 23:16:57.796 D/ValueAnimator: 动画值：0.8267103402-25 23:16:57.826 D/ValueAnimator: 动画值：0.8885729302-25 23:16:57.836 D/ValueAnimator: 动画值：0.9381532702-25 23:16:57.856 D/ValueAnimator: 动画值：0.972188202-25 23:16:57.876 D/ValueAnimator: 动画值：0.9938441502-25 23:16:57.886 D/ValueAnimator: 动画值：1.0 ValueAnimator的使用一般会结合更新监听器AnimatorUpdateListener，大多数时候是在自定义控件时使用。下面是用ValueAnimator自定义控件实现动画打开关闭效果。expanded_veiw.xml：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; android:divider=&quot;@drawable/divider&quot; android:orientation=&quot;vertical&quot; android:showDividers=&quot;middle&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/ll_expanded_question&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:gravity=&quot;center_vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_expanded_question&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;48dp&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center_vertical&quot; android:padding=&quot;8dp&quot; android:text=&quot;如何把一本很难的书看懂？&quot; android:textColor=&quot;#999999&quot; android:textSize=&quot;16sp&quot;/&gt; &lt;ImageView android:id=&quot;@+id/iv_expanded_indicator&quot; android:layout_width=&quot;16dp&quot; android:layout_height=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:src=&quot;@drawable/img_up&quot;/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=&quot;@+id/tv_expanded_answer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;8dp&quot; android:text=&quot;多读几遍。真的特别有用。至少看三遍。从开头看，看到中间，重头再来，再看得多一点，在从新开始，建议看到快结束时再从新开始。&quot; android:textColor=&quot;#999999&quot; android:textSize=&quot;16sp&quot;/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class ExpandedView extends FrameLayout &#123; private TextView mTvAnswer; private boolean isClosed; private ImageView mIvIndicator; public ExpandedView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; private void init(Context context) &#123; View view = LayoutInflater.from(context).inflate(R.layout.expanded_view, this, true); LinearLayout llQuestion = (LinearLayout) view.findViewById(R.id.ll_expanded_question); llQuestion.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; anim(); &#125; &#125;); mTvAnswer = (TextView) view.findViewById(R.id.tv_expanded_answer); mIvIndicator = (ImageView) view.findViewById(R.id.iv_expanded_indicator); &#125; private void anim() &#123; // 指示器旋转 ValueAnimator valueAnimator1 = isClosed ? ValueAnimator.ofFloat(180, 0) : ValueAnimator.ofFloat(0, 180); valueAnimator1.setDuration(500); valueAnimator1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float value = (float) animation.getAnimatedValue(); mIvIndicator.setRotation(value); &#125; &#125;); valueAnimator1.start(); // 打开开关闭操作 final int answerHeight = mTvAnswer.getMeasuredHeight(); ValueAnimator valueAnimator2 = isClosed ? ValueAnimator.ofInt(-answerHeight, 0) : ValueAnimator.ofInt(0, -answerHeight); valueAnimator2.setDuration(500); final MarginLayoutParams params = (MarginLayoutParams) mTvAnswer.getLayoutParams(); valueAnimator2.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int value = (int) animation.getAnimatedValue(); params.bottomMargin = value; mTvAnswer.setLayoutParams(params); &#125; &#125;); valueAnimator2.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; isClosed = !isClosed; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); valueAnimator2.start(); &#125;&#125; TypeEvaluatorObjectAnimator和ValueAnimator都有ofObject方法，传入的都有一个TypeEvaluator类型的参数。TypeEvaluator是一个接口，里面也只有一个抽象方法：1public T evaluate(float fraction, T startValue, T endValue); 再看ofInt方法中没有传入该参数，但实际上调用ofInt方法时，系统已经有实现了TypeEvaluator接口的IntEvaluator，它的源码也非常简单：1234public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt));&#125; fraction范围为0到1，表示动画执行过程中已完成程度。泛型T即为动画执行的属性类型。所以我们要用属性动画来执行复杂对象的动画过程，就需要自定义TypeEvaluator，实现动画逻辑。先来定义一个对象123456789101112131415161718192021222324252627282930313233343536public class Circle &#123; private int raduis; // 半径 private int color; // 颜色 private int elevation; // 高度 public Circle(int raduis, int color, int elevation) &#123; this.raduis = raduis; this.color = color; this.elevation = elevation; &#125; public int getRaduis() &#123; return raduis; &#125; public void setRaduis(int raduis) &#123; this.raduis = raduis; &#125; public int getColor() &#123; return color; &#125; public void setColor(int color) &#123; this.color = color; &#125; public int getElevation() &#123; return elevation; &#125; public void setElevation(int elevation) &#123; this.elevation = elevation; &#125;&#125; CircleEvaluator，实现TypeEvaluator接口：12345678910111213141516171819202122232425262728public class CircleEvaluator implements TypeEvaluator&lt;Circle&gt; &#123; @Override public Circle evaluate(float fraction, Circle startValue, Circle endValue) &#123; int startRaduis = startValue.getRaduis(); int endRaduis = endValue.getRaduis(); int raduis = (int) (startRaduis + fraction * (endRaduis - startRaduis)); int startColor = startValue.getColor(); int endColor = endValue.getColor(); int startColorRed = Color.red(startColor); int startColorGreen = Color.green(startColor); int startColorBlue = Color.blue(startColor); int endColorRed = Color.red(endColor); int endColorGreen = Color.green(endColor); int endColorBlue = Color.blue(endColor); int colorRed = (int) (startColorRed + fraction * (endColorRed - startColorRed)); int colorGreen = (int) (startColorGreen + fraction * (endColorGreen - startColorGreen)); int colorBlue = (int) (startColorBlue + fraction * (endColorBlue - startColorBlue)); int color = Color.rgb(colorRed, colorGreen, colorBlue); int startElevation = startValue.getElevation(); int endElevation = endValue.getElevation(); int elevation = (int) (startElevation + fraction * (endElevation - startElevation)); return new Circle(raduis, color, elevation); &#125;&#125; 自定义控件CircleView，将Circle作为它的一个属性：1234567891011121314151617181920212223242526272829public class CircleView extends View &#123; private Circle circle; private Paint mPaint; public CircleView(Context context, AttributeSet attrs) &#123; super(context, attrs); circle = new Circle(168, Color.RED, 0); mPaint = new Paint(); mPaint.setAntiAlias(true); &#125; @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); setElevation(circle.getElevation()); mPaint.setColor(circle.getColor()); canvas.drawCircle(getMeasuredHeight() / 2, getMeasuredHeight() / 2, circle.getRaduis(), mPaint); &#125; public void setCircle(Circle circle) &#123; this.circle = circle; postInvalidate(); &#125; public Circle getCircle() &#123; return circle; &#125;&#125; ObjectAnimator使用：12345678private void start1() &#123; Circle startCircle = new Circle(168, Color.RED, 0); Circle middleCircle = new Circle(300, Color.GREEN, 15); Circle endCircle = new Circle(450, Color.BLUE, 30); ObjectAnimator.ofObject(mCircleView, &quot;circle&quot;, new CircleEvaluator(), startCircle, middleCircle, endCircle) .setDuration(5000) .start();&#125; ValueAnimator使用：123456789101112131415private void start2() &#123; Circle startCircle = new Circle(168, Color.RED, 0); Circle middleCircle = new Circle(300, Color.GREEN, 15); Circle endCircle = new Circle(450, Color.BLUE, 30); ValueAnimator valueAnimator = ValueAnimator.ofObject(new CircleEvaluator(), startCircle, middleCircle, endCircle); valueAnimator.setDuration(5000); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Circle circle = (Circle) animation.getAnimatedValue(); mCircleView.setCircle(circle); &#125; &#125;); valueAnimator.start();&#125; 需要注意的是，系统调用获取控件setter、getter方法是通过反射获取的，属性的名称必须和getter、setter方法名称后面的字符串一致，比如上面的getter、setter方法分别为getCircle、setCircle，那么属性名字就必须为circle。 帧动画帧动画需要开发者制定好动画每一帧，系统一帧一帧的播放图片。12345678910private void start1() &#123; AnimationDrawable ad = new AnimationDrawable(); for (int i = 0; i &lt; 7; i++) &#123; Drawable drawable = getResources().getDrawable(getResources().getIdentifier(&quot;ic_fingerprint_&quot; + i, &quot;drawable&quot;, getPackageName())); ad.addFrame(drawable, 100); &#125; ad.setOneShot(false); mImageView.setImageDrawable(ad); ad.start();&#125; 帧动画同样也可以在xml文件中配置，直接在工程drawable目录新建animation-list标签：1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt;&lt;item android:drawable=&quot;@drawable/ic_fingerprint_0&quot; android:duration=&quot;100&quot;/&gt;&lt;item android:drawable=&quot;@drawable/ic_fingerprint_1&quot; android:duration=&quot;100&quot;/&gt;&lt;item android:drawable=&quot;@drawable/ic_fingerprint_2&quot; android:duration=&quot;100&quot;/&gt;&lt;item android:drawable=&quot;@drawable/ic_fingerprint_3&quot; android:duration=&quot;100&quot;/&gt;&lt;item android:drawable=&quot;@drawable/ic_fingerprint_4&quot; android:duration=&quot;100&quot;/&gt;&lt;item android:drawable=&quot;@drawable/ic_fingerprint_5&quot; android:duration=&quot;100&quot;/&gt;&lt;item android:drawable=&quot;@drawable/ic_fingerprint_6&quot; android:duration=&quot;100&quot;/&gt;&lt;/animation-list&gt; 12345private void start2() &#123; mImageView.setImageResource(R.drawable.frame_anim); AnimationDrawable animationDrawable = (AnimationDrawable) mImageView.getDrawable(); animationDrawable.start();&#125; 其中android:onshot属性和setOneShot方法表示是否只执行一次。AnimationDrawable实际是上是一个Drawable动画，动画执行的过程总会给你不断重绘Drawable的每一帧图像，实现动态播放效果。 源码：https://github.com/xiaoyanger0825/AnimationSummary]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手绘制一个折线图控件ChartView]]></title>
    <url>%2F2017%2F02%2F14%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E6%8A%98%E7%BA%BF%E5%9B%BE%E6%8E%A7%E4%BB%B6ChartView%2F</url>
    <content type="text"><![CDATA[折线图在很多App中都有用到，GitHub上面有一些功能全面的折线图框架，比如hellecharts-android，achartengine。但是很多时候设计师给定的样式，通过这些框架不一定能完全达到效果。所以只有琢磨着通过自定义View来自己绘制一个折线图：根据展示效果，坐标轴、刻度、刻度值、数据点线、标题全部都通过自绘来实现。 初始化绘制相关参数在构造函数中初始化画笔及数据刻度值等参数：123456789101112131415161718192021222324252627282930private void init() &#123; this.setBackgroundColor(Color.WHITE); // x轴刻度值 if (xLabel == null) &#123; xLabel = new String[]&#123;&quot;12-11&quot;, &quot;12-12&quot;, &quot;12-13&quot;, &quot;12-14&quot;, &quot;12-15&quot;, &quot;12-16&quot;, &quot;12-17&quot;&#125;; &#125; // 数据点 if (data == null) &#123; data = new String[]&#123;&quot;2.98&quot;, &quot;2.99&quot;, &quot;2.99&quot;, &quot;2.98&quot;, &quot;2.92&quot;, &quot;2.94&quot;, &quot;2.95&quot;&#125;; &#125; // 标题 if (title == null) &#123; title = &quot;七日年化收益率(%)&quot;; &#125; // 根据设置的数据值生成Y坐标刻度值 yLabel = createYLabel(); // 数据点及其连线的颜色集合 mDataLineColors = new String[]&#123;&quot;#fbbc14&quot;, &quot;#fbaa0c&quot;, &quot;#fbaa0c&quot;, &quot;#fb8505&quot;, &quot;#ff6b02&quot;, &quot;#ff5400&quot;, &quot;#ff5400&quot;&#125;; // 新建画笔 mDataLinePaint = new Paint(); // 数据(点和连线)画笔 mScaleLinePaint = new Paint(); // 坐标(刻度线条)值画笔 mScaleValuePaint = new Paint(); // 图表(刻度值)画笔 mBackColorPaint = new Paint(); // 背景(色块)画笔 // 画笔抗锯齿 mDataLinePaint.setAntiAlias(true); mScaleLinePaint.setAntiAlias(true); mScaleValuePaint.setAntiAlias(true); mBackColorPaint.setAntiAlias(true);&#125; x轴的刻度值、数据点、y中刻度值设置初始值根据初始值先进行绘制。后续重新设置数据后再重绘。在根据给定数据点生成y的坐标刻度值时，需要考虑两点：1.数据点及其连线需要绘制在坐标区域的中间位置，并且数据点的临界值(最大或最小值)不能超过y坐标刻度的临界值；2.y刻度值必须均分，并且根据不同数据值展示合适的y刻度值。所以createYLabel()方法实现了根据给定的数据点的值来计算出对应y刻度值的算法。123456789101112131415161718192021222324252627/** * 根据数据值data生成合适的Y坐标刻度值 * * @return y轴坐标刻度值数组 */private String[] createYLabel() &#123; float[] dataFloats = new float[7]; for (int i = 0; i &lt; data.length; i++) &#123; dataFloats[i] = Float.parseFloat(data[i]); &#125; // 将数据值从小到大排序 Arrays.sort(dataFloats); // 中间值 float middle = format3Bit((dataFloats[0] + dataFloats[6]) / 2f); // y轴刻度，+0.01f为了避免所有数据点都相等时计算出的y刻度为0. float scale = format3Bit((dataFloats[6] - dataFloats[0]) / 4 + 0.01f); String[] yText = new String[5]; yText[0] = (middle - 2 * scale) + &quot;&quot;; yText[1] = (middle - scale) + &quot;&quot;; yText[2] = middle + &quot;&quot;; yText[3] = (middle + scale) + &quot;&quot;; yText[4] = (middle + 2 * scale) + &quot;&quot;; for (int i = 0; i &lt; yText.length; i++) &#123; yText[i] = format3Bit(yText[i]); &#125; return yText;&#125; 将数据值排序后计算出中间值middle、y轴刻度值scale。format3Bit(float number)将计算结果进行格式化，保证刻度值的小数位数一致。1234567891011121314151617181920212223242526272829303132/** * 格式化数字 ###.000 * * @return ###.000 */private float format3Bit(float number) &#123; DecimalFormat decimalFormat = new DecimalFormat(&quot;###.000&quot;); String target = decimalFormat.format(number); if (target.startsWith(&quot;.&quot;)) &#123; target = &quot;0&quot; + target; &#125; return Float.parseFloat(target);&#125;/** * 格式化数据 ###.000 * * @param numberStr 格式化后的字符串形式 * @return ###.000 */private String format3Bit(String numberStr) &#123; if (TextUtils.isEmpty(numberStr)) &#123; return &quot;0.000&quot;; &#125; float numberFloat = Float.parseFloat(numberStr); DecimalFormat decimalFormat = new DecimalFormat(&quot;###.000&quot;); String target = decimalFormat.format(numberFloat); if (target.startsWith(&quot;.&quot;)) &#123; target = &quot;0&quot; + target; &#125; return target;&#125; 在onMeasure中初始化绘制尺寸及画笔属性等参数：12345678910111213141516171819202122232425262728293031323334@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); initParams();&#125;private void initParams() &#123; int width = getMeasuredWidth() - getPaddingLeft() - getPaddingRight(); int height = getMeasuredHeight() - getPaddingTop() - getPaddingBottom(); yScale = height / 7.5f; // y轴刻度 xScale = width / 7.5f; // x轴刻度 startPointX = xScale / 2; // 开始绘图的x坐标 startPointY = yScale / 2; // 开始UI图的y坐标 xLength = 6.5f * xScale; // x轴长度 yLength = 5.5f * yScale; // y轴长度 xTextPlaceHeight = yScale / 2; // x轴刻度文字的占位高度 yTextPlaceWidth = xScale / 2; // y轴刻度文字的占位宽度 titleHeight = yScale; chartLineStrokeWidth = xScale / 50; // 图表线条的线宽 coordTextSize = xScale / 5; // 坐标刻度文字的大小 dataLineStrodeWidth = xScale / 15; // 数据线条的线宽 // 设置画笔相关属性 mBackColorPaint.setColor(0x11DEDE68); mScaleLinePaint.setStrokeWidth(chartLineStrokeWidth); mScaleLinePaint.setColor(0xFFDEDCD8); mScaleValuePaint.setColor(0xFF999999); mScaleValuePaint.setTextSize(coordTextSize); mDataLinePaint.setStrokeWidth(dataLineStrodeWidth); mDataLinePaint.setStrokeCap(Paint.Cap.ROUND); mDataLinePaint.setTextSize(1.5f * coordTextSize);&#125; 在onMeasure中就不去判断测量模式了，布局中直接使用match_parent或具体的dp值。 绘制在onDraw方法中进行绘制：12345678910@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); drawBackColor(canvas); // 绘制背景色块 drawYAxisAndXScaleValue(canvas); // 绘制y轴和x刻度值 drawXAxisAndYScaleValue(canvas); // 绘制x轴和y刻度值 drawDataLines(canvas); // 绘制数据连线 drawDataPoints(canvas); // 绘制数据点 drawTitle(canvas); // 绘制标题&#125; 绘制方法的具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * 绘制背景色块 * @param canvas */private void drawBackColor(Canvas canvas) &#123; for (int i = 0; i &lt; 7; i++) &#123; if (i == 2 || i == 4 || i == 6) &#123; canvas.drawRect(startPointX + (i - 1) * xScale, startPointY, startPointX + i * xScale, yLength + startPointY, mBackColorPaint); &#125; &#125;&#125;private void drawYAxisAndXScaleValue(Canvas canvas) &#123; for (int i = 0; i &lt; 7; i++) &#123; canvas.drawLine(startPointX + i * xScale, startPointY, startPointX + i * xScale, startPointY + yLength, mScaleLinePaint); mScaleValuePaint.getTextBounds(xLabel[i], 0, xLabel[i].length(), bounds); if (i == 0) &#123; canvas.drawText(xLabel[i], startPointX, startPointY + yLength + bounds.height() + yScale / 15, mScaleValuePaint); &#125; else &#123; canvas.drawText(xLabel[i], startPointX + i * xScale - bounds.width() / 2, startPointY + yLength + bounds.height() + yScale / 15, mScaleValuePaint); &#125; &#125;&#125;/** * 绘制x轴和y刻度值 * @param canvas */private void drawXAxisAndYScaleValue(Canvas canvas) &#123; for (int i = 0; i &lt; 6; i++) &#123; if (i &lt; 5) &#123; mScaleValuePaint.getTextBounds(yLabel[4 - i], 0, yLabel[4 - i].length(), bounds); canvas.drawText(yLabel[4 - i], startPointX + xScale / 15, startPointY + yScale * (i + 0.5f) + bounds.height() / 2, mScaleValuePaint); canvas.drawLine(startPointX + bounds.width() + 2 * xScale / 15, startPointY + (i + 0.5f) * yScale, startPointX + xLength, startPointY + (i + 0.5f) * yScale, mScaleLinePaint); &#125; else &#123; canvas.drawLine(startPointX, startPointY + (i + 0.5f) * yScale, startPointX + xLength, startPointY + (i + 0.5f) * yScale, mScaleLinePaint); &#125; &#125;&#125;/** * 绘制数据线条 * @param canvas */private void drawDataLines(Canvas canvas) &#123; getDataRoords(); for (int i = 0; i &lt; 6; i++) &#123; mDataLinePaint.setColor(Color.parseColor(mDataLineColors[i])); canvas.drawLine(mDataCoords[i][0], mDataCoords[i][1], mDataCoords[i + 1][0], mDataCoords[i + 1][1], mDataLinePaint); &#125;&#125;/** * 绘制数据点 * @param canvas */private void drawDataPoints(Canvas canvas) &#123; // 点击后，绘制数据点 if (isClick &amp;&amp; clickIndex &gt; -1) &#123; mDataLinePaint.setColor(Color.parseColor(mDataLineColors[clickIndex])); canvas.drawCircle(mDataCoords[clickIndex][0], mDataCoords[clickIndex][1], xScale / 10, mDataLinePaint); mDataLinePaint.setColor(Color.WHITE); canvas.drawCircle(mDataCoords[clickIndex][0], mDataCoords[clickIndex][1], xScale / 20, mDataLinePaint); mDataLinePaint.setColor(Color.parseColor(mDataLineColors[clickIndex])); &#125;&#125;/** * 绘制标题 * @param canvas */private void drawTitle(Canvas canvas) &#123; // 绘制标题文本和线条 mDataLinePaint.getTextBounds(title, 0, title.length(), bounds); canvas.drawText(title, (getWidth() - bounds.width()) / 2, startPointY + yLength + yScale, mDataLinePaint); canvas.drawLine((getWidth() - bounds.width()) / 2 - xScale / 15, startPointY + yLength + yScale - bounds.height() / 2 + coordTextSize / 4, (getWidth() - bounds.width()) / 2 - xScale / 2, startPointY + yLength + yScale - bounds.height() / 2 + coordTextSize / 4, mDataLinePaint);&#125;/** * 获取数据值的坐标点 * * @return 数据点的坐标 */private void getDataRoords() &#123; float originalPointX = startPointX; float originalPointY = startPointY + yLength - yScale; for (int i = 0; i &lt; data.length; i++) &#123; mDataCoords[i][0] = originalPointX + i * xScale; float dataY = Float.parseFloat(data[i]); float oriY = Float.parseFloat(yLabel[0]); mDataCoords[i][1] = originalPointY - (yScale * (dataY - oriY) / (Float.parseFloat(yLabel[1]) - Float.parseFloat(yLabel[0]))); &#125;&#125; getDataRoords()是为了根据数据点的值及坐标刻度的的比例关系计算出数据点的坐标，数据点（小圆圈）是点击后重绘才显示。点击数据点后，详细的数据信息采用PopupWindow来展示。点击事件就直接在onTouchEnvent中来处理：12345678910111213141516171819202122@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; float touchX = event.getX(); float touchY = event.getY(); for (int i = 0; i &lt; 7; i++) &#123; float dataX = mDataCoords[i][0]; float dataY = mDataCoords[i][1]; // 控制触摸/点击的范围，在有效范围内才触发 if (Math.abs(touchX - dataX) &lt; xScale / 2 &amp;&amp; Math.abs(touchY - dataY) &lt; yScale / 2) &#123; isClick = true; clickIndex = i; invalidate(); // 重绘展示数据点小圆圈 showDetails(i); // 通过PopupWindow展示详细数据信息 return true; &#125; else &#123; hideDetails(); &#125; clickIndex = -1; invalidate(); &#125; return super.onTouchEvent(event);&#125; 遍历数据点，根据触摸的位置判断是否在数据点的有效范围内，在有效范围内则通过showDetails(i)弹出弹窗，展示详细的百分比信息。1234567891011121314151617181920212223private void showDetails(int index) &#123; if (mPopWin != null) mPopWin.dismiss(); TextView tv = new TextView(getContext()); tv.setTextColor(Color.WHITE); tv.setBackgroundResource(R.drawable.shape_pop_bg); GradientDrawable myGrad = (GradientDrawable) tv.getBackground(); myGrad.setColor(Color.parseColor(mDataLineColors[index])); tv.setPadding(20, 0, 20, 0); tv.setGravity(Gravity.CENTER); tv.setText(data[index] + &quot;%&quot;); mPopWin = new PopupWindow(tv, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); mPopWin.setBackgroundDrawable(new ColorDrawable(0)); mPopWin.setFocusable(false); // 根据坐标点的位置计算弹窗的展示位置 int xoff = (int) (mDataCoords[index][0] - 0.5f * xScale); int yoff = -(int) (getHeight() - mDataCoords[index][1] + 0.75f * yScale); mPopWin.showAsDropDown(this, xoff, yoff); mPopWin.update();&#125;private void hideDetails() &#123; if (mPopWin != null) mPopWin.dismiss();&#125; 需要注意的是：根据需要展示的数据点的index以及数据点的坐标，计算出展示弹窗的位置xoff和xoff，弹窗的展示位置是从控件的最左下角为原点算的偏移量。 配置添加数据的方法，供外部调用12345678910111213141516171819202122232425262728293031323334/** * 设置x轴刻度值 * * @param xLabel x刻度值 */public void setxLabel(String[] xLabel) &#123; this.xLabel = xLabel;&#125;/** * 设置数据 * * @param data 数据值 */public void setData(String[] data) &#123; this.data = data;&#125;/** * 设置标题 * * @param title 标题 */public void setTitle(String title) &#123; this.title = title;&#125;/** * 重新设置x轴刻度、数据、标题后必须刷新重绘 */public void fresh() &#123; init(); postInvalidate();&#125; 当然，也可以添加自定义属性，将数据、坐标刻度值在布局文件中来配置，这里就不添加了。 使用123456789101112131415private void setData() &#123; String title = &quot;7日年化收益率(%)&quot;; String[] xLabel1 = &#123;&quot;12-11&quot;, &quot;12-12&quot;, &quot;12-13&quot;, &quot;12-14&quot;, &quot;12-15&quot;, &quot;12-16&quot;, &quot;12-17&quot;&#125;; String[] xLabel2 = &#123;&quot;2-13&quot;, &quot;2-14&quot;, &quot;2-15&quot;, &quot;2-16&quot;, &quot;2-17&quot;, &quot;2-18&quot;, &quot;2-19&quot;&#125;; String[] data1 = &#123;&quot;2.92&quot;, &quot;2.99&quot;, &quot;3.20&quot;, &quot;2.98&quot;, &quot;2.92&quot;, &quot;2.94&quot;, &quot;2.90&quot;&#125;; String[] data2 = &#123;&quot;2.50&quot;, &quot;2.50&quot;, &quot;2.50&quot;, &quot;2.50&quot;, &quot;2.50&quot;, &quot;2.50&quot;, &quot;2.50&quot;&#125;; mChartView1.setTitle(title); mChartView1.setxLabel(xLabel1); mChartView1.setData(data1); mChartView1.fresh(); mChartView2.setTitle(title); mChartView2.setxLabel(xLabel2); mChartView2.setData(data2); mChartView2.fresh();&#125; 源码：https://github.com/xiaoyanger0825/ChartView]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Path动态绘制Drawable]]></title>
    <url>%2F2017%2F02%2F06%2F%E7%94%A8Path%E5%8A%A8%E6%80%81%E7%BB%98%E5%88%B6Drawable%2F</url>
    <content type="text"><![CDATA[今日头条的下拉刷新动画在下拉过程中有一个动态绘制刷新图的效果： 基本思路按照最终呈现的图构造出完整的Path路径，根据传入的进度percent，动态截取新的Path，并且每次截取都重绘新的Path，从而实现动态绘制效果。 具体实现将效果图自定义为一个Drawable：PullDrawable。 1.初始化画笔1234567891011121314private void iniPaint() &#123; // 外部边框画笔 mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(0xffcccccc); mPaint.setStrokeWidth(4f); // 内部矩形和线条画笔 mInnerPaint = new Paint(); mInnerPaint.setAntiAlias(true); mInnerPaint.setStyle(Paint.Style.STROKE); mInnerPaint.setColor(0xffcccccc); mInnerPaint.setStrokeWidth(6f);&#125; 2.初始化Path根据Drawable的宽w和高h设置合适的外边框圆角半径r和内边距p，然后根据w、h、r、p构造出最终图的完整路径：mBorderPath、mRectPath、mLine1Path、mLine2Path、mLine3Path、mLine4Path、mLine5Path、mLine6Path。mBorderPathMeasure 、mRectPathMeasure、mLine1PathMeasure 、mLine2PathMeasure 、mLine3PathMeasure、mLine4PathMeasure、mLine5PathMeasure 、mLine6PathMeasure为路径测量类，用于测量完整路径的长度和切取制定长度的路径。mBorderDstPath 、mRectDstPath 、mLine1DstPath 、mLine2DstPath、mLine3DstPath 、mLine4DstPath 、mLine5DstPath、mLine6DstPath 为从完整路径中截取后的路径，用于重绘。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@Overrideprotected void onBoundsChange(Rect bounds) &#123; super.onBoundsChange(bounds); initPath(bounds);&#125;private void initPath(Rect bounds) &#123; int w = bounds.width(); int h = bounds.height(); int r = (int) (w * 2 / 15f); // 圆角半径 int p = (int) (r / 3f); // 内边距 // 外边框(圆角矩形) mBorderPath = new Path(); mBorderDstPath = new Path(); mBorderPath.moveTo(w - p, p + r); RectF rectFRightTop = new RectF(w - p - 2 * r, p, w - p, 2 * r + p); mBorderPath.arcTo(rectFRightTop, 0, -90); mBorderPath.lineTo(p + r, p); RectF rectFLeftTop = new RectF(p, p, p + 2 * r, p + 2 * r); mBorderPath.arcTo(rectFLeftTop, -90, -90); mBorderPath.lineTo(p, h - p - r); RectF rectFLeftBottom = new RectF(p, h - p - 2 * r, p + 2 * r, h - p); mBorderPath.arcTo(rectFLeftBottom, -180, -90); mBorderPath.lineTo(w - p - r, h - p); RectF rectFRightBottom = new RectF(w - p - 2 * r, h - p - 2 * r, w - p, h - p); mBorderPath.arcTo(rectFRightBottom, -270, -90); mBorderPath.lineTo(w - p, p + r); mBorderPathMeasure = new PathMeasure(mBorderPath, true); //////////////////////////////////////////////////////////////////////////////////////////// float d = p; // 内部矩形与水平方向上的三条横线的距离 float xp = 0.8f * r; // 水平方向相对于外边框的边距 float yp = 1.2f * r; // 竖直方向相对于外边框的边距 // 内部矩形 mRectPath = new Path(); mRectDstPath = new Path(); mRectPath.moveTo(w / 2f - d / 2f, p + yp); mRectPath.lineTo(p + xp, p + yp); mRectPath.lineTo(p + xp, (h - 2 * p - 2 * yp) * 0.4f + yp + p); mRectPath.lineTo(w / 2f - d / 2f, (h - 2 * p - 2 * yp) * 0.4f + yp + p); mRectPath.lineTo(w / 2f - d / 2f, p + yp); mRectPathMeasure = new PathMeasure(mRectPath, true); // 第1根线条 mLine1Path = new Path(); mLine1DstPath = new Path(); mLine1Path.moveTo(w / 2f + d / 2f, p + yp); mLine1Path.lineTo(w - p - xp, p + yp); mLine1PathMeasure = new PathMeasure(mLine1Path, false); // 第2根线条 mLine2Path = new Path(); mLine2DstPath = new Path(); mLine2Path.moveTo(w / 2f + d / 2f, (h - 2 * p - 2 * yp) * 0.2f + yp + p); mLine2Path.lineTo(w - p - xp, (h - 2 * p - 2 * yp) * 0.2f + yp + p); mLine2PathMeasure = new PathMeasure(mLine2Path, false); // 第3根线条 mLine3Path = new Path(); mLine3DstPath = new Path(); mLine3Path.moveTo(w / 2f + d / 2f, (h - 2 * p - 2 * yp) * 0.4f + yp + p); mLine3Path.lineTo(w - p - xp, (h - 2 * p - 2 * yp) * 0.4f + yp + p); mLine3PathMeasure = new PathMeasure(mLine3Path, false); // 第4根线条 mLine4Path = new Path(); mLine4DstPath = new Path(); mLine4Path.moveTo(p + xp, (h - 2 * p - 2 * yp) * 0.6f + yp + p); mLine4Path.lineTo(w - p - xp, (h - 2 * p - 2 * yp) * 0.6f + yp + p); mLine4PathMeasure = new PathMeasure(mLine4Path, false); // 第5根线条 mLine5Path = new Path(); mLine5DstPath = new Path(); mLine5Path.moveTo(p + xp, (h - 2 * p - 2 * yp) * 0.8f + yp + p); mLine5Path.lineTo(w - p - xp, (h - 2 * p - 2 * yp) * 0.8f + yp + p); mLine5PathMeasure = new PathMeasure(mLine5Path, false); // 第6根线条 mLine6Path = new Path(); mLine6DstPath = new Path(); mLine6Path.moveTo(p + xp, (h - 2 * p - 2 * yp) * 1f + yp + p); mLine6Path.lineTo(w - p - xp, (h - 2 * p - 2 * yp) * 1f + yp + p); mLine6PathMeasure = new PathMeasure(mLine6Path, false);&#125; 3.根据进度百分比截取路径由于外部边框和内部内容是同时绘制，外部边框在percent从0到1过程中不断截取，而内部内容则是分阶段(内部矩形和6条线分为7个阶段)进行的截取，我们只需要计算出阶段的临界点(pRect、pLine1、pLine2、pLine3、pLine4、pLine5、pLine6)，然后就可以根据百分比和临界点来计算需要截取的长度进行截取。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void update(float percent) &#123; // 每次更新前重置 mBorderDstPath.reset(); // 截取制定百分比percent长度的路径，截取后的路径保存到mBorderDstPath中 mBorderPathMeasure.getSegment(0, mBorderPathMeasure.getLength() * percent, mBorderDstPath, true); // 完整路径长度 float rectLength = mRectPathMeasure.getLength(); float line1Length = mLine1PathMeasure.getLength(); float line2Length = mLine2PathMeasure.getLength(); float line3Length = mLine3PathMeasure.getLength(); float line4Length = mLine4PathMeasure.getLength(); float line5Length = mLine5PathMeasure.getLength(); float line6Length = mLine6PathMeasure.getLength(); float totalLength = rectLength + line1Length + line2Length + line3Length + line4Length + line5Length + line6Length; // 百分比临界点 float pRect = rectLength / totalLength; float pLine1 = line1Length / totalLength + pRect; float pLine2 = line2Length / totalLength + pLine1; float pLine3 = line3Length / totalLength + pLine2; float pLine4 = line4Length / totalLength + pLine3; float pLine5 = line5Length / totalLength + pLine4; float pLine6 = line6Length / totalLength + pLine5; // 根据指定的百分比以及临界点切取路径 mRectDstPath.reset(); mRectPathMeasure.getSegment(0, rectLength * (percent / pRect), mRectDstPath, true); mLine1DstPath.reset(); mLine1PathMeasure.getSegment(0, line1Length * ((percent - pRect) / (pLine1 - pRect)), mLine1DstPath, true); mLine2DstPath.reset(); mLine2PathMeasure.getSegment(0, line2Length * ((percent - pLine1) / (pLine2 - pLine1)), mLine2DstPath, true); mLine3DstPath.reset(); mLine3PathMeasure.getSegment(0, line3Length * ((percent - pLine2) / (pLine3 - pLine2)), mLine3DstPath, true); mLine4DstPath.reset(); mLine4PathMeasure.getSegment(0, line4Length * ((percent - pLine3) / (pLine4 - pLine3)), mLine4DstPath, true); mLine5DstPath.reset(); mLine5PathMeasure.getSegment(0, line5Length * ((percent - pLine4) / (pLine5 - pLine4)), mLine5DstPath, true); mLine6DstPath.reset(); mLine6PathMeasure.getSegment(0, line6Length * ((percent - pLine5) / (pLine6 - pLine5)), mLine6DstPath, true); // 重绘 invalidateSelf();&#125; 4.重绘截取后的路径1234567891011@Overridepublic void draw(Canvas canvas) &#123; canvas.drawPath(mBorderDstPath, mPaint); canvas.drawPath(mRectDstPath, mInnerPaint); canvas.drawPath(mLine1DstPath, mInnerPaint); canvas.drawPath(mLine2DstPath, mInnerPaint); canvas.drawPath(mLine3DstPath, mInnerPaint); canvas.drawPath(mLine4DstPath, mInnerPaint); canvas.drawPath(mLine5DstPath, mInnerPaint); canvas.drawPath(mLine6DstPath, mInnerPaint);&#125; 5.添加一个清除图像的方法外部调用该方法，可以清除掉当前画面。1234567891011public void clear() &#123; mBorderDstPath.reset(); mRectDstPath.reset(); mLine1DstPath.reset(); mLine2DstPath.reset(); mLine3DstPath.reset(); mLine4DstPath.reset(); mLine5DstPath.reset(); mLine6DstPath.reset(); invalidateSelf();&#125; 在Activity中调用123mImageView = (ImageView) findViewById(R.id.image_view);mPullDrawable = new PullDrawable();mImageView.setImageDrawable(mPullDrawable); 1.通过动画不断从0到1改变percent实现动态绘制123456789101112131415161718192021222324private void startPullAnim() &#123; if (mPullValueAnimator == null) &#123; mPullValueAnimator = ValueAnimator.ofFloat(0, 1); mPullValueAnimator.setInterpolator(new LinearInterpolator()); mPullValueAnimator.setDuration(4000); mPullValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float value = (float) animation.getAnimatedValue(); mPullDrawable.update(value); &#125; &#125;); &#125; else &#123; clear(); &#125; mPullValueAnimator.start();&#125;private void clear() &#123; if (mPullValueAnimator != null &amp;&amp; mPullValueAnimator.isRunning()) &#123; mPullValueAnimator.cancel(); &#125; mPullDrawable.clear();&#125; 2.通过SeekBar拖动进度来重绘1234@Overridepublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; mPullDrawable.update(progress / 100f);&#125; 最后绘制逻辑比较简单，只是计算比例和截取长度稍显繁琐。主要的运用到的知识点就是Path的构建和PathMeasure截取。另外，PathMeasure还可以通过getPosTan(float distance, float pos[], float tan[])获取指定距离的Path的位置和正切值，通过这个位置和正切值可以实现很多跟随指定路径运动的动画效果，可以参考这篇文章的详细介绍PathMeasure之迷径追踪。 源码：https://github.com/xiaoyanger0825/HeadLinesPull]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义Drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yalantis开源项目Phoenix-Pull-to-Refresh源码分析]]></title>
    <url>%2F2017%2F01%2F22%2FYalantis%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEPhoenix-Pull-to-Refresh%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[GitHub上有个非常漂亮的Android下拉刷新框架，是由Yalantis开源的，看如下效果图：在我自己做的项目中也用到了这样的下拉刷新样式，今天就来分析下它的源码。项目地址：https://github.com/Yalantis/Phoenix 看下这个项目的library结构：除了一个工具包，真正涉及到下拉刷新UI逻辑的就只有3个类：PullToRefreshView，BaseRefreshVeiw，SunRefreshView。 官方给出的使用demo：12345678910111213&lt;com.yalantis.phoenix.PullToRefreshView android:id=&quot;@+id/pull_to_refresh&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@+id/list_view&quot; android:divider=&quot;@null&quot; android:dividerHeight=&quot;0dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/com.yalantis.phoenix.PullToRefreshView&gt; 123456789101112mPullToRefreshView = (PullToRefreshView) findViewById(R.id.pull_to_refresh);mPullToRefreshView.setOnRefreshListener(new PullToRefreshView.OnRefreshListener() &#123; @Override public void onRefresh() &#123; mPullToRefreshView.postDelayed(new Runnable() &#123; @Override public void run() &#123; mPullToRefreshView.setRefreshing(false); &#125; &#125;, REFRESH_DELAY); &#125; &#125;); 特别简单，是不是有种熟悉的感觉，基本上就和SwipeRefreshLayout的使用方式一样。 PullToRefreshViewPullToRefreshView继承自ViewGroup，那么我们就按照自定义ViewGroup的套路来进行分析。构造函数中初始化一些属性：123456789101112131415161718192021222324252627282930313233343536public PullToRefreshView(Context context, AttributeSet attrs) &#123; super(context, attrs); // 自定义属性（实际上这个属性没什么用处） TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RefreshView); final int type = a.getInteger(R.styleable.RefreshView_type, STYLE_SUN); a.recycle(); // 动画插值器 mDecelerateInterpolator = new DecelerateInterpolator(DECELERATE_INTERPOLATION_FACTOR); // 滑动触发的临界距离 mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); // 触发下拉刷新拖动的总距离 mTotalDragDistance = Utils.convertDpToPixel(context, DRAG_MAX_DISTANCE); // 头部刷新的ImageView mRefreshView = new ImageView(context); // 根据type设置刷新样式 setRefreshStyle(type); // 将头部刷新ImageVeiw添加到当前的PullToRefreshView addView(mRefreshView); setWillNotDraw(false); ViewCompat.setChildrenDrawingOrderEnabled(this, true);&#125;public void setRefreshStyle(int type) &#123; setRefreshing(false); switch (type) &#123; case STYLE_SUN: // new一个刷新的Drawable mBaseRefreshView = new SunRefreshView(getContext(), this); break; default: throw new InvalidParameterException(&quot;Type does not exist&quot;); &#125; // 设置头部刷新的ImageView(mRefreshView)设自定义的Drawable(mBaseRefreshView) mRefreshView.setImageDrawable(mBaseRefreshView);&#125; 根据上文中PullToRefreshView的使用方式，同时在构造函数中向PullToRefreshView添加了一个ImageView(mRefreshView)，可以看出整个PullToRefreshView中就只有两个子控件：mRefreshView，mTarget。mRefreshView就是下拉及刷新过程头部用来展示动画的ImageView。mTarget就是需要刷新的目标View，比如RecylerView，ListView，ScrollView。 onMeasure测量子控件（mTarget，mRefreshView）1234567891011121314151617181920212223242526272829@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 确保需要刷新的子控件Target已经添加 ensureTarget(); if (mTarget == null) return; // 测量mTarget和mRefreshView widthMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth() - getPaddingRight() - getPaddingLeft(), MeasureSpec.EXACTLY); heightMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), MeasureSpec.EXACTLY); mTarget.measure(widthMeasureSpec, heightMeasureSpec); mRefreshView.measure(widthMeasureSpec, heightMeasureSpec);&#125;private void ensureTarget() &#123; if (mTarget != null) return; if (getChildCount() &gt; 0) &#123; // 遍历子View，找到mTarget for (int i = 0; i &lt; getChildCount(); i++) &#123; View child = getChildAt(i); if (child != mRefreshView) &#123; mTarget = child; mTargetPaddingBottom = mTarget.getPaddingBottom(); mTargetPaddingLeft = mTarget.getPaddingLeft(); mTargetPaddingRight = mTarget.getPaddingRight(); mTargetPaddingTop = mTarget.getPaddingTop(); &#125; &#125; &#125;&#125; onLayout布局子控件（mTarget，mRefreshView）：123456789101112131415@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; ensureTarget(); if (mTarget == null) return; // 获取PullToRefreshView的宽高以及padding值 int height = getMeasuredHeight(); int width = getMeasuredWidth(); int left = getPaddingLeft(); int top = getPaddingTop(); int right = getPaddingRight(); int bottom = getPaddingBottom(); // 根据PullToRefreshView的宽高和内边界来布局mTarget、mRefreshView mTarget.layout(left, top + mCurrentOffsetTop, left + width - right, top + height - bottom + mCurrentOffsetTop); mRefreshView.layout(left, top, left + width - right, top + height - bottom);&#125; onInterceptTouchEvent重点来了，拦截TouchEvent。mTarget一般都是可以滚动的，要保证下拉刷新滚动和子控件mTarget内部的滑动不冲突，所以就需要重写拦截逻辑：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; // enable 或者 mTarget能滑动 或者 正在刷新，此时不拦截，交给child来分发ev if (!isEnabled() || canChildScrollUp() || mRefreshing) &#123; return false; &#125; // 事件action final int action = MotionEventCompat.getActionMasked(ev); // 根据事件类型，处理拦截逻辑 switch (action) &#123; case MotionEvent.ACTION_DOWN: // 手指down时，设置mTarget的偏移量为0 // 相当于初始化mTarget的mCurrentOffsetTop以及头部刷新的Drawable（mBaseRefreshView） setTargetOffsetTop(0, true); // 活动手指ID（触发拖动的手指） mActivePointerId = MotionEventCompat.getPointerId(ev, 0); // 不是正在被拖动 mIsBeingDragged = false; // 活动手指初始按下时的Y坐标 final float initialMotionY = getMotionEventY(ev, mActivePointerId); if (initialMotionY == -1) &#123; return false; &#125; mInitialMotionY = initialMotionY; break; case MotionEvent.ACTION_MOVE: if (mActivePointerId == INVALID_POINTER) &#123; return false; &#125; // 获取活动手指的Y坐标（当前可能有多个手指在屏幕上move，只需处理活动手指即可） final float y = getMotionEventY(ev, mActivePointerId); if (y == -1) &#123; return false; &#125; // 移动的距离yDiff大于临界值并且当前没有被拖动 // 改变拖动的状态值mIsBeingDragged为正在拖动 final float yDiff = y - mInitialMotionY; if (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) &#123; mIsBeingDragged = true; &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: // 手指cancel或者up，拖动状态为false，活动手指invalid。 mIsBeingDragged = false; mActivePointerId = INVALID_POINTER; break; case MotionEventCompat.ACTION_POINTER_UP: // 多个手指在屏幕上，当第二个手指抬起时，需要更新活动手指 onSecondaryPointerUp(ev); break; &#125; // 只要当前处于拖动状态，就拦截事件，否则不拦截 return mIsBeingDragged;&#125;/** * 当有多个手指在屏幕上时，有一个手指抬起时，需要处理的逻辑 * 多点触控时，手指的down和up之间，只有通过ID才能识别手指，当有手指抬起时，需要更新活动手指。 * @param ev */private void onSecondaryPointerUp(MotionEvent ev) &#123; final int pointerIndex = MotionEventCompat.getActionIndex(ev); final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex); if (pointerId == mActivePointerId) &#123; final int newPointerIndex = pointerIndex == 0 ? 1 : 0; mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex); &#125;&#125; 关于事件拦截机制和多点触控相关的解析可以参考大牛非著名程序员的博客：http://www.gcssloop.com/ onTouchEvent拦截到的事件，要在onTouchEvent中来处理，实现mTarget拖动的UI逻辑。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@Overridepublic boolean onTouchEvent(@NonNull MotionEvent ev) &#123; // 当前没有被拖动，不处理 if (!mIsBeingDragged) &#123; return super.onTouchEvent(ev); &#125; // 根据事件action处理不同事件逻辑 final int action = MotionEventCompat.getActionMasked(ev); switch (action) &#123; case MotionEvent.ACTION_MOVE: &#123; // 获取当前事件中活动手指的pointerIndex final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId); if (pointerIndex &lt; 0) &#123; return false; &#125; // 根据活动手指pointerIndex获取Y坐标 // 计算出手指的移动距离yDiff final float y = MotionEventCompat.getY(ev, pointerIndex); final float yDiff = y - mInitialMotionY; // mTarget需要滚动的距离scrollTop final float scrollTop = yDiff * DRAG_RATE; // 当前拖动百分比mCurrentDragPercent mCurrentDragPercent = scrollTop / mTotalDragDistance; if (mCurrentDragPercent &lt; 0) &#123; return false; &#125; // 以下逻辑都是根据当前拖动百分比和mTarget需要滚动的距离来计算出当前move事件中mTarget需要达到的目标Y坐标 // 即每一次移动都需要计算出即将要达到的位置的Y坐标，通过该即将到达的Y坐标以及当前的偏移量， // 就能计算出这次手指移动时mTarget所需要的偏移量 // 做如此处理主要是让拖动距离超过触发刷新的距离时继续拖动有一个阻尼效果 float boundedDragPercent = Math.min(1f, Math.abs(mCurrentDragPercent)); float extraOS = Math.abs(scrollTop) - mTotalDragDistance; float slingshotDist = mTotalDragDistance; float tensionSlingshotPercent = Math.max(0, Math.min(extraOS, slingshotDist * 2) / slingshotDist); float tensionPercent = (float) ((tensionSlingshotPercent / 4) - Math.pow( (tensionSlingshotPercent / 4), 2)) * 2f; float extraMove = (slingshotDist) * tensionPercent / 2; // targetY为此次手指移动mTarget即将达到的Y坐标 int targetY = (int) ((slingshotDist * boundedDragPercent) + extraMove); // 设置mBaseRefreshView(头部刷新Drawable)的百分比，用以更新刷新动画 mBaseRefreshView.setPercent(mCurrentDragPercent, true); // 设置mTarget偏移量，实现下拉 setTargetOffsetTop(targetY - mCurrentOffsetTop, true); break; &#125; case MotionEventCompat.ACTION_POINTER_DOWN: // 新的手指按下时，更新触发拖动活动手指 final int index = MotionEventCompat.getActionIndex(ev); mActivePointerId = MotionEventCompat.getPointerId(ev, index); break; case MotionEventCompat.ACTION_POINTER_UP: // 多点触控，手指抬起时更新活动手指 onSecondaryPointerUp(ev); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: &#123; if (mActivePointerId == INVALID_POINTER) &#123; return false; &#125; // 手指up或cancel，根据活动手指计算出mTarget滚动的距离overScrollTop final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId); final float y = MotionEventCompat.getY(ev, pointerIndex); final float overScrollTop = (y - mInitialMotionY) * DRAG_RATE; // 改变拖动状体 mIsBeingDragged = false; if (overScrollTop &gt; mTotalDragDistance) &#123; // mTarget被拖动的距离大于触发刷新的拖动距离时，设置当前刷新状态true setRefreshing(true, true); &#125; else &#123; // 否则，当前刷新状态为false,并且通过动画让mTarget回到最初状态 mRefreshing = false; animateOffsetToStartPosition(); &#125; // 活动手指invelid mActivePointerId = INVALID_POINTER; return false; &#125; &#125; // 消费掉当前Touch事件 return true;&#125; 手指在屏幕滑动时，mTarget的整个拖动逻辑都是在onTouchEvent中实现。在setRefershing方法中，设置PullToRefreshView当前的刷新状态：1.通过动画将mTarget偏移到正在刷新的位置2.通过动画将mTarget偏移到初始位置12345678910111213141516171819202122/** * 设置PullToRefreshView的刷新状态 * * @param refreshing 是否正在刷新 * @param notify 是否回调onRefresh */private void setRefreshing(boolean refreshing, final boolean notify) &#123; if (mRefreshing != refreshing) &#123; mNotify = notify; ensureTarget(); mRefreshing = refreshing; if (mRefreshing) &#123; // 正在刷新，设置刷新Drawable（mBaseRefreshView）的percent，用以更新刷新动画 mBaseRefreshView.setPercent(1f, true); // 通过动画让mTarget偏移到正在刷新的位置。 animateOffsetToCorrectPosition(); &#125; else &#123; // 不是正在刷新，通过动画使mTarget偏移到初始位置。 animateOffsetToStartPosition(); &#125; &#125;&#125; 在通过动画来偏移mTarget的逻辑比较简单，同样也是通过动画的执行过程来不断调用setTargetOffsetTop方法来移动mTarget。在PullToRefresh中，主要是处理拦截到的move事件，通过move事件计算出mTarget所需的偏移量来实现mTarget的拖动。同时在手指up时，通过当前拖动偏移量mCurrentOffsetTop、触发刷新的拖动距离mTotalDragDistance比较来决定是通过动画将mTarget偏移到正在刷新的位置和最初始的位置。总之，PullToRefershView是通过mTarget的偏移来实现下拉拖动。mTarget偏移的同时，将当前拖动百分比mCurrentDragPercent设置到刷新的Drawable（mBaseRefreshView）中，更新刷新动画。 BaseRefreshVeiw这个类是自定义刷新Drawable抽象类，继承自Drawable，并且实现了Animable接口。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public abstract class BaseRefreshView extends Drawable implements Drawable.Callback, Animatable &#123; private PullToRefreshLayout mRefreshLayout; private boolean mEndOfRefreshing; public BaseRefreshView(Context context, PullToRefreshLayout layout) &#123; mRefreshLayout = layout; &#125; public Context getContext() &#123; return mRefreshLayout != null ? mRefreshLayout.getContext() : null; &#125; public PullToRefreshLayout getRefreshLayout() &#123; return mRefreshLayout; &#125; /** * 设置拖动百分比，用以更新Drawable中的动画 */ public abstract void setPercent(float percent, boolean invalidate); /** * 设置偏移量，用以更新Drawable中的动画 */ public abstract void offsetTopAndBottom(int offset); // ...去掉一些无用代码... @Override public int getOpacity() &#123; return PixelFormat.TRANSLUCENT; &#125; @Override public void setAlpha(int alpha) &#123; &#125; @Override public void setColorFilter(ColorFilter cf) &#123; &#125; // ...去掉一些无用代码...&#125; BaseRefreshView作为一个抽象类，我们可以继承它来实现不同样式的刷新动画。在PullToRefershView中根据拖动实时调用setPercent(float percent, boolean invalidate)，offsetTopAndBottom(int offset)这两个方法就可以实时更新动画。 SunRefreshView具体实现就是SunRefreshView，继承自BaseRefreshView，具体的动画逻辑躲在SunRefreshView中实现。1234567891011121314151617181920@Overridepublic void setPercent(float percent, boolean invalidate) &#123; setPercent(percent); if (invalidate) setRotate(percent);&#125;@Overridepublic void offsetTopAndBottom(int offset) &#123; mTop += offset; invalidateSelf();&#125;public void setPercent(float percent) &#123; mPercent = percent;&#125;public void setRotate(float rotate) &#123; mRotate = rotate; invalidateSelf();&#125; 实现抽象父类BaseRefreshView的两个方法，offsetTopAndBottom(int offset)方法改变mTop，setPercent(float percent, boolean invalidate)方法设置mPercent和mRotate，两个方法都会重绘自己。PullToRefresh在手指拖动过程中不断调用这两个方法，达到拖动时Drawable跟随变化的动效。当手指松开时，PullToRefreshView自动回到正在刷新的状态或者初始状态，SunRefreshView的动效变化是通过调用start()和stop()方法，在start()和stop()中开始和结束mAnimation动画。123456789101112131415161718192021222324252627@Overridepublic void start() &#123; mAnimation.reset(); isRefreshing = true; mParent.startAnimation(mAnimation);&#125;@Overridepublic void stop() &#123; mParent.clearAnimation(); isRefreshing = false; resetOriginals();&#125;private void setupAnimations() &#123; mAnimation = new Animation() &#123; @Override public void applyTransformation(float interpolatedTime, Transformation t) &#123; // 根据动画时间来设置(sun)旋转，然后重绘 setRotate(interpolatedTime); &#125; &#125;; mAnimation.setRepeatCount(Animation.INFINITE); mAnimation.setRepeatMode(Animation.RESTART); mAnimation.setInterpolator(LINEAR_INTERPOLATOR); mAnimation.setDuration(ANIMATION_DURATION);&#125; 不管PullToRefreshView调用setPercent(float percent, boolean invalidate)和offsetTopAndBottom(int offset)方法，还是手指松开时调用的start()和stop()方法，最终都是要改变这三个变量：mPercent、mRotate、mTop。因为整个下拉刷新的头部动效都是通过SunRefreshView这个Drawable来不断重绘自己实现的。1234567891011121314@Overridepublic void draw(Canvas canvas) &#123; if (mScreenWidth &lt;= 0) return; // 保存当前画布状态，然后平移、裁剪画布 final int saveCount = canvas.save(); canvas.translate(0, mTop); canvas.clipRect(0, -mTop, mScreenWidth, mParent.getTotalDragDistance()); // 绘制sky、sun、town drawSky(canvas); drawSun(canvas); drawTown(canvas); // 绘制完成后恢复画布状态 canvas.restoreToCount(saveCount);&#125; 绘制过程按照mTop画布会进行平移和裁剪。绘制sky：sky的动画过程中由缩放和平移两个动画组成。缩放是通过mPrercent计算出缩放比例skyScale，平移是通过缩放比例skyScale和 PullToRefreshView的拖动比例mTotalDragDistance计算出x和y方向的偏移量。123456789101112131415161718192021222324252627private void drawSky(Canvas canvas) &#123; Matrix matrix = mMatrix; matrix.reset(); // 拖动比例 float dragPercent = Math.min(1f, Math.abs(mPercent)); float skyScale; // sky缩放比例 float scalePercentDelta = dragPercent - SCALE_START_PERCENT; // SCALE_START_PERCENT = 0.5f，SKY_INITIAL_SCALE = 1.05f // 拖动比例大于0.5时，sky缩放比例为SKY_INITIAL_SCALE - (SKY_INITIAL_SCALE - 1.0f) * scalePercent; // 拖动比例小于0.5时，sky缩放比例就为SKY_INITIAL_SCALE if (scalePercentDelta &gt; 0) &#123; /** Change skyScale between &#123;@link #SKY_INITIAL_SCALE&#125; and 1.0f depending on &#123;@link #mPercent&#125; */ float scalePercent = scalePercentDelta / (1.0f - SCALE_START_PERCENT); skyScale = SKY_INITIAL_SCALE - (SKY_INITIAL_SCALE - 1.0f) * scalePercent; &#125; else &#123; skyScale = SKY_INITIAL_SCALE; &#125; // 根据缩放比例skyScale就算出offsetX和offsetY. float offsetX = -(mScreenWidth * skyScale - mScreenWidth) / 2.0f; float offsetY = (1.0f - dragPercent) * mParent.getTotalDragDistance() - mSkyTopOffset // Offset canvas moving - mSkyHeight * (skyScale - 1.0f) / 2 // Offset sky scaling + mSkyMoveOffset * dragPercent; // Give it a little move top -&gt; bottom matrix.postScale(skyScale, skyScale); matrix.postTranslate(offsetX, offsetY); // 绘制sky canvas.drawBitmap(mSky, matrix, null);&#125; skyScale、x方向偏移量offsetX，y方向偏移量offsetY不断变化来重绘sky，实现动画效果。绘制sun：sun在下拉刷新和释放时，有三个动画：上下平移、旋转、缩放。1234567891011121314151617181920212223242526272829303132333435363738394041424344private void drawSun(Canvas canvas) &#123; Matrix matrix = mMatrix; matrix.reset(); float dragPercent = mPercent; if (dragPercent &gt; 1.0f) &#123; // Slow down if pulling over set height dragPercent = (dragPercent + 9.0f) / 10; &#125; float sunRadius = (float) mSunSize / 2.0f; float sunRotateGrowth = SUN_INITIAL_ROTATE_GROWTH; // 偏移量offsetX和offsetY决定sun的位置 // 在重绘的过程中根据mPercent和mTop实现上下平移 float offsetX = mSunLeftOffset; float offsetY = mSunTopOffset + (mParent.getTotalDragDistance() / 2) * (1.0f - dragPercent) // Move the sun up - mTop; // Depending on Canvas position // 根据拖动比例mPercent计算缩放比例 float scalePercentDelta = dragPercent - SCALE_START_PERCENT; if (scalePercentDelta &gt; 0) &#123; float scalePercent = scalePercentDelta / (1.0f - SCALE_START_PERCENT); float sunScale = 1.0f - (1.0f - SUN_FINAL_SCALE) * scalePercent; sunRotateGrowth += (SUN_FINAL_ROTATE_GROWTH - SUN_INITIAL_ROTATE_GROWTH) * scalePercent; matrix.preTranslate(offsetX + (sunRadius - sunRadius * sunScale), offsetY * (2.0f - sunScale)); matrix.preScale(sunScale, sunScale); // 缩放的同时要改变偏移量（保证缩放和上下平移时，sun的中心在竖直方向） offsetX += sunRadius; offsetY = offsetY * (2.0f - sunScale) + sunRadius * sunScale; &#125; else &#123; matrix.postTranslate(offsetX, offsetY); // 缩放的同时要改变偏移量（保证缩放和上下平移时，sun的中心在竖直方向） offsetX += sunRadius; offsetY += sunRadius; &#125; // 根据mRotate计算旋转的角度 // 拖动时旋转方向为顺时针，释放或正在刷新为逆时针方向。 // 拖动时或释放后旋转的角度按照拖动的幅度来旋转，正在刷新时每次绘制旋转1° matrix.postRotate( (isRefreshing ? -360 : 360) * mRotate * (isRefreshing ? 1 : sunRotateGrowth), offsetX, offsetY); // 绘制sun canvas.drawBitmap(mSun, matrix, null);&#125; sun的动画相对来说要复杂些，主要逻辑就是根据mPercent来计算偏移量和缩放比例，根据mRotate和sunRotateGrowth来计算旋转角度。绘制town：town的绘制逻辑和sky一样，只涉及到平移和缩放。123456789101112131415161718192021222324252627282930313233343536private void drawTown(Canvas canvas) &#123; Matrix matrix = mMatrix; matrix.reset(); float dragPercent = Math.min(1f, Math.abs(mPercent)); float townScale; float townTopOffset; float townMoveOffset; // 计算缩放比例 float scalePercentDelta = dragPercent - SCALE_START_PERCENT; if (scalePercentDelta &gt; 0) &#123; /** * Change townScale between &#123;@link #TOWN_INITIAL_SCALE&#125; and &#123;@link #TOWN_FINAL_SCALE&#125; depending on &#123;@link #mPercent&#125; * Change townTopOffset between &#123;@link #mTownInitialTopOffset&#125; and &#123;@link #mTownFinalTopOffset&#125; depending on &#123;@link #mPercent&#125; */ float scalePercent = scalePercentDelta / (1.0f - SCALE_START_PERCENT); townScale = TOWN_INITIAL_SCALE + (TOWN_FINAL_SCALE - TOWN_INITIAL_SCALE) * scalePercent; townTopOffset = mTownInitialTopOffset - (mTownFinalTopOffset - mTownInitialTopOffset) * scalePercent; townMoveOffset = mTownMoveOffset * (1.0f - scalePercent); &#125; else &#123; float scalePercent = dragPercent / SCALE_START_PERCENT; townScale = TOWN_INITIAL_SCALE; townTopOffset = mTownInitialTopOffset; townMoveOffset = mTownMoveOffset * scalePercent; &#125; // 计算平移量 float offsetX = -(mScreenWidth * townScale - mScreenWidth) / 2.0f; float offsetY = (1.0f - dragPercent) * mParent.getTotalDragDistance() // Offset canvas moving + townTopOffset - mTownHeight * (townScale - 1.0f) / 2 // Offset town scaling + townMoveOffset; // Give it a little move matrix.postScale(townScale, townScale); matrix.postTranslate(offsetX, offsetY); // 绘制town canvas.drawBitmap(mTown, matrix, null);&#125; 将sky、sun、town绘制完成。在绘制过程中与平移量、缩放比例、旋转角度有关的mTop、mPercent、mRotate这三个变量都是在PullToRefreshView下拉刷新过程中不断改变的。sky、sun、town组合在一起伴随着下拉刷新的过程不断重绘，从而实现刷新动画。 总结PullToRefreshView主要是实现mTarget的拖动并解决mTarget内部滑动时的冲突。SunRefreshView主要是在PullToRefresh有变化时不断重绘自己实现动画效果。 Yalantis还有另外两个下拉刷新的开源项目Pull-to-Refresh.Tours和Pull-To-Make-Soup，里面的PullToRefreshView都是和Phoenix-Pull-to-Refresh中的一样，只是自定义了不同BaseRefreshView，我们也可以根据这个框架的PullToRefreshView来自定义自己的下拉刷新Drawable，实现自己的下拉刷新样式。 文中可能有理解有误或疏漏之处，欢迎大家指正，谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用logger打印完整的okhttp网络请求和响应日志]]></title>
    <url>%2F2017%2F01%2F17%2F%E5%88%A9%E7%94%A8logger%E6%89%93%E5%8D%B0%E5%AE%8C%E6%95%B4%E7%9A%84okhttp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[我们公司在项目中使用的网络请求工具是Retrofit，底层封装的是OkHttp，通常调试网络接口时都会将网络请求和响应相关数据通过日志的形式打印出来。OkHttp也提供了一个网络拦截器okhttp-logging-interceptor，通过它能拦截okhttp网络请求和响应所有相关信息（请求行、请求头、请求体、响应行、响应行、响应头、响应体）。 使用okhttp网络日志拦截器：1compile &apos;com.squareup.okhttp3:logging-interceptor:3.5.0&apos; 定义拦截器中的网络日志工具123456public class HttpLogger implements HttpLoggingInterceptor.Logger &#123; @Override public void log(String message) &#123; Log.d(&quot;HttpLogInfo&quot;, message); &#125; &#125; 初始化OkHttpClient，并添加网络日志拦截器12345678910111213141516/*** 初始化okhttpclient.** @return okhttpClient*/private OkHttpClient okhttpclient() &#123; if (mOkHttpClient == null) &#123; HttpLoggingInterceptor logInterceptor = new HttpLoggingInterceptor(new HttpLogger()); logInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); mOkHttpClient = new OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .addNetworkInterceptor(logInterceptor) .build(); &#125; return mOkHttpClient;&#125; 打印出来的日志 在给OkhttpClient添加网络请求拦截器的时候需要注意，应该调用方法addNetworkInterceptor，而不是addInterceptor。因为有时候可能会通过cookieJar在header里面去添加一些持久化的cookie或者session信息。这样就在请求头里面就不会打印出这些信息。看一下OkHttpClient调用拦截器的源码：12345678910111213141516Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; 在okhttp执行网络请求时，会先构造拦截链，此时是将所有的拦截器都放入一个ArrayList中，看源码就知道添加拦截器的顺序是：client.interceptors()，BridgeInterceptor，CacheInterceptor，ConnectInterceptor，networkInterceptors，CallServerInterceptor。在通过拦截链执行拦截逻辑是按先后顺序递归调用的。如果是我们调用addInterceptor方法来添加HttpLoggingInterceptor拦截器，那么网络日志拦截器就会被添加到client.networkInterceptors()里面，根据添加到ArrayList中的顺序，执行拦截时会先执行HttpLoggingInterceptor，并打印出日志。然后才会执行CookieJar包装的拦截器BridgeInterceptor。这就导致我们添加header中的cookie等信息不会打印出来。 利用HttpLoggingInterceptor打印网络日志非常完整，但是看到响应的结果数据时，感觉有些混乱，平常在调试时希望一眼就能看清楚json数据的层次结构，所以需要将响应结果的json串进行格式化。 我采用的是开源日志库looger来打印，这个库不但能很方便的帮开发者过滤掉系统日志，而且对打印出来的效果作了优化，更加简洁美观。 关于looger的详细的API：传送门。 加入logger的依赖：1compile &apos;com.orhanobut:logger:1.15&apos; 在使用looger库的时候我通常都会先封装一层，作为一个工具类。12345678910111213141516171819202122232425262728293031323334public class LogUtil &#123; /** * 初始化log工具，在app入口处调用 * * @param isLogEnable 是否打印log */ public static void init(boolean isLogEnable) &#123; Logger.init(&quot;LogHttpInfo&quot;) .hideThreadInfo() .logLevel(isLogEnable ? LogLevel.FULL : LogLevel.NONE) .methodOffset(2); &#125; public static void d(String message) &#123; Logger.d(message); &#125; public static void i(String message) &#123; Logger.i(message); &#125; public static void w(String message, Throwable e) &#123; String info = e != null ? e.toString() : &quot;null&quot;; Logger.w(message + &quot;：&quot; + info); &#125; public static void e(String message, Throwable e) &#123; Logger.e(e, message); &#125; public static void json(String json) &#123; Logger.json(json); &#125;&#125; 在应用入口调用初始化方法12345678public class App extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // 初始化Looger工具 LogUtil.init(BuildConfig.LOG_DEBUG); &#125;&#125; 如果直接在LoggerHttp的log方法中调用LogUtil.d(message)，打印出来的日志是分散的，因为log方法是将一个网络请求的请求\响应行、header逐条打印的。但想要的效果是将同一个网络请求和响应的所有信息合并成一条日志，这样才方便调试时查看。所以需要在LoggerHttp的log方法中做一些逻辑处理：123456789101112131415161718192021private class HttpLogger implements HttpLoggingInterceptor.Logger &#123; private StringBuilder mMessage = new StringBuilder(); @Override public void log(String message) &#123; // 请求或者响应开始 if (message.startsWith(&quot;--&gt; POST&quot;)) &#123; mMessage.setLength(0); &#125; // 以&#123;&#125;或者[]形式的说明是响应结果的json数据，需要进行格式化 if ((message.startsWith(&quot;&#123;&quot;) &amp;&amp; message.endsWith(&quot;&#125;&quot;)) || (message.startsWith(&quot;[&quot;) &amp;&amp; message.endsWith(&quot;]&quot;))) &#123; message = JsonUtil.formatJson(JsonUtil.decodeUnicode(message)); &#125; mMessage.append(message.concat(&quot;\n&quot;)); // 响应结束，打印整条日志 if (message.startsWith(&quot;&lt;-- END HTTP&quot;)) &#123; LogUtil.d(mMessage.toString()); &#125; &#125;&#125; 这里之所以没有采用looger库的Looger.json(String json)方法去打印json数据，是因为这个方法调用也会打印成单独的一条日志，不能实现将请求的所有信息在一条日志中。JsonUtil是单独封装的一个将json格式化的工具，通过formatJson(String json)将json串格式化出清晰的层次结构。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 格式化json字符串 * * @param jsonStr 需要格式化的json串 * @return 格式化后的json串 */public static String formatJson(String jsonStr) &#123; if (null == jsonStr || &quot;&quot;.equals(jsonStr)) return &quot;&quot;; StringBuilder sb = new StringBuilder(); char last = &apos;\0&apos;; char current = &apos;\0&apos;; int indent = 0; for (int i = 0; i &lt; jsonStr.length(); i++) &#123; last = current; current = jsonStr.charAt(i); //遇到&#123; [换行，且下一行缩进 switch (current) &#123; case &apos;&#123;&apos;: case &apos;[&apos;: sb.append(current); sb.append(&apos;\n&apos;); indent++; addIndentBlank(sb, indent); break; //遇到&#125; ]换行，当前行缩进 case &apos;&#125;&apos;: case &apos;]&apos;: sb.append(&apos;\n&apos;); indent--; addIndentBlank(sb, indent); sb.append(current); break; //遇到,换行 case &apos;,&apos;: sb.append(current); if (last != &apos;\\&apos;) &#123; sb.append(&apos;\n&apos;); addIndentBlank(sb, indent); &#125; break; default: sb.append(current); &#125; &#125;return sb.toString();&#125;/** * 添加space * * @param sb * @param indent */private static void addIndentBlank(StringBuilder sb, int indent) &#123; for (int i = 0; i &lt; indent; i++) &#123; sb.append(&apos;\t&apos;); &#125;&#125; decodeUnicode(String json)是将json中的Unicode编码转化为汉字编码（unicode编码的json中的汉字打印出来有可能是\u开头的字符串，所以需要处理）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * http 请求数据返回 json 中中文字符为 unicode 编码转汉字转码 * * @param theString * @return 转化后的结果. */public static String decodeUnicode(String theString) &#123; char aChar; int len = theString.length(); StringBuffer outBuffer = new StringBuffer(len); for (int x = 0; x &lt; len; ) &#123; aChar = theString.charAt(x++); if (aChar == &apos;\\&apos;) &#123; aChar = theString.charAt(x++); if (aChar == &apos;u&apos;) &#123; int value = 0; for (int i = 0; i &lt; 4; i++) &#123; aChar = theString.charAt(x++); switch (aChar) &#123; case &apos;0&apos;: case &apos;1&apos;: case &apos;2&apos;: case &apos;3&apos;: case &apos;4&apos;: case &apos;5&apos;: case &apos;6&apos;: case &apos;7&apos;: case &apos;8&apos;: case &apos;9&apos;: value = (value &lt;&lt; 4) + aChar - &apos;0&apos;; break; case &apos;a&apos;: case &apos;b&apos;: case &apos;c&apos;: case &apos;d&apos;: case &apos;e&apos;: case &apos;f&apos;: value = (value &lt;&lt; 4) + 10 + aChar - &apos;a&apos;; break; case &apos;A&apos;: case &apos;B&apos;: case &apos;C&apos;: case &apos;D&apos;: case &apos;E&apos;: case &apos;F&apos;: value = (value &lt;&lt; 4) + 10 + aChar - &apos;A&apos;; break; default: throw new IllegalArgumentException( &quot;Malformed \\uxxxx encoding.&quot;); &#125; &#125; outBuffer.append((char) value); &#125; else &#123; if (aChar == &apos;t&apos;) aChar = &apos;\t&apos;; else if (aChar == &apos;r&apos;) aChar = &apos;\r&apos;; else if (aChar == &apos;n&apos;) aChar = &apos;\n&apos;; else if (aChar == &apos;f&apos;) aChar = &apos;\f&apos;; outBuffer.append(aChar); &#125; &#125; else outBuffer.append(aChar); &#125; return outBuffer.toString();&#125; 最终效果（不能将图全部截出来，所以我就把日志贴成代码段了）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172D/LogHttpInfo: ╔════════════════════════════════════════════════════════════════════════════════════════D/LogHttpInfo: ║ RealInterceptorChain.proceed (RealInterceptorChain.java:92)D/LogHttpInfo: ║ HttpLoggingInterceptor.intercept (HttpLoggingInterceptor.java:266)D/LogHttpInfo: ╟────────────────────────────────────────────────────────────────────────────────────────D/LogHttpInfo: ║ --&gt; POST http://op.juhe.cn/onebox/movie/video http/1.1D/LogHttpInfo: ║ Content-Type: application/x-www-form-urlencodedD/LogHttpInfo: ║ Content-Length: 95D/LogHttpInfo: ║ Host: op.juhe.cnD/LogHttpInfo: ║ Connection: Keep-AliveD/LogHttpInfo: ║ Accept-Encoding: gzipD/LogHttpInfo: ║ User-Agent: okhttp/3.5.0D/LogHttpInfo: ║ D/LogHttpInfo: ║ key=a3d3a43fcc149b6ed8268b8fa41d27b7&amp;dtype=json&amp;q=%E9%81%97%E8%90%BD%E7%9A%84%E4%B8%96%E7%95%8CD/LogHttpInfo: ║ --&gt; END POST (95-byte body)D/LogHttpInfo: ║ &lt;-- 200 OK http://op.juhe.cn/onebox/movie/video (760ms)D/LogHttpInfo: ║ Server: nginxD/LogHttpInfo: ║ Date: Mon, 16 Jan 2017 09:36:35 GMTD/LogHttpInfo: ║ Content-Type: application/json;charset=utf-8D/LogHttpInfo: ║ Transfer-Encoding: chunkedD/LogHttpInfo: ║ Connection: keep-aliveD/LogHttpInfo: ║ X-Powered-By: PHP/5.6.23D/LogHttpInfo: ║ D/LogHttpInfo: ║ &#123;D/LogHttpInfo: ║ &quot;reason&quot;:&quot;查询成功&quot;,D/LogHttpInfo: ║ &quot;result&quot;:&#123;D/LogHttpInfo: ║ &quot;title&quot;:&quot;遗失的世界&quot;,D/LogHttpInfo: ║ &quot;tag&quot;:&quot;动作 \/ 科幻&quot;,D/LogHttpInfo: ║ &quot;act&quot;:&quot;詹妮弗·奥黛尔 威尔·斯诺 拉塞尔·布雷克利&quot;,D/LogHttpInfo: ║ &quot;year&quot;:&quot;1999&quot;,D/LogHttpInfo: ║ &quot;rating&quot;:null,D/LogHttpInfo: ║ &quot;area&quot;:&quot;美国&quot;,D/LogHttpInfo: ║ &quot;dir&quot;:&quot;理查德·富兰克林&quot;,D/LogHttpInfo: ║ &quot;desc&quot;:&quot;本剧取材于制造出福尔摩斯这个人物形象的英国著名作家亚瑟.柯南道尔的经典小说。故事讲述的是在一块未开发的土地上遭遇恐龙的危险经历。 一名孤独的探险家死去了，他那破旧的、包有皮边的笔记本便成为因时间而被淡忘了的史前高原探险活动的惟一的线索。 在伦敦，爱德华·查林杰教授召集了擅长不同领域的冒险家，组建了一支探险队，决心证实遗失的世界的存在，在地图上未标明的丛林中探险。 在亚马逊丛林一片被时间遗忘的高原土地上，科学探险队的几位成员在寻找离开高原的路径。他们必须防御来自原始部落猎人们的袭击。他们在野外的高原上遇阻，无法返回，而这里又是一个令人害怕的世界，时常出没一些史前的食肉动物、原始的猿人、奇特的植物和吸血的蝙蝠。为了生存，这群命运不济的人必须团结起来，拋弃个人之间的喜好和偏见，随时准备应付任何可能突发的情况。在野性丛林美女维罗尼卡的帮助下，手中只有几只猎枪的他们用智能一次又一次摆脱了死亡的威胁。&quot;,D/LogHttpInfo: ║ &quot;cover&quot;:&quot;http:\/\/p6.qhimg.com\/t0160a8a6f5b768034a.jpg&quot;,D/LogHttpInfo: ║ &quot;vdo_status&quot;:&quot;play&quot;,D/LogHttpInfo: ║ &quot;playlinks&quot;:&#123;D/LogHttpInfo: ║ &quot;tudou&quot;:&quot;http:\/\/www.tudou.com\/programs\/view\/KVeyWojke1M\/?tpa=dW5pb25faWQ9MTAyMjEzXzEwMDAwMV8wMV8wMQ&quot;D/LogHttpInfo: ║ &#125;,D/LogHttpInfo: ║ &quot;video_rec&quot;:[D/LogHttpInfo: ║ &#123;D/LogHttpInfo: ║ &quot;cover&quot;:&quot;http:\/\/p2.qhimg.com\/d\/dy_4dc349a3bf8c1b267d3236f3b74c8ea2.jpg&quot;,D/LogHttpInfo: ║ &quot;detail_url&quot;:&quot;http:\/\/www.360kan.com\/tv\/PrRoc3GoSzDpMn.html&quot;,D/LogHttpInfo: ║ &quot;title&quot;:&quot;阿尔法战士 第一季&quot;D/LogHttpInfo: ║ &#125;,D/LogHttpInfo: ║ &#123;D/LogHttpInfo: ║ &quot;cover&quot;:&quot;http:\/\/p7.qhimg.com\/t01513514907831e055.jpg&quot;,D/LogHttpInfo: ║ &quot;detail_url&quot;:&quot;http:\/\/www.360kan.com\/tv\/Q4Frc3GoRmbuMX.html&quot;,D/LogHttpInfo: ║ &quot;title&quot;:&quot;浩劫余生 第一季&quot;D/LogHttpInfo: ║ &#125;D/LogHttpInfo: ║ ],D/LogHttpInfo: ║ &quot;act_s&quot;:[D/LogHttpInfo: ║ &#123;D/LogHttpInfo: ║ &quot;name&quot;:&quot;詹妮弗·奥黛尔&quot;,D/LogHttpInfo: ║ &quot;url&quot;:&quot;http:\/\/baike.so.com\/doc\/5907024-6119928.html&quot;,D/LogHttpInfo: ║ &quot;image&quot;:&quot;http:\/\/p2.qhmsg.com\/dmsmty\/120_110_100\/t0154caf60f6fa2dc56.jpg&quot;D/LogHttpInfo: ║ &#125;,D/LogHttpInfo: ║ &#123;D/LogHttpInfo: ║ &quot;name&quot;:&quot;威尔·斯诺&quot;,D/LogHttpInfo: ║ &quot;url&quot;:&quot;http:\/\/baike.so.com\/doc\/204403-216173.html&quot;,D/LogHttpInfo: ║ &quot;image&quot;:&quot;http:\/\/p8.qhmsg.com\/dmsmty\/120_110_100\/t018d2ce8920050594f.jpg&quot;D/LogHttpInfo: ║ &#125;,D/LogHttpInfo: ║ &#123;D/LogHttpInfo: ║ &quot;name&quot;:&quot;拉塞尔·布雷克利&quot;,D/LogHttpInfo: ║ &quot;url&quot;:&quot;http:\/\/baike.so.com\/doc\/1057636-1118829.html&quot;,D/LogHttpInfo: ║ &quot;image&quot;:&quot;http:\/\/p2.qhmsg.com\/dmsmty\/120_110_100\/t01aa727c49da3edc79.jpg&quot;D/LogHttpInfo: ║ &#125;D/LogHttpInfo: ║ ]D/LogHttpInfo: ║ &#125;,D/LogHttpInfo: ║ &quot;error_code&quot;:0D/LogHttpInfo: ║ &#125;D/LogHttpInfo: ║ &lt;-- END HTTP (2994-byte body)D/LogHttpInfo: ╚════════════════════════════════════════════════════════════════════════════════════════ 通过这样的方式打印出来的网络请求日志包含了所有的网络信息， 并且结构层次非常清晰。源码：https://github.com/xiaoyanger0825/LogHttpInfo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[京东快报轮播公告的实现]]></title>
    <url>%2F2017%2F01%2F14%2F%E4%BA%AC%E4%B8%9C%E5%BF%AB%E6%8A%A5%E8%BD%AE%E6%92%AD%E5%85%AC%E5%91%8A%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[手机京东app首页的京东快报有一个无限轮播的公告栏，先看效果：公告内容大概每3s从中间向上滑出，同时下一条内容从底部向上滑动进入。整个过程还伴随有内容的渐变消失。开始想这样的效果可以通过自绘控件来实现，后面再想想采用ViewFlipper来实现更为简单。看看ViewFlipper类官方注释： Simple {@link ViewAnimator} that will animate between two or more views that have been added to it. Only one child is shown at a time. If requested, can automatically flip between each child at a regular interval. 大概意思就是ViewFlipper是一个容器，能够将添加在里面的两个或更多子View动画的切换，在一个时间点只有一个child展示出来。并且可以自动的在每隔一个时间段切换到一个child。要实现京东快报的切换效果，我们只需要将需要根据轮播的公告内容设置到TextView并添加到ViewFlipper，同时设置他们之间的切换动画就可以了。 为了方便在项目中直接使用，我们将其自定义为一个继承自ViewFlipper的控件NoticeView。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * Created by xjj on 2017/1/14. * 轮播公告Veiw */public class NoticeView extends ViewFlipper implements View.OnClickListener &#123; private Context mContext; private List&lt;String&gt; mNotices; public NoticeView(Context context) &#123; super(context); &#125; public NoticeView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; private void init(Context context) &#123; mContext = context; // 轮播间隔时间为3s setFlipInterval(3000); // 内边距5dp setPadding(dp2px(5f), dp2px(5f), dp2px(5f), dp2px(5f)); // 设置enter和leave动画 setInAnimation(AnimationUtils.loadAnimation(mContext, R.anim.notify_in)); setOutAnimation(AnimationUtils.loadAnimation(mContext, R.anim.notify_out)); &#125; /** * 添加需要轮播展示的公告 * * @param notices */ public void addNotice(List&lt;String&gt; notices) &#123; mNotices = notices; removeAllViews(); for (int i = 0; i &lt; mNotices.size(); i++) &#123; // 根据公告内容构建一个TextView String notice = notices.get(i); TextView textView = new TextView(mContext); textView.setSingleLine(); textView.setText(notice); textView.setTextSize(13f); textView.setEllipsize(TextUtils.TruncateAt.END); textView.setTextColor(Color.parseColor(&quot;#666666&quot;)); textView.setGravity(Gravity.CENTER_VERTICAL); // 将公告的位置设置为textView的tag方便点击是回调给用户 textView.setTag(i); textView.setOnClickListener(this); // 添加到ViewFlipper NoticeView.this.addView(textView, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)); &#125; &#125; @Override public void onClick(View v) &#123; int position = (int) v.getTag(); String notice = (String) mNotices.get(i); if (mOnNoticeClickListener != null) &#123; mOnNoticeClickListener.onNotieClick(position, notice); &#125; &#125; /** * 通知点击监听接口 */ public interface OnNoticeClickListener &#123; void onNotieClick(int position, String notice); &#125; private OnNoticeClickListener mOnNoticeClickListener; /** * 设置通知点击监听器 * * @param onNoticeClickListener 通知点击监听器 */ public void setOnNoticeClickListener(OnNoticeClickListener onNoticeClickListener) &#123; mOnNoticeClickListener = onNoticeClickListener; &#125; private int dp2px(float dpValue) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, mContext.getResources().getDisplayMetrics()); &#125;&#125; 公告内容进入动画notice_in.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--平移--&gt; &lt;translate android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromYDelta=&quot;50%p&quot; android:toYDelta=&quot;0&quot;/&gt; &lt;!--渐变--&gt; &lt;alpha android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt;&lt;/set&gt; 公告内容滑出动画notice_out.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--平移--&gt; &lt;translate android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;-50%p&quot;/&gt; &lt;!--渐变--&gt; &lt;alpha android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot;/&gt;&lt;/set&gt; 在Activity中使用123456789private void init() &#123; NoticeView noticeView = (NoticeView) findViewById(R.id.notice_view); List&lt;String&gt; notices = new ArrayList&lt;&gt;(); notices.add(&quot;大促销下单拆福袋，亿万新年红包随便拿&quot;); notices.add(&quot;家电五折团，抢十亿无门槛现金红包&quot;); notices.add(&quot;星球大战剃须刀首发送200元代金券&quot;); noticeView.addNotice(notices); noticeView.startFlipping();&#125; 最终效果（布局代码就不贴了，比较简单） 源码：https://github.com/xiaoyanger0825/NoticeView]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义ViewPager轮播图指示器]]></title>
    <url>%2F2017%2F01%2F13%2F%E8%87%AA%E5%AE%9A%E4%B9%89ViewPager%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%8C%87%E7%A4%BA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[轮播图在项目中一般会使用VeiwPager来实现，同时还会关联轮播指示器。上一篇文章给ViewPager添加一个自定义的滚动监听器实现了一个自定义的滚动监听器，现在通过这个监听器的关联可以很方便的实现一个自定义的指示器。改造ViewPager的OnPageChangedListener，添加自定义的ViewPager滚动监听器（直接将上一篇文章的代码贴过来了）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * ViewPager辅助类 */public class ViewPagerHelper implements ViewPager.OnPageChangeListener &#123; private double mLastPositionOffsetSum; // 上一次滑动总的偏移量 private OnPageScrollListener mOnPageScrollListener; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; // 当前总的偏移量 float currentPositionOffsetSum = position + positionOffset; // 上次滑动的总偏移量大于此次滑动的总偏移量，页面从右向左进入(手指从右向左滑动) boolean rightToLeft = mLastPositionOffsetSum &lt;= currentPositionOffsetSum; if (currentPositionOffsetSum == mLastPositionOffsetSum) return; int enterPosition; int leavePosition; float percent; if (rightToLeft) &#123; // 从右向左滑 enterPosition = (positionOffset == 0.0f) ? position : position + 1; leavePosition = enterPosition - 1; percent = (positionOffset == 0.0f) ? 1.0f : positionOffset; &#125; else &#123; // 从左向右滑 enterPosition = position; leavePosition = position + 1; percent = 1 - positionOffset; &#125; if (mOnPageScrollListener != null) &#123; mOnPageScrollListener.onPageScroll(enterPosition, leavePosition, percent); &#125; mLastPositionOffsetSum = currentPositionOffsetSum; &#125; @Override public void onPageSelected(int position) &#123; if (mOnPageScrollListener != null) &#123; mOnPageScrollListener.onPageSelected(position); &#125; &#125; /** * @param state 当前滑动状态 * ViewPager.SCROLL_STATE_IDLE 页面处于闲置、稳定状态，即没被拖动也没惯性滑动 * ViewPager.SCROLL_STATE_DRAGGING 页面正在被用户拖动，即手指正在拖动状态 * Viewpager.SCROLL_STATE_SETTLING 页面处于即将到达最终状态的过程，即手指松开后惯性滑动状态 */ @Override public void onPageScrollStateChanged(int state) &#123; if (mOnPageScrollListener != null) &#123; mOnPageScrollListener.onPageScrollStateChanged(state); &#125; &#125; public void bindScrollListener(ViewPager viewPager, OnPageScrollListener onPageScrollListener) &#123; mOnPageScrollListener = onPageScrollListener; viewPager.addOnPageChangeListener(this); &#125;&#125; 123456789101112131415161718192021222324252627/** * ViewPage的页面滚动监听器 */public interface OnPageScrollListener &#123; /** * 页面滚动时调用 * * @param enterPosition 进入页面的位置 * @param leavePosition 离开的页面的位置 * @param percent 滑动百分比 */ void onPageScroll(int enterPosition, int leavePosition, float percent); /** * 页面选中时调用 * * @param position 选中页面的位置 */ void onPageSelected(int position); /** * 页面滚动状态变化时调用 * * @param state 页面的滚动状态 */ void onPageScrollStateChanged(int state);&#125; 根据两种指示器的效果分析，都是通过回调onPageScroll方法中不断变化的enterPositon、leavePosition和percent来实现。 NumberIndicator（数字指示器）当ViewPager页面从右向左滑动时，指示器中对应页面的数字从下往上滚动，页面停止，数字停止在中间位置。当ViewPager页面从左向右滑动时，指示器中对应页面的数字从下往上滚动，页面停止，数字停止在中间位置。 最终指示器效果可以采用绘制View的方式来实现（当然也可以采用组合控件的方式来实现）。ViewPager页面滑动时，不断重绘View，达到指示数字上下滑动的效果。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/** * 数字指示器 */public class NumberIndicater extends View implements OnPageScrollListener &#123; private Context mContext; private int mCircleColor; private int mCircleSize; private int mNumberColor; private int mNumberSize; private int mCount; private int mCurrent; private Paint mCirclePaint; private Paint mTextPaint; private float offset; // 页面偏移百分比 private boolean isUp; // 指示器数字是否向上滑动 public NumberIndicater(Context context) &#123; this(context, null); &#125; public NumberIndicater(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public NumberIndicater(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initAttrs(context, attrs); initPaint(); &#125; /** * 初始化属性 * * @param context * @param attrs */ private void initAttrs(Context context, AttributeSet attrs) &#123; mContext = context; mCircleSize = dp2px(48f); mCircleColor = 0xfffdd63b; mNumberSize = sp2px(14f); mNumberColor = 0xff353535; // 自定义属性 TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.NumberIndicater); mCircleColor = ta.getColor(R.styleable.NumberIndicater_circle_color, mCircleColor); mCircleSize = (int) ta.getDimension(R.styleable.NumberIndicater_circle_size, mCircleSize); mNumberColor = ta.getColor(R.styleable.NumberIndicater_number_color, mNumberColor); mNumberSize = (int) ta.getDimension(R.styleable.NumberIndicater_number_size, mNumberSize); ta.recycle(); &#125; private void initPaint() &#123; mCirclePaint = new Paint(); mCirclePaint.setAntiAlias(true); mCirclePaint.setColor(mCircleColor); mCirclePaint.setStyle(Paint.Style.FILL_AND_STROKE); mTextPaint = new Paint(); mTextPaint.setAntiAlias(true); mTextPaint.setTextAlign(Paint.Align.LEFT); mTextPaint.setColor(mNumberColor); mTextPaint.setTextSize(mNumberSize); offset = 1; mCount = 3; mCurrent = 1; isUp = true; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 设置测量后的尺寸 setMeasuredDimension(measure(widthMeasureSpec), measure(heightMeasureSpec)); &#125; private int measure(int measureSpec) &#123; int size = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.EXACTLY: size = specSize; break; case MeasureSpec.AT_MOST: case MeasureSpec.UNSPECIFIED: size = mCircleSize; break; &#125; return size; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制圆形底图 canvas.drawCircle(getWidth() / 2f, getHeight() / 2f, mCircleSize / 2f, mCirclePaint); // 绘制分割线 drawSplit(canvas); // 绘制右边总数数字 drawTotleNumber(canvas); // 绘制左边指示数字 drawIndicatNumber(canvas); &#125; private void drawSplit(Canvas canvas) &#123; String text = &quot;/&quot;; float width = mTextPaint.measureText(text); float x = (getWidth() - width) / 2f; Paint.FontMetrics fontMetrics = mTextPaint.getFontMetrics(); float y = getHeight() / 2f + (Math.abs(fontMetrics.ascent) - fontMetrics.descent) / 2f; // x为绘制文本左边缘距离X轴的距离，y为绘制文本基线距离Y轴的位置 canvas.drawText(text, x, y, mTextPaint); &#125; private void drawTotleNumber(Canvas canvas) &#123; String text = String.valueOf(mCount); float x = getWidth() / 2f + mTextPaint.measureText(&quot;/&quot;) / 2f + 3; Paint.FontMetrics fontMetrics = mTextPaint.getFontMetrics(); float y = getHeight() / 2f + (Math.abs(fontMetrics.ascent) - fontMetrics.descent) / 2f; canvas.drawText(text, x, y, mTextPaint); &#125; private void drawIndicatNumber(Canvas canvas) &#123; mTextPaint.setTextSize(mNumberSize * 1.3f); String text = String.valueOf(mCurrent); Rect rect = new Rect(); // 获取文本的宽度 float width = mTextPaint.measureText(text); // 获取文本的高度 mTextPaint.getTextBounds(text, 0, text.length(), rect); float height = rect.height(); // 文本左边缘距离X轴的距离 float x = getWidth() / 2f - mTextPaint.measureText(&quot;/&quot;) / 2f - 3 - width; Paint.FontMetrics fontMetrics = mTextPaint.getFontMetrics(); // 文本基线位置距离Y轴的距离 float y = getHeight() / 2f + (Math.abs(fontMetrics.ascent) - fontMetrics.descent) / 2f; if (isUp) &#123; // 指示数字向上滑动 y = offset * y + (1 - offset) * (getHeight() / 2f - mCircleSize / 2f + mCircleSize + height); &#125; else &#123; // 指示数字向下滑动 y = offset * y + (1 - offset) * (getHeight() / 2f - mCircleSize / 2f); &#125; canvas.drawText(text, x, y, mTextPaint); mTextPaint.setTextSize(mNumberSize); &#125; /** * 将指示器绑定到ViewPager * * @param viewPager view pager */ public void bindViewPager(ViewPager viewPager) &#123; if (viewPager != null &amp;&amp; viewPager.getAdapter() != null) &#123; mCount = viewPager.getAdapter().getCount(); new ViewPagerHelper().bindScrollListener(viewPager, this); invalidate(); // 绑定ViewPager后指示器重绘，因为指示器的数字与初始的可能不同 &#125; &#125; @Override public void onPageScroll(int enterPosition, int leavePosition, float percent) &#123; mCurrent = enterPosition + 1; offset = percent; isUp = enterPosition &gt; leavePosition; postInvalidate(); // 滑动过程中不断重绘 &#125; @Override public void onPageSelected(int position) &#123; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; private int dp2px(float dpValue) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, mContext.getResources().getDisplayMetrics()); &#125; private int sp2px(float dpValue) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, dpValue, mContext.getResources().getDisplayMetrics()); &#125;&#125; PointIndicator（圆点指示器）根据ViewPager滑动的位置和百分比，动态绘制指示小圆点。通过Viewpger滑动过程中的enterPosition和leavePosition以及滑动百分比percent来计算出滑动小圆点的左边位置即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/** * 圆点指示器 */public class PointIndicator extends View implements OnPageScrollListener &#123; private Context mContext; private int mNormalColor; private int mSelectColor; private int mPointSize; private int mPointSpace; private Paint mNormalPaint; private Paint mSelectPaint; private int mCount; private int enterPosition; private int leavePosition; private float percent; public PointIndicator(Context context) &#123; this(context, null); &#125; public PointIndicator(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public PointIndicator(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initAttrs(context, attrs); initPaint(); &#125; private void initPaint() &#123; mNormalPaint = new Paint(); mNormalPaint.setColor(mNormalColor); mNormalPaint.setAntiAlias(true); mSelectPaint = new Paint(); mSelectPaint.setColor(mSelectColor); mSelectPaint.setAntiAlias(true); mCount = 4; &#125; private void initAttrs(Context context, AttributeSet attrs) &#123; mContext = context; mNormalColor = 0x66cccccc; mSelectColor = 0xfffdd63b; mPointSize = dp2px(3f); mPointSpace = dp2px(3f); // 自定义属性 TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.PointIndicator); mNormalColor = ta.getColor(R.styleable.PointIndicator_normal_color, mNormalColor); mSelectColor = ta.getColor(R.styleable.PointIndicator_select_color, mSelectColor); mPointSize = (int) ta.getDimension(R.styleable.PointIndicator_point_size, mPointSize); mPointSpace = (int) ta.getDimension(R.styleable.PointIndicator_point_space, mPointSpace); ta.recycle(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec)); &#125; private int measureWidth(int measureSpec) &#123; int size = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.EXACTLY: size = specSize; break; case MeasureSpec.AT_MOST: case MeasureSpec.UNSPECIFIED: size = mCount * mPointSize + (mCount - 1) * mPointSpace; break; &#125; return size; &#125; private int measureHeight(int measureSpec) &#123; int size = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.EXACTLY: size = specSize; break; case MeasureSpec.AT_MOST: case MeasureSpec.UNSPECIFIED: size = mPointSize; break; &#125; return size; &#125; @Override protected void onDraw(Canvas canvas) &#123; // 绘制normalPoint drawNormalPoint(canvas); // 绘制selectPoint drawSelectPoint(canvas); &#125; private void drawSelectPoint(Canvas canvas) &#123; float cx; if (enterPosition &gt; leavePosition) &#123; cx = (leavePosition + 0.5f) * mPointSize + leavePosition * mPointSpace + (mPointSize + mPointSpace) * percent; &#125; else &#123; cx = (leavePosition + 0.5f) * mPointSize + leavePosition * mPointSpace - (mPointSize + mPointSpace) * percent; &#125; float cy = getHeight() / 2; float radius = mPointSize / 2f; canvas.drawCircle(cx, cy, radius, mSelectPaint); &#125; private void drawNormalPoint(Canvas canvas) &#123; for (int i = 0; i &lt; mCount; i++) &#123; float cx = mPointSize / 2f + (mPointSize + mPointSpace) * i; float cy = getHeight() / 2; float radius = mPointSize / 2f; canvas.drawCircle(cx, cy, radius, mNormalPaint); &#125; &#125; public void bindViewPager(ViewPager viewPager) &#123; if (viewPager != null) &#123; if (viewPager.getAdapter() != null) &#123; mCount = viewPager.getAdapter().getCount(); new ViewPagerHelper().bindScrollListener(viewPager, this); requestLayout(); // 绑定ViewPager后指示器重新布局，因为指示器的数量和宽度可能有变化 &#125; &#125; &#125; @Override public void onPageScroll(int enterPosition, int leavePosition, float percent) &#123; this.enterPosition = enterPosition; this.leavePosition = leavePosition; this.percent = percent; postInvalidate(); &#125; @Override public void onPageSelected(int position) &#123; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; private int dp2px(float dpValue) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, mContext.getResources().getDisplayMetrics()); &#125;&#125; 涉及到的自定义属性：12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;NumberIndicater&quot;&gt; &lt;attr name=&quot;circle_color&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;circle_size&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;number_size&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;number_color&quot; format=&quot;color&quot;/&gt; &lt;/declare-styleable&gt; &lt;declare-styleable name=&quot;PointIndicator&quot;&gt; &lt;attr name=&quot;point_size&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;point_space&quot; format=&quot;dimension&quot;/&gt; &lt;attr name=&quot;normal_color&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;select_color&quot; format=&quot;color&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 以上两种指示器都是通过自绘View的方式来实现。通过自定义的OnPageScrollListener还可以实现更多效果炫酷的指示器。 源码：https://github.com/xiaoyanger0825/Indicator]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给ViewPager添加一个自定义的滚动监听器]]></title>
    <url>%2F2017%2F01%2F09%2F%E7%BB%99ViewPager%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%BB%9A%E5%8A%A8%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[ViewPager是在日常开发业务中使用较多的，通常我们都会使用OnPagerChangeListener来监听ViewPager页面的滚动和状态变化：12345678910111213141516171819202122mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; // 页面正在滚动时不断调用 Log.d(&quot;ViewPager&quot;, &quot;onPageScrolled————&gt;&quot; + &quot; position：&quot; + position + &quot; positionOffest：&quot; + positionOffset + &quot; positionOffsetPixels：&quot; + positionOffsetPixels); &#125; @Override public void onPageSelected(int position) &#123; // 页面选中时调用 Log.d(&quot;ViewPager&quot;, &quot;onPagerSelected————&gt; position：&quot; +position); &#125; @Override public void onPageScrollStateChanged(int state) &#123; // 页面的滚动状态变化时调用 Log.d(&quot;ViewPager&quot;, &quot;onPageScrollStateChanged————&gt; state：&quot; + state); &#125;&#125;); 在onPageScrolled方法中：position：在滑动过程中，有可能是你当前页面位置，也有可能是你要滑动到的下一个页面位置；positionOffset：页面位置的偏移量，值为0到1之间。页面从右向左滑出时，值从0逐渐变为1并且在趋近1的时候突变为0。页面从左向右滑出时，值从1逐渐变为0；positionOffsetPixels：页面滑动的像素值，从右向左滑动时，该值逐渐变大，从左向右滑动时，逐渐变小。 从第0页滑动到第1页onPageScrolled调用：从第1页滑动到第2页onPageScrolled调用：从第2页滑动回到第1页onPageScrolled调用：从第1页滑动回到第0页onPageScrolled调用：通常情况下，这个监听器中的三个回调方法已经完全能够满足我们的业务需要。但是因为第一个参数position在滑动过程中不是很明确的表示是当前页面位置还是下一个页面的位置，我们还需要通过positionOffset或者positionOffsetPixels来判断。 因此我们通过OnPageChangedListener来封装一个自定义的滚动监听器，使用这个自定义的滚动监听器，在页面滑动时，可以很明确的回调进入的页面，离开的页面，以及滑动百分比、状态和最后选中的页面。 1.定义滚动监听接口123456789101112131415161718192021222324252627/** * ViewPage的页面滚动监听器 */public interface OnPageScrollListener &#123; /** * 页面滚动时调用 * * @param enterPosition 进入页面的位置 * @param leavePosition 离开的页面的位置 * @param percent 滑动百分比 */ void onPageScroll(int enterPosition, int leavePosition, float percent); /** * 页面选中时调用 * * @param position 选中页面的位置 */ void onPageSelected(int position); /** * 页面滚动状态变化时调用 * * @param state 页面的滚动状态 */ void onPageScrollStateChanged(int state);&#125; 2.在ViewPagerHelper中来实现滑动时页面位置、百分比的回调123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * ViewPager辅助类 */public class ViewPagerHelper &#123; private double mLastPositionOffsetSum; // 上一次滑动总的偏移量 private OnPageScrollListener mOnPageScrollListener; public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; // 当前总的偏移量 float currentPositionOffsetSum = position + positionOffset; // 上次滑动的总偏移量大于此次滑动的总偏移量，页面从右向左进入(手指从右向左滑动) boolean rightToLeft = mLastPositionOffsetSum &lt;= currentPositionOffsetSum; if (currentPositionOffsetSum == mLastPositionOffsetSum) return; int enterPosition; int leavePosition; float percent; if (rightToLeft) &#123; // 从右向左滑 enterPosition = (positionOffset == 0.0f) ? position : position + 1; leavePosition = enterPosition - 1; percent = (positionOffset == 0.0f) ? 1.0f : positionOffset; &#125; else &#123; // 从左向右滑 enterPosition = position; leavePosition = position + 1; percent = 1 - positionOffset; &#125; if (mOnPageScrollListener != null) &#123; mOnPageScrollListener.onPageScroll(enterPosition, leavePosition, percent); &#125; mLastPositionOffsetSum = currentPositionOffsetSum; &#125; public void onPageSelected(int position) &#123; if (mOnPageScrollListener != null) &#123; mOnPageScrollListener.onPageSelected(position); &#125; &#125; /** * @param state 当前滑动状态 * ViewPager.SCROLL_STATE_IDLE 页面处于闲置、稳定状态，即没被拖动也没惯性滑动 * ViewPager.SCROLL_STATE_DRAGGING 页面正在被用户拖动，即手指正在拖动状态 * Viewpager.SCROLL_STATE_SETTLING 页面处于即将到达最终状态的过程，即手指松开后惯性滑动状态 */ public void onPageScrollStateChanged(int state) &#123; if (mOnPageScrollListener != null) &#123; mOnPageScrollListener.onPageScrollStateChanged(state); &#125; &#125; public void setOnPageScrollListener(OnPageScrollListener onPageScrollListener) &#123; mOnPageScrollListener = onPageScrollListener; &#125;&#125; 3.采用工具类ViewPagerUtil来绑定ViewPager和OnPageScrollListener1234567891011121314151617181920212223242526272829303132/** * ViewPager工具类 */public class ViewPagerUtil &#123; /** * 给ViewPager绑定自定义的滚动监听 * * @param viewPager * @param onPageScrollListener */ public static void bind(@NonNull ViewPager viewPager, @NonNull OnPageScrollListener onPageScrollListener) &#123; final ViewPagerHelper helper = new ViewPagerHelper(); // 给helper设置滚动监听 helper.setOnPageScrollListener(onPageScrollListener); viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; helper.onPageScrolled(position, positionOffset, positionOffsetPixels); &#125; @Override public void onPageSelected(int position) &#123; helper.onPageSelected(position); &#125; @Override public void onPageScrollStateChanged(int state) &#123; helper.onPageScrollStateChanged(state); &#125; &#125;); &#125;&#125; 4.调用工具类方法实现绑定12345678910111213141516171819ViewPagerUtil.bind(mViewPager, new OnPageScrollListener() &#123; @Override public void onPageScroll(int enterPosition, int leavePosition, float percent) &#123; Log.d(&quot;ViewPager&quot;, &quot;onPageScrolled————&gt;&quot; + &quot; 进入页面：&quot; + enterPosition + &quot; 离开页面：&quot; + leavePosition + &quot; 滑动百分比：&quot; + percent); &#125; @Override public void onPageSelected(int position) &#123; Log.d(&quot;ViewPager&quot;, &quot;onPageSelected————&gt; position：&quot; + position); &#125; @Override public void onPageScrollStateChanged(int state) &#123; Log.d(&quot;ViewPager&quot;, &quot;onPageScrollStateChanged————&gt; state：&quot; + state); &#125;&#125;); 运行结果：从第0页滑动到第1页onPageScroll调用：从第1页滑动到第2页onPageScroll调用：从第2页滑动到第1页onPageScroll调用：从第1页滑动到第0页onPageScroll调用： 通过封装过后的OnPageScrollListener，可以很方便的定义各种样式的ViewPager指示器。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
</search>
