<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="喜欢NBA的Android码农">
<meta property="og:type" content="website">
<meta property="og:title" content="小样儿">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="小样儿">
<meta property="og:description" content="喜欢NBA的Android码农">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小样儿">
<meta name="twitter:description" content="喜欢NBA的Android码农">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>小样儿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小样儿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/03/React-Native-——-Component（组件）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/03/React-Native-——-Component（组件）/" itemprop="url">React Native —— Component（组件）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T21:44:36+08:00">
                2017-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React-Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>React利用JSX语法将html标签封装成组件的形式，来插入到DOM中，可以很方便的构建出网页UI。在React Native中，组件仍是其最核心的东西，各个界面UI都是通过基础组件的拼装来实现的。</p>
<h5 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h5><p>React 的核心机制就是创建虚拟DOM，在虚拟DOM与实际DOM之间通过强大的Diff算法来减少对实际DOM的渲染操作以提升性能。虚拟DOM可以用原生的JS来创建，但是这样的方式让代码的可读性不够友好，Facebook就利用大家熟悉的XML语法结合JS创造了JSX语法。JSX既是原生的JS，又能直观易懂的展示这些语意化的组件。</p>
<p>使用JSX语法定义组件V：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &quot;react&quot;;</span><br><span class="line">import &#123;Alert, StyleSheet, Text, View&#125; from &quot;react-native&quot;;</span><br><span class="line">export default class V extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.visite&#125; onPress=&#123;() =&gt; this.press()&#125;&gt;访问&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    press = () =&gt; &#123;</span><br><span class="line">        Alert.alert(&quot;标题&quot;, &quot;内容&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">        flex: 1,</span><br><span class="line">        justifyContent: &apos;center&apos;,</span><br><span class="line">        alignItems: &apos;center&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    visite: &#123;</span><br><span class="line">        width: 40,</span><br><span class="line">        height: 40,</span><br><span class="line">        backgroundColor: &apos;#00ff00&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在组件的JS文件中，可以直接使用ES6语法，组件的层次结构都是在render方法中采用JSX语法来定义，可以将JSX语法看做是JS和XML混写的语法，当遇到&lt;，JSX就当HTML解析，遇到{就当JS解析。</p>
<h5 id="props（属性）"><a href="#props（属性）" class="headerlink" title="props（属性）"></a>props（属性）</h5><p>UI的各种展示效果，需要用到它的属性<code>props</code>。大多数的组件在定义的时候就可以使用各种参数来定制，这些参数就是组件的属性<code>props</code>。<code>props</code>中的某个属性的值通常是在父组件中指定，而且一经指定，一般都不会再改变，除非父组件去重新指定它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &quot;react&quot;;</span><br><span class="line">import &#123;Text, View&#125; from &quot;react-native&quot;;</span><br><span class="line">class C extends Component &#123;</span><br><span class="line"></span><br><span class="line">    // 定义并初始化属性，es6写法</span><br><span class="line">    static defaultProps = &#123;name: &quot;Jack&quot;, age: 25&#125;;</span><br><span class="line">    static propTypes = &#123;name: React.PropTypes.string, age: React.PropTypes.number&#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Text&gt;&#123;this.props.name + &quot; &quot; + this.props.age + &quot; &quot; + this.props.sex&#125;&lt;/Text&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class V extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        let cName1 = &apos;Smith&apos;;</span><br><span class="line">        let cName2 = &apos;Mark&apos;;</span><br><span class="line">        let cAge1 = 30;</span><br><span class="line">        let cAge2 = 20;</span><br><span class="line">        let cSex1 = &apos;男&apos;;</span><br><span class="line">        let cSex2 = &apos;女&apos;;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;C name=&#123;cName1&#125; age=&#123;cAge1&#125; sex=&#123;cSex1&#125;/&gt;</span><br><span class="line">                &lt;C name=&#123;cName2&#125; age=&#123;cAge2&#125; sex=&#123;cSex2&#125;/&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，组件<code>C</code>中定义了两个默认的属性<code>name</code>和<code>age</code>，并给定了类型和初始值。在组件<code>V</code>中，引用了组件<code>C</code>，因此组件<code>V</code>为组件<code>C</code>的父组件。父组件<code>V</code>给组件<code>C</code>的<code>name</code>和<code>age</code>属性指定新的属性值，同时新增了一个<code>sex</code>的属性并给定属性值。那么在组件<code>C</code>中是不能改变组件<code>V</code>给它指定的<code>name</code>、<code>age</code>和<code>sex</code>的值。</p>
<h5 id="state（状态）"><a href="#state（状态）" class="headerlink" title="state（状态）"></a>state（状态）</h5><p>如果需要改变组件的参数来实现交互，需要用到它的状态<code>state</code>。通常在组件的构造函数中初始化<code>state</code>，在需要修改的时候调用<code>setState()</code>方法。</p>
<p>举一个例子，一段文本点击后改变它的背景，那么我们将<code>bgColor</code>定义为组件V3的状态，在<code>constructor</code>函数中初始化，点击后改变该状态的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &quot;react&quot;;</span><br><span class="line">import &#123;Text, View&#125; from &quot;react-native&quot;;</span><br><span class="line">export default class V3 extends Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;bgColor: &quot;#ffffff&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;&#123;</span><br><span class="line">                backgroundColor: this.state.bgColor,</span><br><span class="line">                height: 30,</span><br><span class="line">                justifyContent: &apos;center&apos;,</span><br><span class="line">                alignItems: &apos;center&apos;</span><br><span class="line">            &#125;&#125;&gt;</span><br><span class="line">                &lt;Text onPress=&#123;() =&gt; this.press()&#125;&gt;点击改变背景颜色&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    press = () =&gt; &#123;</span><br><span class="line">        if (this.state.bgColor === &quot;#ffffff&quot;) &#123;</span><br><span class="line">            this.setState(&#123;bgColor: &quot;#00ff00&quot;&#125;);</span><br><span class="line">        &#125; else if (this.state.bgColor === &quot;#00ff00&quot;) &#123;</span><br><span class="line">            this.setState(&#123;bgColor: &quot;#ff00ff&quot;&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.setState(&#123;bgColor: &quot;#ffffff&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h5><p><img src="http://upload-images.jianshu.io/upload_images/1801191-0d5b3a2f70ca7219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组件生命周期"></p>
<p>上流程图描述了组件从创建、运行到销毁的整个过程，可以看到如果一个组件在被创建，从开始一直到运行会依次调用<code>getDefaultProps</code>到<code>render</code>这五个函数；在运行过程中，如果有属性和状态的改变，又会触发左侧的其他函数的调用，并在此回到运行状态；当组件即将会被销毁时，会调用函数<code>conponentWillUnmount</code>来通知组件，到最终组件销毁，生命周期结束。</p>
<ul>
<li><code>getDefaultProps</code> 获取默认属性，并初始化<code>props</code>;</li>
<li><code>getInitialState</code> 获取初始化的组件状态<code>state</code>；</li>
<li><code>componentWillMount</code> 组件将会被装载，在渲染<code>render</code>前调用；</li>
<li><code>componentWillReceiveProps</code> 如果接收到属性就会调用该方法，旧的属性仍然可以通过this.props来获取，也可以调用this.setState来更新组件的状态，这里更新状态是安全的，不会触发render。</li>
<li><code>shouldComponentUpdate</code> 决定是否更新组件；</li>
<li><code>componentWillUpdate</code> 如果组件的状态或者属性改变了，并且<code>shouldComponentUpdate</code>为<code>true</code>，就会调用侧方法准备更新组件；</li>
<li><code>render</code>渲染，即初次渲染和更新组件的方法；</li>
<li><code>componentDidUpdate</code> 组件更新完成后会调用此方法；</li>
<li><code>conponentWillUnmount</code> 当组件要销毁，即从界面移除时，就会调用此方法。</li>
</ul>
<p>在ES6中已经废除了<code>getDefaultProps</code>和<code>getInitialState</code>的方式，直接通过<code>this.props</code>和<code>this.state</code>来获取。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/01/React-Native-——-搭建开发环境、创建Hello-World/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/01/React-Native-——-搭建开发环境、创建Hello-World/" itemprop="url">React Native —— 搭建开发环境、创建Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-01T15:51:51+08:00">
                2017-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React-Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>React Native(简称RN)从诞生以来，就受到了广大开发者的追捧。相比于Native开发，RN开发更为灵活，而且支持跨平台（Android和iOS同时支持），也更方便热更新，最重要的是它基本上能够达到与Native App一样的渲染和体验效果。虽然RN目前还有许多功能不够完善，同时也存在一些兼容性问题，作为Native开发者，我们还是可以通过混合开发（RN+原生开发）的模式来规避这些坑，这样也能兼具RN和原生开发的共同优势。</p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>对于前端工程师来说，学习RN要容易得多，但是对于原生开发者来说，学习成本还是相对较大：</p>
<p>首先，你需要有一定的JavaScript基础，对于没有js基础的同学，想直接就从RN开始，那估计是相当痛苦的。<br>其次，React作为RN的核心，在开始学习RN之前，至少要对React相关的基础知识有所了解。</p>
<p>如果完全没有接触过前端，想学习RN的话，建议还是可以先学习一下html/css、js等基础知识，再开始React、RN的学习，这样可能前期花费的时间和精力比较多，但是后期就要轻松很多，不用在学习RN的中途还要去恶补一些前端的基础知识。</p>
<h5 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h5><p>因为我使用的是Windows系统，所以下面就介绍下如何在Windows系统下搭建RN开发环境。</p>
<p>参考<a href="http://reactnative.cn/docs/0.31/getting-started.html" target="_blank" rel="noopener">ReactNative中文网</a>，首先我们需要装Python2和Node，考虑到可能chocolatey国外网站可能访问较慢，我们就直接冲Python官网下载Python2，下载地址：<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-2968b33fa60ecb28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载Python2"></p>
<p> 选择2.7.13版本，注意不要选Python2以上的版本，目前RN还不支持。然后在Node.js中文网下载最新的Node.js的msi安装包，注意根据自己的系统位数选择。下载地址：<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a><br><img src="http://upload-images.jianshu.io/upload_images/1801191-d8f358a3a0816b15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载Node.js"></p>
<p>下载完成后直接安装，安装完成后建议设置npm镜像以加速后面的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure>
<p>安装Yarn、RN的命令行工具（react-native-cli），<a href="http://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a>是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn react-native-cli</span><br></pre></td></tr></table></figure>
<p>安装完yarn后也要设置镜像源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry https://registry.npm.taobao.org --global</span><br><span class="line">yarn config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure>
<h5 id="安装开发工具"><a href="#安装开发工具" class="headerlink" title="安装开发工具"></a>安装开发工具</h5><p>我是做安卓开发，已经有了AndroidStudio开发工具，AndroidStudio安装和android-sdk的配置我就不介绍了，需要注意的是android-sdk路径的环境变量ANDROID_HOME必须要配置，如果之前没有的需要加上。</p>
<p>RN的开发工具有很多，像是Atom、Sublime、WebStorm等前端开发工具都能进行RN的开发。由于笔者长期使用AndroidStudio，所以我就用WebStrom了，因为它们都是由JetBrains出品，操作界面、快捷键、插件都是一致的，不需要进行二次学习。</p>
<p>WebStrom下载地址：<a href="http://www.jetbrains.com/webstorm/download/" target="_blank" rel="noopener">http://www.jetbrains.com/webstorm/download/</a><br>下载安装后，只有30天的免费使用，需要破解的话，网上有很多方式。</p>
<h5 id="创建HelloWorld"><a href="#创建HelloWorld" class="headerlink" title="创建HelloWorld"></a>创建HelloWorld</h5><p>打开WebStorm，点击Create New Project创建一个新的RN工程：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-f148ea58e061cdd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>选择左侧的React Native标签，location选项为你的工程目录和工程名称HelloWorld，Node interpreter和React Native选项为默认的就行。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-59ceac02ec25d78c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>点击create后，就开始构建工程了，第一次构建过程中要去下载RN的依赖包，可能时间比较长，耐心等待。构建完成后，可以看到RN项目的工程目录结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-86d86cd2289a6a5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其中有几个比较关键的文件：</p>
<ul>
<li><em>-test-</em>，为测试文件，里面存放一些测试用的js文件。</li>
<li><em>android</em>，就是一个原生的android工程项目，可以用androidStudio打开进行原生开发。</li>
<li><em>ios</em>，就是一个原生的ios工程项目，可以用xcode打开进行原生开发。</li>
<li><em>node_module</em>，下载的依赖库都存放在里面，包括React和React Native，相当于* AndroidStudio的External Libraries。</li>
<li><em>package.json</em>，RN工程的远程依赖，通常是在根目录通过命令行<code>npm install xxxxxx --save</code>t添加一个库，添加完成后，会把依赖信息自动写在package.json里面，相当于AndroidStudio的build.gradle。</li>
<li><em>index.android.js</em>，这是android的React Native入口文件。</li>
<li><em>index.ios.js</em>，这是ios的React Native入口文件。</li>
</ul>
<p>点击WebStorm右上角的下拉按钮，选择Android：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-dae55b2666d62e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>界面上就会出现运行和调试按钮了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-c2ae4b190190b7fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>连接到真机，点击执行。执行的过程中会添加react和react-native的依赖。同时如果默认的gradle版本是你没有使用过的话，也会自动去下载，所以耐心等待。当然最好是在执行之前通过AdnroidStudio打开RN工程下的android项目，将gradle版本修改到本地已有的版本。</p>
<p>运行时，在真机上可能遇到白屏情况，需要开启悬浮窗权限。也极有可能会出现下图左边的错误，点击RELOAD后，又会出现右边的fix方案：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-c3c6760eea46d1cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一般的最有可能的还是最后一种情况，即是运行设备（真机或模拟器）与packager server没在同一个ip，就不能用localhost了。</p>
<p>摇一摇手机，出现对话框：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-88d5d14eaf16e016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>点击Dev Settings，进入设置界面，点击Debug server hoset &amp;port for device，弹出对话框，输入自己电脑所在的局域网的ip:8081</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-efcb8e0d4daf0ec7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>点击确定后，回到主界面，摇一摇手机，再次点击对话框中的reload，就运行成功了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-be057f4325f907ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>参考：<br><a href="http://reactnative.cn/docs/0.31/getting-started.html" target="_blank" rel="noopener">React Native 中文网</a><br><a href="http://www.jianshu.com/p/97692b1c451d" target="_blank" rel="noopener">从Android到React Native开发（一、入门）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/18/自定义实现MIUI的拖动视差效果（阻尼效果）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/18/自定义实现MIUI的拖动视差效果（阻尼效果）/" itemprop="url">自定义实现MIUI的拖动视差效果（阻尼效果）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-18T15:09:42+08:00">
                2017-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在MIUI上有一些界面在拖动的时候有一个视差效果：<br><img src="http://upload-images.jianshu.io/upload_images/1801191-5dc31f5d2ba3e20e.gif?imageMogr2/auto-orient/strip" alt=""><br>在可以滚动的视图中，内容滚动到顶部时继续下拉，整个视图就有一个竖直方向拉伸的视差效果。滚动到底部继续上拉，也有同样的效果。</p>
<p>滚动视图可能是<code>ScrollView</code>、<code>RecyclerView</code>，要实现这样的效果，需要自定义并拦截<code>Touch</code>事件，重新处理事件逻辑。</p>
<p>以<code>RecyclerView</code>为例，我们自定义一个<code>ParallaxRecyclerView</code>，复写<code>onInterceptTouchEvent</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onInterceptTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    int action = MotionEventCompat.getActionMasked(event);</span><br><span class="line">    if (isRestoring &amp;&amp; action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        isRestoring = false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isEnabled() || isRestoring || (!isScrollToTop() &amp;&amp; !isScrollToBottom())) &#123;</span><br><span class="line">        return super.onInterceptTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    switch (action) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            mActivePointerId = event.getPointerId(0);</span><br><span class="line">            isBeingDragged = false;</span><br><span class="line">            float initialMotionY = getMotionEventY(event);</span><br><span class="line">            if (initialMotionY == -1) &#123;</span><br><span class="line">                return super.onInterceptTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            mInitialMotionY = initialMotionY;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            if (mActivePointerId == MotionEvent.INVALID_POINTER_ID) &#123;</span><br><span class="line">                return super.onInterceptTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            final float y = getMotionEventY(event);</span><br><span class="line">            if (y == -1f) &#123;</span><br><span class="line">                return super.onInterceptTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            if (isScrollToTop() &amp;&amp; !isScrollToBottom()) &#123;</span><br><span class="line">                // 在顶部不在底部</span><br><span class="line">                float yDiff = y - mInitialMotionY;</span><br><span class="line">                if (yDiff &gt; mTouchSlop &amp;&amp; !isBeingDragged) &#123;</span><br><span class="line">                    isBeingDragged = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!isScrollToTop() &amp;&amp; isScrollToBottom()) &#123;</span><br><span class="line">                // 在底部不在顶部</span><br><span class="line">                float yDiff = mInitialMotionY - y;</span><br><span class="line">                if (yDiff &gt; mTouchSlop &amp;&amp; !isBeingDragged) &#123;</span><br><span class="line">                    isBeingDragged = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (isScrollToTop() &amp;&amp; isScrollToBottom()) &#123;</span><br><span class="line">                // 在底部也在顶部</span><br><span class="line">                float yDiff = y - mInitialMotionY;</span><br><span class="line">                if (Math.abs(yDiff) &gt; mTouchSlop &amp;&amp; !isBeingDragged) &#123;</span><br><span class="line">                    isBeingDragged = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 不在底部也不在顶部</span><br><span class="line">                return super.onInterceptTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case MotionEventCompat.ACTION_POINTER_UP:</span><br><span class="line">            onSecondaryPointerUp(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">        case MotionEvent.ACTION_CANCEL:</span><br><span class="line">            mActivePointerId = MotionEvent.INVALID_POINTER_ID;</span><br><span class="line">            isBeingDragged = false;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return isBeingDragged || super.onInterceptTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滚动RecyclerView到达顶部或者底部继续拖动时，需要拦截Touch事件。所以在<code>MotionEvent.ACTION_MOVE</code>时需要判断当前RecyclerView是否在顶部或者底部。需要注意的是，当RecyclerView中的item没有填充满整视图时，RecyclerView的状态既是在顶部也是在底部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean isScrollToTop() &#123;</span><br><span class="line">    return !ViewCompat.canScrollVertically(this, -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isScrollToBottom() &#123;</span><br><span class="line">    return !ViewCompat.canScrollVertically(this, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mActivePointerId</code>表示在多点触控是当前活动手指的id，<code>mInitialMotionY</code>为手指按下时的Y坐标。</p>
<p>当达到顶部或底部继续拖动时，根据当前的位置（<code>isScrollToTop()</code>、<code>isScrollToBottom()</code>）和<code>ACTION_MOVE</code>时的移动距离<code>yDiff</code>来判断是否需要拦截：在顶部时向上拖动并且<code>yDiff&gt;mTouchSlop</code>就需要拦截，底部时向下拖动同样<code>yDiff&gt;mTouchSlop</code>也需要拦截，同时在顶部和底部时满足<code>Math.abs(yDiff)&gt;mTouchSlop</code>也需要拦截。需要拦截都是在没有被拖动（<code>!isBeingDragged</code>）的情况下。</p>
<p><code>RecyclerViev</code>既没有在顶部也没有在底部时，说明item滚动到中间，可以上下继续滚动，不需要拦截，交给<code>super.onInterceptTouchEvent(event)</code>来处理。同时其它不需要拦截的情况也都交给<code>super</code>来处理。</p>
<p><code>onSecondaryPointerUp(event)</code>为当第二个手指离开屏幕是需要重新设置<code>mActivePointerId</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void onSecondaryPointerUp(MotionEvent event) &#123;</span><br><span class="line">    final int pointerIndex = MotionEventCompat.getActionIndex(event);</span><br><span class="line">    final int pointerId = event.getPointerId(pointerIndex);</span><br><span class="line">    if (pointerId == mActivePointerId) &#123;</span><br><span class="line">        int newPointerIndex = pointerIndex == 0 ? 1 : 0;</span><br><span class="line">        mActivePointerId = event.getPointerId(newPointerIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拦截到TouchEvent，在onTouchEven中处理，实现拖动视差效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    switch (MotionEventCompat.getActionMasked(event)) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            mActivePointerId = event.getPointerId(0);</span><br><span class="line">            isBeingDragged = false;</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_MOVE: &#123; </span><br><span class="line">            float y = getMotionEventY(event);</span><br><span class="line">            if (isScrollToTop() &amp;&amp; !isScrollToBottom()) &#123;</span><br><span class="line">                // 在顶部不在底部</span><br><span class="line">                mDistance = y - mInitialMotionY;</span><br><span class="line">                if (mDistance &lt; 0) &#123;</span><br><span class="line">                    return super.onTouchEvent(event);</span><br><span class="line">                &#125;</span><br><span class="line">                mScale = calculateRate(mDistance);</span><br><span class="line">                pull(mScale);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (!isScrollToTop() &amp;&amp; isScrollToBottom()) &#123;</span><br><span class="line">                // 在底部不在顶部</span><br><span class="line">                mDistance = mInitialMotionY - y;</span><br><span class="line">                if (mDistance &lt; 0) &#123;</span><br><span class="line">                    return super.onTouchEvent(event);</span><br><span class="line">                &#125;</span><br><span class="line">                mScale = calculateRate(mDistance);</span><br><span class="line">                push(mScale);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (isScrollToTop() &amp;&amp; isScrollToBottom()) &#123;</span><br><span class="line">                // 在底部也在顶部</span><br><span class="line">                mDistance = y - mInitialMotionY;</span><br><span class="line">                if (mDistance &gt; 0) &#123;</span><br><span class="line">                    mScale = calculateRate(mDistance);</span><br><span class="line">                    pull(mScale);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mScale = calculateRate(-mDistance);</span><br><span class="line">                    push(mScale);</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 不在底部也不在顶部</span><br><span class="line">                return super.onTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        case MotionEventCompat.ACTION_POINTER_DOWN:</span><br><span class="line">            mActivePointerId = event.getPointerId(MotionEventCompat.getActionIndex(event));</span><br><span class="line">            break;</span><br><span class="line">        case MotionEventCompat.ACTION_POINTER_UP:</span><br><span class="line">            onSecondaryPointerUp(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP: </span><br><span class="line">        case MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">            if (isScrollToTop() &amp;&amp; !isScrollToBottom()) &#123;</span><br><span class="line">                animateRestore(true);</span><br><span class="line">            &#125; else if (!isScrollToTop() &amp;&amp; isScrollToBottom()) &#123;</span><br><span class="line">                animateRestore(false);</span><br><span class="line">            &#125; else if (isScrollToTop() &amp;&amp; isScrollToBottom()) &#123;</span><br><span class="line">                if (mDistance &gt; 0) &#123;</span><br><span class="line">                    animateRestore(true);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    animateRestore(false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return super.onTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码虽然有点长，但是逻辑很简单，在拦截到<code>ACTION_MOVE</code>事件后，同样根据顶部或底部位置以及滚动的距离<code>mDistance</code>来确定是否消费掉该事件。不需要消费的直接给<code>`super.onTouchEvent(event)</code>来处理，需要消费的话根据<code>mDistance</code>来计算出缩放的比例<code>mScale</code>，再通过<code>pull(mScale)</code>和<code>push(mScale)</code>来缩放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private float calculateRate(float distance) &#123;</span><br><span class="line">    int screenHeight = getResources().getDisplayMetrics().heightPixels;</span><br><span class="line">    float originalDragPercent = distance / screenHeight;</span><br><span class="line">    float dragPercent = Math.min(1f, originalDragPercent);</span><br><span class="line">    float rate = 2f * dragPercent - (float) Math.pow(dragPercent, 2f);</span><br><span class="line">    return 1 + rate / 5f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mScale</code>的计算是一个二次函数，当拖动距离越大时，<code>mScale</code>的变化程度越小，这样使得拖动时有一个张力效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void pull(float scale) &#123;</span><br><span class="line">    this.setPivotY(0);</span><br><span class="line">    this.setScaleY(scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void push(float scale) &#123;</span><br><span class="line">    this.setPivotY(this.getHeight());</span><br><span class="line">    this.setScaleY(scale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ACTION_UP</code>时，需要将缩放的视图通过动画还原到初始状态。这里也需要判断位置，因为不同位置的的缩放中心点不一样。同时即在顶部也在底部时是根<code>mDistance</code>的正负值来判断拖动的方向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void animateRestore(final boolean isPullRestore) &#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(mScale, 1f);</span><br><span class="line">    animator.setDuration(300);</span><br><span class="line">    animator.setInterpolator(new DecelerateInterpolator(2f));</span><br><span class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">            float value = (float) animation.getAnimatedValue();</span><br><span class="line">            if (isPullRestore) &#123;</span><br><span class="line">                pull(value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.addListener(new Animator.AnimatorListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationStart(Animator animation) &#123;</span><br><span class="line">            isRestoring = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">            isRestoring = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationCancel(Animator animation) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationRepeat(Animator animation) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就OK了，如果需要实现<code>ScrollView</code>、<code>ListView</code>、<code>GridView</code>也是一样的逻辑，<a href="https://github.com/xiaoyanger0825/Parallax" target="_blank" rel="noopener">源码</a>中已经有了<code>ParallaxScrollView</code>的实现，看下最终效果图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-b8a855ebdae2b7b2.gif?imageMogr2/auto-orient/strip" alt="ParallaxRecyclerView"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-0e390f65f8100c43.gif?imageMogr2/auto-orient/strip" alt="ParallaxScrollView"></p>
<p>源码：<a href="https://github.com/xiaoyanger0825/Parallax" target="_blank" rel="noopener">https://github.com/xiaoyanger0825/Parallax</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/22/用MediaPlayer-TextureView封装一个完美实现全屏、小窗口的视频播放器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/22/用MediaPlayer-TextureView封装一个完美实现全屏、小窗口的视频播放器/" itemprop="url">用MediaPlayer+TextureView封装一个完美实现全屏、小窗口的视频播放器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-22T15:58:55+08:00">
                2017-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>项目已添加IjkPlayer支持，后续逐渐完善其他功能。<br>地址：<a href="https://github.com/xiaoyanger0825/NiceVieoPlayer" target="_blank" rel="noopener">https://github.com/xiaoyanger0825/NiceVieoPlayer</a></p>
</blockquote>
<h3 id="为什么使用TextureView"><a href="#为什么使用TextureView" class="headerlink" title="为什么使用TextureView"></a>为什么使用TextureView</h3><p>在Android总播放视频可以直接使用<code>VideoView</code>，<code>VideoView</code>是通过继承自<code>SurfaceView</code>来实现的。<code>SurfaceView</code>的大概原理就是在现有<code>View</code>的位置上创建一个新的<code>Window</code>，内容的显示和渲染都在新的<code>Window</code>中。这使得<code>SurfaceView</code>的绘制和刷新可以在单独的线程中进行，从而大大提高效率。但是呢，由于<code>SurfaceView</code>的内容没有显示在<code>View</code>中而是显示在新建的<code>Window</code>中， 使得<code>SurfaceView</code>的显示不受<code>View</code>的属性控制，不能进行平移，缩放等变换，也不能放在其它<code>RecyclerView</code>或<code>ScrollView</code>中，一些<code>View</code>中的特性也无法使用。</p>
<p><code>TextureView</code>是在4.0(API level 14)引入的，与<code>SurfaceView</code>相比，它不会创建新的窗口来显示内容。它是将内容流直接投放到<code>View</code>中，并且可以和其它普通<code>View</code>一样进行移动，旋转，缩放，动画等变化。<code>TextureView</code>必须在硬件加速的窗口中使用。</p>
<p><code>TextureView</code>被创建后不能直接使用，必须要在它被它添加到<code>ViewGroup</code>后，待<code>SurfaceTexture</code>准备就绪才能起作用（看<code>TextureView</code>的源码，<code>TextureView</code>是在绘制的时候创建的内部<code>SurfaceTexture</code>）。通常需要给<code>TextureView</code>设置监听器<code>SurfaceTextuListener</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mTextureView.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) &#123;</span><br><span class="line">        // SurfaceTexture准备就绪</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) &#123;</span><br><span class="line">        // SurfaceTexture缓冲大小变化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) &#123;</span><br><span class="line">        // SurfaceTexture即将被销毁</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSurfaceTextureUpdated(SurfaceTexture surface) &#123;</span><br><span class="line">        // SurfaceTexture通过updateImage更新</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>SurfaceTexture</code>的准备就绪、大小变化、销毁、更新等状态变化时都会回调相对应的方法。当<code>TextureView</code>内部创建好<code>SurfaceTexture</code>后，在监听器的<code>onSurfaceTextureAvailable</code>方法中，用<code>SurfaceTexture</code>来关联<code>MediaPlayer</code>，作为播放视频的图像数据来源。</p>
<p><code>SurfaceTexture</code>作为数据通道，把从数据源（<code>MediaPlayer</code>）中获取到的图像帧数据转为GL外部纹理，交给<code>TextureVeiw</code>作为<code>View heirachy</code>中的一个硬件加速层来显示，从而实现视频播放功能。</p>
<h3 id="MediaPlayer介绍"><a href="#MediaPlayer介绍" class="headerlink" title="MediaPlayer介绍"></a>MediaPlayer介绍</h3><p><code>MediaPlayer</code>是Android原生的多媒体播放器，可以用它来实现本地或者在线音视频的播放，同时它支持<a href="https://developer.android.google.cn/guide/topics/media/media-formats.html" target="_blank" rel="noopener">https和rtsp</a>。</p>
<p><code>MediaPlayer</code>定义了各种状态，可以理解为是它的生命周期。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-e1f128fb472e97b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MediaPlayer状态图（生命周期）"></p>
<p>这个状态图描述了<code>MediaPlayer</code>的各种状态，以及主要方法调用后的状态变化。</p>
<p>MediaPlayer的相关方法及监听接口：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>setDataSource</td>
<td>设置数据源</td>
<td>Initialized</td>
<td></td>
</tr>
<tr>
<td>prepare</td>
<td>准备播放，同步</td>
<td>Preparing —&gt; Prepared</td>
<td></td>
</tr>
<tr>
<td>prepareAsync</td>
<td>准备播放，异步</td>
<td>Preparing —&gt; Prepared</td>
<td></td>
</tr>
<tr>
<td>start</td>
<td>开始或恢复播放</td>
<td>Started</td>
<td></td>
</tr>
<tr>
<td>pause</td>
<td>暂停</td>
<td>Paused</td>
<td></td>
</tr>
<tr>
<td>stop</td>
<td>停止</td>
<td>Stopped</td>
<td></td>
</tr>
<tr>
<td>seekTo</td>
<td>到指定时间点位置</td>
<td>PrePared/Started</td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>重置播放器</td>
<td>Idle</td>
<td></td>
</tr>
<tr>
<td>setAudioStreamType</td>
<td>设置音频流类型</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>setDisplay</td>
<td>设置播放视频的Surface</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>setVolume</td>
<td>设置声音</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>getBufferPercentage</td>
<td>获取缓冲半分比</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>getCurrentPosition</td>
<td>获取当前播放位置</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>getDuration</td>
<td>获取播放文件总时间</td>
<td>–</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>内部回调接口</th>
<th>介绍</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>OnPreparedListener</td>
<td>准备监听</td>
<td>Preparing ——&gt;Prepared</td>
<td></td>
</tr>
<tr>
<td>OnVideoSizeChangedListener</td>
<td>视频尺寸变化监听</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>OnInfoListener</td>
<td>指示信息和警告信息监听</td>
<td>–</td>
<td></td>
</tr>
<tr>
<td>OnCompletionListener</td>
<td>播放完成监听</td>
<td>PlaybackCompleted</td>
<td></td>
</tr>
<tr>
<td>OnErrorListener</td>
<td>播放错误监听</td>
<td>Error</td>
<td></td>
</tr>
<tr>
<td>OnBufferingUpdateListener</td>
<td>缓冲更新监听</td>
<td>–</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>MediaPlayer</code>在直接new出来之后就进入了Idle状态，此时可以调用多个重载的<code>setDataSource()</code>方法从idle状态进入Initialized状态（如果调用<code>setDataSource()</code>方法的时候，<code>MediaPlayer</code>对象不是出于Idle状态，会抛异常，可以调用<code>reset()</code>方法回到Idle状态）。</p>
<p>调用<code>prepared()</code>方法和<code>preparedAsync()</code>方法进入Prepared状态，prepared()方法直接进入Parpared状态，preparedAsync()方法会先进入PreParing状态，播放引擎准备完毕后会通过<code>OnPreparedListener.onPrepared()</code>回调方法通知Prepared状态。</p>
<p>在Prepared状态下就可以调用start()方法进行播放了，此时进入started()状态，如果播放的是网络资源，Started状态下也会自动调用客户端注册的<code>OnBufferingUpdateListener.OnBufferingUpdate()</code>回调方法，对流播放缓冲的状态进行追踪。</p>
<p><code>pause()</code>方法和<code>start()</code>方法是对应的，调用<code>pause()</code>方法会进入Paused状态，调用<code>start()</code>方法重新进入Started状态，继续播放。</p>
<p><code>stop()</code>方法会使<code>MdiaPlayer</code>从Started、Paused、Prepared、PlaybackCompleted等状态进入到Stoped状态，播放停止。</p>
<p>当资源播放完毕时，如果调用了<code>setLooping(boolean)</code>方法，会自动进入Started状态重新播放，如果没有调用则会自动调用客户端播放器注册的<code>OnCompletionListener.OnCompletion()</code>方法，此时<code>MediaPlayer</code>进入PlaybackCompleted状态，在此状态里可以调用<code>start()</code>方法重新进入Started状态。</p>
<h3 id="封装考虑"><a href="#封装考虑" class="headerlink" title="封装考虑"></a>封装考虑</h3><p><code>MediaPlayer</code>的方法和接口比较多，不同的状态调用各个方法后状态变化情况也比较复杂。播放相关的逻辑只与<code>MediaPlayer</code>的播放状态和调用方法相关，而界面展示和UI操作很多时候都需要根据自己项目来定制。参考原生的<code>VideoView</code>，为了解耦和方便定制，把<code>MediaPlayer</code>的播放逻辑和UI界面展示及操作相关的逻辑分离。我是把<code>MediaPlayer</code>直接封装到<code>NiceVideoPlayer</code>中，各种UI状态和操作反馈都封装到<code>NiceVideoPlayerController</code>里面。如果需要根据不同的项目需求来修改播放器的功能，就只重写<code>NiceVideoPlayerController</code>就可以了。</p>
<h3 id="NiceVideoPlayer"><a href="#NiceVideoPlayer" class="headerlink" title="NiceVideoPlayer"></a>NiceVideoPlayer</h3><p>首先，需要一个<code>FrameLayout</code>容器<code>mContainer</code>，里面有两层内容，第一层就是展示播放视频内容的<code>TextureView</code>，第二层就是播放器控制器<code>mController</code>。那么自定义一个<code>NiceVideoPlayer</code>继承自<code>FrameLayout</code>,将<code>mContainer</code>添加到当前控件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class NiceVideoPlayer extends FrameLayout&#123;</span><br><span class="line"></span><br><span class="line">    private Context mContext;</span><br><span class="line">    private NiceVideoController mController;</span><br><span class="line">    private FrameLayout mContainer;</span><br><span class="line">    </span><br><span class="line">    public NiceVideoPlayer(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NiceVideoPlayer(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        mContext = context;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">         mContainer = new FrameLayout(mContext);</span><br><span class="line">         mContainer.setBackgroundColor(Color.BLACK);</span><br><span class="line">         LayoutParams params = new LayoutParams(</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        this.addView(mContainer, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加<code>setUp</code>方法来配置播放的视频资源路径（本地/网络资源）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setUp(String url, Map&lt;String, String&gt; headers) &#123;</span><br><span class="line">        mUrl = url;</span><br><span class="line">        mHeaders = headers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用户要在<code>mController</code>中操作才能播放，因此需要在播放之前设置好<code>mController</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void setController(NiceVideoPlayerController controller) &#123;</span><br><span class="line">    mController = controller;</span><br><span class="line">    mController.setNiceVideoPlayer(this);</span><br><span class="line">    LayoutParams params = new LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">    mContainer.addView(mController, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户在自定义好自己的控制器后通过<code>setController</code>这个方法设置给播放器进行关联。</p>
<p>触发播放时，<code>NiceVideoPlayer</code>将展示视频图像内容的<code>mTextureView</code>添加到<code>mContainer</code>中（在<code>mController</code>的下层），同时初始化<code>mMediaPlayer</code>，待<code>mTextureView</code>的数据通道<code>SurfaceTexture</code>准备就绪后就可以打开播放器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">    initMediaPlayer();  // 初始化播放器</span><br><span class="line">    initTextureView();  // 初始化展示视频内容的TextureView</span><br><span class="line">    addTextureView();   // 将TextureView添加到容器中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initTextureView() &#123;</span><br><span class="line">    if (mTextureView == null) &#123;</span><br><span class="line">        mTextureView = new TextureView(mContext);</span><br><span class="line">        mTextureView.setSurfaceTextureListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void addTextureView() &#123;</span><br><span class="line">    mContainer.removeView(mTextureView);</span><br><span class="line">    LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">    mContainer.addView(mTextureView, 0,  params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initMediaPlayer() &#123;</span><br><span class="line">    if (mMediaPlayer == null) &#123;</span><br><span class="line">        mMediaPlayer = new MediaPlayer();</span><br><span class="line"></span><br><span class="line">        mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">        mMediaPlayer.setScreenOnWhilePlaying(true);</span><br><span class="line"></span><br><span class="line">        mMediaPlayer.setOnPreparedListener(mOnPreparedListener);</span><br><span class="line">        mMediaPlayer.setOnVideoSizeChangedListener(mOnVideoSizeChangedListener);</span><br><span class="line">        mMediaPlayer.setOnCompletionListener(mOnCompletionListener);</span><br><span class="line">        mMediaPlayer.setOnErrorListener(mOnErrorListener);</span><br><span class="line">        mMediaPlayer.setOnInfoListener(mOnInfoListener);</span><br><span class="line">        mMediaPlayer.setOnBufferingUpdateListener(mOnBufferingUpdateListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) &#123;</span><br><span class="line">    // surfaceTexture数据通道准备就绪，打开播放器</span><br><span class="line">    openMediaPlayer(surface);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void openMediaPlayer(SurfaceTexture surface) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        mMediaPlayer.setDataSource(mContext.getApplicationContext(), Uri.parse(mUrl), mHeaders);</span><br><span class="line">        mMediaPlayer.setSurface(new Surface(surface));</span><br><span class="line">        mMediaPlayer.prepareAsync();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onSurfaceTextureUpdated(SurfaceTexture surface) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开播放器调用<code>prepareAsync()</code>方法后，<code>mMediaPlayer</code>进入准备状态，准备就绪后就可以开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private MediaPlayer.OnPreparedListener mOnPreparedListener</span><br><span class="line">        = new MediaPlayer.OnPreparedListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPrepared(MediaPlayer mp) &#123;</span><br><span class="line">        mp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NiceVideoPlayer</code>的这些逻辑已经实现视频播放了，操作相关以及UI展示的逻辑需要在控制器<code>NiceVideoPlayerController</code>中来实现。但是呢，UI的展示和反馈都需要依据播放器当前的播放状态，所以需要给播放器定义一些常量来表示它的播放状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final int STATE_ERROR = -1;          // 播放错误</span><br><span class="line">public static final int STATE_IDLE = 0;            // 播放未开始</span><br><span class="line">public static final int STATE_PREPARING = 1;       // 播放准备中</span><br><span class="line">public static final int STATE_PREPARED = 2;        // 播放准备就绪</span><br><span class="line">public static final int STATE_PLAYING = 3;         // 正在播放</span><br><span class="line">public static final int STATE_PAUSED = 4;          // 暂停播放</span><br><span class="line">// 正在缓冲(播放器正在播放时，缓冲区数据不足，进行缓冲，缓冲区数据足够后恢复播放)</span><br><span class="line">public static final int STATE_BUFFERING_PLAYING = 5;</span><br><span class="line">// 正在缓冲(播放器正在播放时，缓冲区数据不足，进行缓冲，此时暂停播放器，继续缓冲，缓冲区数据足够后恢复暂停)</span><br><span class="line">public static final int STATE_BUFFERING_PAUSED = 6;</span><br><span class="line">public static final int STATE_COMPLETED = 7;       // 播放完成</span><br></pre></td></tr></table></figure>
<p>播放视频时，<code>mMediaPlayer</code>准备就绪(<code>Prepared</code>)后没有马上进入播放状态，中间有一个时间延迟时间段，然后开始渲染图像。所以将Prepared——&gt;“开始渲染”中间这个时间段定义为<code>STATE_PREPARED</code>。</p>
<p>如果是播放网络视频，在播放过程中，缓冲区数据不足时<code>mMediaPlayer</code>内部会停留在某一帧画面以进行缓冲。正在缓冲时，<code>mMediaPlayer</code>可能是在正在播放也可能是暂停状态，因为在缓冲时如果用户主动点击了暂停，就是处于<code>STATE_BUFFERING_PAUSED</code>，所以缓冲有<code>STATE_BUFFERING_PLAYING</code>和<code>STATE_BUFFERING_PAUSED</code>两种状态，缓冲结束后，恢复播放或暂停。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">private MediaPlayer.OnPreparedListener mOnPreparedListener</span><br><span class="line">        = new MediaPlayer.OnPreparedListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPrepared(MediaPlayer mp) &#123;</span><br><span class="line">        mp.start();</span><br><span class="line">        mCurrentState = STATE_PREPARED;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;onPrepared ——&gt; STATE_PREPARED&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private MediaPlayer.OnVideoSizeChangedListener mOnVideoSizeChangedListener</span><br><span class="line">        = new MediaPlayer.OnVideoSizeChangedListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onVideoSizeChanged(MediaPlayer mp, int width, int height) &#123;</span><br><span class="line">        LogUtil.d(&quot;onVideoSizeChanged ——&gt; width：&quot; + width + &quot;，height：&quot; + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private MediaPlayer.OnCompletionListener mOnCompletionListener</span><br><span class="line">        = new MediaPlayer.OnCompletionListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCompletion(MediaPlayer mp) &#123;</span><br><span class="line">        mCurrentState = STATE_COMPLETED;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;onCompletion ——&gt; STATE_COMPLETED&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private MediaPlayer.OnErrorListener mOnErrorListener</span><br><span class="line">        = new MediaPlayer.OnErrorListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onError(MediaPlayer mp, int what, int extra) &#123;</span><br><span class="line">        mCurrentState = STATE_ERROR;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;onError ——&gt; STATE_ERROR ———— what：&quot; + what);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private MediaPlayer.OnInfoListener mOnInfoListener</span><br><span class="line">        = new MediaPlayer.OnInfoListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInfo(MediaPlayer mp, int what, int extra) &#123;</span><br><span class="line">        if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) &#123;</span><br><span class="line">            // 播放器渲染第一帧</span><br><span class="line">            mCurrentState = STATE_PLAYING;</span><br><span class="line">            mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">            LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_VIDEO_RENDERING_START：STATE_PLAYING&quot;);</span><br><span class="line">        &#125; else if (what == MediaPlayer.MEDIA_INFO_BUFFERING_START) &#123;</span><br><span class="line">            // MediaPlayer暂时不播放，以缓冲更多的数据</span><br><span class="line">            if (mCurrentState == STATE_PAUSED || mCurrentState == STATE_BUFFERING_PAUSED) &#123;</span><br><span class="line">                mCurrentState = STATE_BUFFERING_PAUSED;</span><br><span class="line">                LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_BUFFERING_START：STATE_BUFFERING_PAUSED&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mCurrentState = STATE_BUFFERING_PLAYING;</span><br><span class="line">                LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_BUFFERING_START：STATE_BUFFERING_PLAYING&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        &#125; else if (what == MediaPlayer.MEDIA_INFO_BUFFERING_END) &#123;</span><br><span class="line">            // 填充缓冲区后，MediaPlayer恢复播放/暂停</span><br><span class="line">            if (mCurrentState == STATE_BUFFERING_PLAYING) &#123;</span><br><span class="line">                mCurrentState = STATE_PLAYING;</span><br><span class="line">                mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">                LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_BUFFERING_END： STATE_PLAYING&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mCurrentState == STATE_BUFFERING_PAUSED) &#123;</span><br><span class="line">                mCurrentState = STATE_PAUSED;</span><br><span class="line">                mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">                LogUtil.d(&quot;onInfo ——&gt; MEDIA_INFO_BUFFERING_END： STATE_PAUSED&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LogUtil.d(&quot;onInfo ——&gt; what：&quot; + what);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private MediaPlayer.OnBufferingUpdateListener mOnBufferingUpdateListener</span><br><span class="line">        = new MediaPlayer.OnBufferingUpdateListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onBufferingUpdate(MediaPlayer mp, int percent) &#123;</span><br><span class="line">        mBufferPercentage = percent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>mController.setControllerState(mPlayerState, mCurrentState)</code>，<code>mCurrentState</code>表示当前播放状态，<code>mPlayerState</code>表示播放器的全屏、小窗口，正常三种状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final int PLAYER_NORMAL = 10;        // 普通播放器</span><br><span class="line">public static final int PLAYER_FULL_SCREEN = 11;   // 全屏播放器</span><br><span class="line">public static final int PLAYER_TINY_WINDOW = 12;   // 小窗口播放器</span><br></pre></td></tr></table></figure>
<p>定义好播放状态后，开始暂停等操作逻辑也需要根据播放状态调整：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">    if (mCurrentState == STATE_IDLE</span><br><span class="line">            || mCurrentState == STATE_ERROR</span><br><span class="line">            || mCurrentState == STATE_COMPLETED) &#123;</span><br><span class="line">        initMediaPlayer();</span><br><span class="line">        initTextureView();</span><br><span class="line">        addTextureView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void restart() &#123;</span><br><span class="line">    if (mCurrentState == STATE_PAUSED) &#123;</span><br><span class="line">        mMediaPlayer.start();</span><br><span class="line">        mCurrentState = STATE_PLAYING;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;STATE_PLAYING&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mCurrentState == STATE_BUFFERING_PAUSED) &#123;</span><br><span class="line">        mMediaPlayer.start();</span><br><span class="line">        mCurrentState = STATE_BUFFERING_PLAYING;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;STATE_BUFFERING_PLAYING&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void pause() &#123;</span><br><span class="line">    if (mCurrentState == STATE_PLAYING) &#123;</span><br><span class="line">        mMediaPlayer.pause();</span><br><span class="line">        mCurrentState = STATE_PAUSED;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;STATE_PAUSED&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mCurrentState == STATE_BUFFERING_PLAYING) &#123;</span><br><span class="line">        mMediaPlayer.pause();</span><br><span class="line">        mCurrentState = STATE_BUFFERING_PAUSED;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;STATE_BUFFERING_PAUSED&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reStart()</code>方法是暂停时继续播放调用。</p>
<h3 id="全屏、小窗口播放的实现"><a href="#全屏、小窗口播放的实现" class="headerlink" title="全屏、小窗口播放的实现"></a>全屏、小窗口播放的实现</h3><p>可能最能想到实现全屏的方式就是把当前播放器的宽高给放大到屏幕大小，同时隐藏除播放器以外的其他所有UI，并设置成横屏模式。但是这种方式有很多问题，比如在列表（<code>ListView或RecyclerView</code>）中，除了放大隐藏外，还需要去计算滑动多少距离才刚好让播放器与屏幕边缘重合，退出全屏的时候还需要滑动到之前的位置，这样实现逻辑不但繁琐，而且和外部UI偶合严重，后面改动维护起来非常困难（我曾经就用这种方式被坑了无数道）。</p>
<p>分析能不能有其他更好的实现方式呢？</p>
<p>整个播放器由<code>mMediaPalyer</code>+<code>mTexutureView</code>+<code>mController</code>组成，要实现全屏或小窗口播放，我们只需要挪动播放器的展示界面<code>mTexutureView</code>和控制界面<code>mController</code>即可。并且呢我们在上面定义播放器时，已经把<code>mTexutureView</code>和<code>mController</code>一起添加到<code>mContainer</code>中了，所以只需要将<code>mContainer</code>从当前视图中移除，并添加到全屏和小窗口的目标视图中即可。</p>
<p>那么怎么确定全屏和小窗口的目标视图呢？</p>
<p>我们知道每个<code>Activity</code>里面都有一个<code>android.R.content</code>，它是一个<code>FrameLayout</code>，里面包含了我们<code>setContentView</code>的所有控件。既然它是一个<code>FrameLayout</code>，我们就可以将它作为全屏和小窗口的目标视图。</p>
<p>我们把从当前视图移除的<code>mContainer</code>重新添加到<code>android.R.content</code>中，并且设置成横屏。这个时候还需要注意<code>android.R.content</code>是不包括<code>ActionBar</code>和状态栏的，所以要将<code>Activity</code>设置成全屏模式，同时隐藏<code>ActionBar</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void enterFullScreen() &#123;</span><br><span class="line">    if (mPlayerState == PLAYER_FULL_SCREEN) return;</span><br><span class="line"></span><br><span class="line">    // 隐藏ActionBar、状态栏，并横屏</span><br><span class="line">    NiceUtil.hideActionBar(mContext);</span><br><span class="line">    NiceUtil.scanForActivity(mContext)</span><br><span class="line">            .setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</span><br><span class="line"></span><br><span class="line">    this.removeView(mContainer);</span><br><span class="line">    ViewGroup contentView = (ViewGroup) NiceUtil.scanForActivity(mContext)</span><br><span class="line">            .findViewById(android.R.id.content);</span><br><span class="line">    LayoutParams params = new LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">    contentView.addView(mContainer, params);</span><br><span class="line"></span><br><span class="line">    mPlayerState = PLAYER_FULL_SCREEN;</span><br><span class="line">    mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">    LogUtil.d(&quot;PLAYER_FULL_SCREEN&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退出全屏也就很简单了，将<code>mContainer</code>从<code>android.R.content</code>中移除，重新添加到当前视图，并恢复<code>ActionBar</code>、清除全屏模式就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean exitFullScreen() &#123;</span><br><span class="line">    if (mPlayerState == PLAYER_FULL_SCREEN) &#123;</span><br><span class="line">        NiceUtil.showActionBar(mContext);</span><br><span class="line">        NiceUtil.scanForActivity(mContext)</span><br><span class="line">                .setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line"></span><br><span class="line">        ViewGroup contentView = (ViewGroup) NiceUtil.scanForActivity(mContext)</span><br><span class="line">                .findViewById(android.R.id.content);</span><br><span class="line">        contentView.removeView(mContainer);</span><br><span class="line">        LayoutParams params = new LayoutParams(</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        this.addView(mContainer, params);</span><br><span class="line"></span><br><span class="line">        mPlayerState = PLAYER_NORMAL;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;PLAYER_NORMAL&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切换横竖屏时为了避免<code>Activity</code>重新走生命周期，别忘了需要在<code>Manifest.xml</code>的<code>activity</code>标签下添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</span><br></pre></td></tr></table></figure>
<p>进入小窗口播放和退出小窗口的实现原理就和全屏功能一样了，只需要修改它的宽高参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void enterTinyWindow() &#123;</span><br><span class="line">    if (mPlayerState == PLAYER_TINY_WINDOW) return;</span><br><span class="line"></span><br><span class="line">    this.removeView(mContainer);</span><br><span class="line"></span><br><span class="line">    ViewGroup contentView = (ViewGroup) NiceUtil.scanForActivity(mContext)</span><br><span class="line">            .findViewById(android.R.id.content);</span><br><span class="line">    // 小窗口的宽度为屏幕宽度的60%，长宽比默认为16:9，右边距、下边距为8dp。</span><br><span class="line">    FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(</span><br><span class="line">            (int) (NiceUtil.getScreenWidth(mContext) * 0.6f),</span><br><span class="line">            (int) (NiceUtil.getScreenWidth(mContext) * 0.6f * 9f / 16f));</span><br><span class="line">    params.gravity = Gravity.BOTTOM | Gravity.END;</span><br><span class="line">    params.rightMargin = NiceUtil.dp2px(mContext, 8f);</span><br><span class="line">    params.bottomMargin = NiceUtil.dp2px(mContext, 8f);</span><br><span class="line"></span><br><span class="line">    contentView.addView(mContainer, params);</span><br><span class="line"></span><br><span class="line">    mPlayerState = PLAYER_TINY_WINDOW;</span><br><span class="line">    mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">    LogUtil.d(&quot;PLAYER_TINY_WINDOW&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean exitTinyWindow() &#123;</span><br><span class="line">    if (mPlayerState == PLAYER_TINY_WINDOW) &#123;</span><br><span class="line">        ViewGroup contentView = (ViewGroup) NiceUtil.scanForActivity(mContext)</span><br><span class="line">                .findViewById(android.R.id.content);</span><br><span class="line">        contentView.removeView(mContainer);</span><br><span class="line">        LayoutParams params = new LayoutParams(</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        this.addView(mContainer, params);</span><br><span class="line"></span><br><span class="line">        mPlayerState = PLAYER_NORMAL;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;PLAYER_NORMAL&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个特别需要注意的一点：</p>
<p>当<code>mContainer</code>移除重新添加后，<code>mContainer</code>及其内部的<code>mTextureView</code>和<code>mController</code>都会重绘，<code>mTextureView</code>重绘后，会重新<code>new</code>一个<code>SurfaceTexture</code>，并重新回调<code>onSurfaceTextureAvailable</code>方法，这样<code>mTextureView</code>的数据通道<code>SurfaceTexture</code>发生了变化，但是<code>mMediaPlayer</code>还是持有原先的<code>mSurfaceTexut</code>，所以在切换全屏之前要保存之前的<code>mSufaceTexture</code>，当切换到全屏后重新调用<code>onSurfaceTextureAvailable</code>时，将之前的<code>mSufaceTexture</code>重新设置给<code>mTexutureView</code>。这样就保证了切换时视频播放的无缝衔接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int width, int height) &#123;</span><br><span class="line">    if (mSurfaceTexture == null) &#123;</span><br><span class="line">        mSurfaceTexture = surfaceTexture;</span><br><span class="line">        openMediaPlayer();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mTextureView.setSurfaceTexture(mSurfaceTexture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NiceVideoPlayerControl"><a href="#NiceVideoPlayerControl" class="headerlink" title="NiceVideoPlayerControl"></a>NiceVideoPlayerControl</h3><p>为了解除<code>NiceVideoPlayer</code>和<code>NiceVideoPlayerController</code>的耦合，把<code>NiceVideoPlayer</code>的一些功能性和判断性方法抽象到<code>NiceVideoPlayerControl</code>接口中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public interface NiceVideoPlayerControl &#123;</span><br><span class="line"></span><br><span class="line">    void start();</span><br><span class="line">    void restart();</span><br><span class="line">    void pause();</span><br><span class="line">    void seekTo(int pos);</span><br><span class="line"></span><br><span class="line">    boolean isIdle();</span><br><span class="line">    boolean isPreparing();</span><br><span class="line">    boolean isPrepared();</span><br><span class="line">    boolean isBufferingPlaying();</span><br><span class="line">    boolean isBufferingPaused();</span><br><span class="line">    boolean isPlaying();</span><br><span class="line">    boolean isPaused();</span><br><span class="line">    boolean isError();</span><br><span class="line">    boolean isCompleted();</span><br><span class="line"></span><br><span class="line">    boolean isFullScreen();</span><br><span class="line">    boolean isTinyWindow();</span><br><span class="line">    boolean isNormal();</span><br><span class="line"></span><br><span class="line">    int getDuration();</span><br><span class="line">    int getCurrentPosition();</span><br><span class="line">    int getBufferPercentage();</span><br><span class="line"></span><br><span class="line">    void enterFullScreen();</span><br><span class="line">    boolean exitFullScreen();</span><br><span class="line">    void enterTinyWindow();</span><br><span class="line">    boolean exitTinyWindow();</span><br><span class="line"></span><br><span class="line">    void release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NiceVideoPlayer</code>实现这个接口即可。</p>
<h3 id="NiceVideoPlayerManager"><a href="#NiceVideoPlayerManager" class="headerlink" title="NiceVideoPlayerManager"></a>NiceVideoPlayerManager</h3><p>同一界面上有多个视频，或者视频放在<code>ReclerView</code>或者<code>ListView</code>的容器中，要保证同一时刻只有一个视频在播放，其他的都是初始状态，所以需要一个<code>NiceVideoPlayerManager</code>来管理播放器，主要功能是保存当前已经开始了的播放器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class NiceVideoPlayerManager &#123;</span><br><span class="line"></span><br><span class="line">    private NiceVideoPlayer mVideoPlayer;</span><br><span class="line"></span><br><span class="line">    private NiceVideoPlayerManager() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static NiceVideoPlayerManager sInstance;</span><br><span class="line"></span><br><span class="line">    public static synchronized NiceVideoPlayerManager instance() &#123;</span><br><span class="line">        if (sInstance == null) &#123;</span><br><span class="line">            sInstance = new NiceVideoPlayerManager();</span><br><span class="line">        &#125;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentNiceVideoPlayer(NiceVideoPlayer videoPlayer) &#123;</span><br><span class="line">        mVideoPlayer = videoPlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void releaseNiceVideoPlayer() &#123;</span><br><span class="line">        if (mVideoPlayer != null) &#123;</span><br><span class="line">            mVideoPlayer.release();</span><br><span class="line">            mVideoPlayer = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean onBackPressd() &#123;</span><br><span class="line">        if (mVideoPlayer != null) &#123;</span><br><span class="line">            if (mVideoPlayer.isFullScreen()) &#123;</span><br><span class="line">                return mVideoPlayer.exitFullScreen();</span><br><span class="line">            &#125; else if (mVideoPlayer.isTinyWindow()) &#123;</span><br><span class="line">                return mVideoPlayer.exitTinyWindow();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mVideoPlayer.release();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用单例，同时，<code>onBackPressed</code>供<code>Activity</code>中用户按返回键时调用。<br><code>NiceVideoPlayer</code>的<code>start</code>方法以及<code>onCompleted</code>需要修改一下，保证开始播放一个视频时要先释放掉之前的播放器；同时自己播放完毕，要将<code>NiceVideoPlayerManager</code>中的<code>mNiceVideoPlayer</code>实例置空，避免内存泄露。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// NiceVideoPlayer的start()方法。</span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">    NiceVideoPlayerManager.instance().releaseNiceVideoPlayer();</span><br><span class="line">    NiceVideoPlayerManager.instance().setCurrentNiceVideoPlayer(this);</span><br><span class="line">    if (mCurrentState == STATE_IDLE</span><br><span class="line">            || mCurrentState == STATE_ERROR</span><br><span class="line">            || mCurrentState == STATE_COMPLETED) &#123;</span><br><span class="line">        initMediaPlayer();</span><br><span class="line">        initTextureView();</span><br><span class="line">        addTextureView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NiceVideoPlayer中的onCompleted监听。</span><br><span class="line">private MediaPlayer.OnCompletionListener mOnCompletionListener</span><br><span class="line">        = new MediaPlayer.OnCompletionListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCompletion(MediaPlayer mp) &#123;</span><br><span class="line">        mCurrentState = STATE_COMPLETED;</span><br><span class="line">        mController.setControllerState(mPlayerState, mCurrentState);</span><br><span class="line">        LogUtil.d(&quot;onCompletion ——&gt; STATE_COMPLETED&quot;);</span><br><span class="line">        NiceVideoPlayerManager.instance().setCurrentNiceVideoPlayer(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="NiceVideoPlayerController"><a href="#NiceVideoPlayerController" class="headerlink" title="NiceVideoPlayerController"></a>NiceVideoPlayerController</h3><p>播放控制界面上，播放、暂停、播放进度、缓冲动画、全屏/小屏等触发都是直接调用播放器对应的操作的。需要注意的就是调用之前要判断当前的播放状态，因为有些状态下调用播放器的操作可能引起错误（比如播放器还没准备就绪，就去获取当前的播放位置）。</p>
<p>播放器在触发相应功能的时候都会调用<code>NiceVideoPlayerController</code>的<code>setControllerState(int playerState, int playState)</code>这个方法来让用户修改UI。</p>
<p>不同项目都可能定制不同的控制器（播放操作界面），这里我就不详细分析实现逻辑了，大致功能就类似腾讯视频的热点列表中的播放器。其中横向滑动改变播放进度、左侧上下滑动改变亮度，右侧上下滑动改变亮度等功能在代码中都有实现。代码有点长，就不贴了，需要的直接<a href="https://github.com/xiaoyanger0825/NiceVieoPlayer" target="_blank" rel="noopener">下载源码</a>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mNiceVideoPlayer.setUp(url, null);</span><br><span class="line">NiceVideoPlayerController controller = new NiceVideoPlayerController(this);</span><br><span class="line">controller.setTitle(title);</span><br><span class="line">controller.setImage(imageUrl);</span><br><span class="line">mNiceVideoPlayer.setController(controller);</span><br></pre></td></tr></table></figure>
<p>在<code>RecyclerView</code>或者<code>ListView</code>中使用时，需要监听<code>itemView</code>的<code>detached</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.addOnChildAttachStateChangeListener(new RecyclerView.OnChildAttachStateChangeListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onChildViewAttachedToWindow(View view) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onChildViewDetachedFromWindow(View view) &#123;</span><br><span class="line">        NiceVideoPlayer niceVideoPlayer = (NiceVideoPlayer) view.findViewById(R.id.nice_video_player);</span><br><span class="line">        if (niceVideoPlayer != null) &#123;</span><br><span class="line">            niceVideoPlayer.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在<code>ItemView</code>detach窗口时，需要释放掉<code>itemView</code>内部的播放器。</p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://upload-images.jianshu.io/upload_images/1801191-3feb4d2d27177c31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-6133b64915dbe2df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-782821c245ca7d6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-2445334e4f124bed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>整个功能有参考<a href="https://github.com/lipangit/JieCaoVideoPlayer" target="_blank" rel="noopener">节操播放器</a>，但是自己这样封装和节操播放器还是有很大差异：一是分离了播放功能和控制界面，定制只需修改控制器即可。二是全屏/小窗口没有新建一个播放器，只是挪动了播放界面和控制器，不用每个视频都需要新建两个播放器，也不用同步状态。</p>
<hr>
<p><code>MediaPlayer</code>有很多格式不支持，项目已添加<code>IjkPlayer</code>的扩展支持，可以切换<code>IjkPlayer</code>和原生<code>MediaPlayer</code>，后续还会考虑添加<code>ExoPlayer</code>，同时也会扩展更多功能。</p>
<p>如果有错误和更好的建议都请提出，源码已上传<a href="https://github.com/xiaoyanger0825/NiceVieoPlayer" target="_blank" rel="noopener">GitHub</a>，欢迎Star，谢谢！。</p>
<p>源码：<a href="https://github.com/xiaoyanger0825/NiceVieoPlayer" target="_blank" rel="noopener">https://github.com/xiaoyanger0825/NiceVieoPlayer</a></p>
<hr>
<p>参考：<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1213/2153.html" target="_blank" rel="noopener">Android TextureView简易教程</a><br><a href="http://www.tuicool.com/articles/AVnaeam" target="_blank" rel="noopener">视频画面帧的展示控件SurfaceView及TextureView对比</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/44062175" target="_blank" rel="noopener">Android 5.0(Lollipop)中的SurfaceTexture，TextureView, SurfaceView和GLSurfaceView</a><br><a href="http://blog.csdn.net/junwang19891012/article/details/8444743" target="_blank" rel="noopener">Android MediaPlayer生命周期详解</a><br><a href="https://github.com/lipangit/JieCaoVideoPlayer" target="_blank" rel="noopener">节操播放器 https://github.com/lipangit/JieCaoVideoPlayer</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/11/EventBus封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/11/EventBus封装/" itemprop="url">EventBus封装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-11T14:59:48+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a>是一款针对Android优化的发布/订阅事件总线。可以替代广播、<code>startActivityForResult</code>、<code>Handler</code>、异步回调等来实现各组件间、组件与后台线程间的通信。它的优点是开销小，代码更优雅，以及将发送者和接收者解耦。</p>
<p>通常我们在使用<code>EventBus</code>的时候都是直接需要接收通信的<code>Activity/Fragment</code>中通过<code>EventBus.getDefault().register(this)</code>订阅事件，在需要发起通信的逻辑直接调用<code>EventBus.getDefault().post(Object event)</code>来发布事件。但是要是一个项目中有很多地方都使用<code>EventBus</code>来通信，比如重新登录后更新各个页面的登录状态，或者是接收到通知更新消息提示等，都这样直接使用的话代码重复率很高，并且呢，如果以后升级或者更换<code>EventBus</code>时，各个地方都要修改，这就比较麻烦了。因此我一般是将<code>EventBus</code>的发布和订阅封装到<code>BaseActivity/BaseFragment</code>中。</p>
<p>在Gradle中添加<code>EventBus</code>依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;org.greenrobot:eventbus:3.0.0&apos;</span><br></pre></td></tr></table></figure>
<p>封装一下<code>EventBus</code>的订阅、取消订阅、发布等方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class EventBusUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static void register(Object subscriber) &#123;</span><br><span class="line">        EventBus.getDefault().register(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void unregister(Object subscriber) &#123;</span><br><span class="line">        EventBus.getDefault().unregister(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sendEvent(Event event) &#123;</span><br><span class="line">        EventBus.getDefault().post(event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void sendStickyEvent(Event event) &#123;</span><br><span class="line">        EventBus.getDefault().postSticky(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其他</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>BaseActivity/BaseFragment</code>中的<code>onCreate</code>和<code>onDestroy</code>方法中订阅和取消订阅，这里添加了一个<code>isRegisterEventBus()</code>方法，默认返回<code>false</code>，即不订阅<code>EventBus</code>，子类<code>Activity/Fragment</code>如果需要订阅的话复写这个方法并返回<code>true</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    if (isRegisterEventBus()) &#123;</span><br><span class="line">        EventBusUtil.register(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否注册事件分发</span><br><span class="line"> *</span><br><span class="line"> * @return true绑定EventBus事件分发，默认不绑定，子类需要绑定的话复写此方法返回true.</span><br><span class="line"> */</span><br><span class="line">protected boolean isRegisterEventBus() &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    if (isRegisterEventBus()) &#123;</span><br><span class="line">        EventBusUtil.unregister(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义事件<code>Event</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Event&lt;T&gt; &#123;</span><br><span class="line">    private int code;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public Event(int code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Event(int code, T data) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(int code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过泛型<code>&lt;T&gt;</code>指定事件通信过程中的数据类型，<code>code</code>为事件码，使用的时候给不同的事件类型指定不同的<code>code</code>。</p>
<p>在<code>BaseActivity\BaseFragment</code>中添加接收到<code>EventBus</code>的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 是否注册事件分发</span><br><span class="line"> *</span><br><span class="line"> * @return true绑定EventBus事件分发，默认不绑定，子类需要绑定的话复写此方法返回true.</span><br><span class="line"> */</span><br><span class="line">protected boolean isRegisterEventBus() &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="line">public void onEventBusCome(Event event) &#123;</span><br><span class="line">    if (event != null) &#123;</span><br><span class="line">        receiveEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)</span><br><span class="line">public void onStickyEventBusCome(Event event) &#123;</span><br><span class="line">    if (event != null) &#123;</span><br><span class="line">        receiveStickyEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 接收到分发到事件</span><br><span class="line"> *</span><br><span class="line"> * @param event 事件</span><br><span class="line"> */</span><br><span class="line">protected void receiveEvent(Event event) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 接受到分发的粘性事件</span><br><span class="line"> *</span><br><span class="line"> * @param event 粘性事件</span><br><span class="line"> */</span><br><span class="line">protected void receiveStickyEvent(Event event) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据自己项目的需求，在订阅了<code>EventBus</code>的<code>Activity/Fragment</code>中复写<code>receiveEvent(Event event)</code>或<code>receiveStickyEvent(Event event)</code>来处理接收到事件后的逻辑。</p>
<p>这里也可以不用在<code>BaseActivty/BaseFragment</code>中添加接受事件的方法（因为添加了过后不能确定的子类的<code>Event</code>泛型）。那么就直接在订阅的<code>Activity/Fragment</code>中给接收事件的方法添加<code>EventBus</code>对应的事件接受注解，并指定参数Event的泛型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="line">public void onEventReceived(Event&lt;User&gt; event) &#123;</span><br><span class="line">    if (event != null &amp;&amp; event.getCode() == C.EventCode.C) &#123;</span><br><span class="line">        User user = event.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在给定<code>Event</code>的<code>code</code>的时候最好在常量池中定义一个类专门用来定义不同类型的<code>EventBus</code>的<code>code</code>，这样在接收到<code>EventBus</code>的地方可以根据这些<code>code</code>值来判断<code>Event</code>的来源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class C &#123;</span><br><span class="line">    // EventBus Code</span><br><span class="line">    public static final class EventCode &#123;</span><br><span class="line">        public static final int A = 0x111111;</span><br><span class="line">        public static final int B = 0x222222;</span><br><span class="line">        public static final int C = 0x333333;</span><br><span class="line">        public static final int D = 0x444444;</span><br><span class="line">        // other more</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例：<br>在<code>MainActivity</code>中复写<code>isRegisterEventBus()</code>并返回<code>true</code>注册<code>EventBus</code>，复写<code>receiveEvent(Event event)</code>接收发布的事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected boolean isRegisterEventBus() &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void receiveEvent(Event event) &#123;</span><br><span class="line">    // 接受到Event后的相关逻辑</span><br><span class="line">    switch (event.getCode()) &#123;</span><br><span class="line">        case C.EventCode.A:</span><br><span class="line">            Log.d(&quot;EventBus&quot;, &quot;接收到A类型的Event&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case C.EventCode.B:</span><br><span class="line">            Log.d(&quot;EventBus&quot;, &quot;接收到B类型的Event&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case C.EventCode.C:</span><br><span class="line">            Log.d(&quot;EventBus&quot;, &quot;接收到B类型的Event，携带User&quot;);</span><br><span class="line">            User user = (User) event.getData();</span><br><span class="line">            break;</span><br><span class="line">        case C.EventCode.D:</span><br><span class="line">            Log.d(&quot;EventBus&quot;, &quot;接收到D类型的Event，携带News&quot;);</span><br><span class="line">            News news = (News) event.getData();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>receiveEvent(Event event)</code>根据对应的事件的<code>code</code>，判断通信的数据来源和传递的数据类型，以完成对应的逻辑。</p>
<p>在<code>InfoActivity</code>中发送事件，<code>InfoActivity</code>只发送不需要接收<code>Event</code>的话就不注册，也不用复写<code>isRegisterEventBus()</code>和<code>receiveEvent(Event event)</code>方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void sendEventA(View view) &#123;</span><br><span class="line">    EventBusUtil.sendEvent(new Event(C.EventCode.A));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sendEventB(View view) &#123;</span><br><span class="line">    EventBusUtil.sendEvent(new Event(C.EventCode.B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sendEventC(View view) &#123;</span><br><span class="line">    Event&lt;User&gt; event = new Event&lt;&gt;(C.EventCode.C, new User());</span><br><span class="line">    EventBusUtil.sendEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sendEventD(View view) &#123;</span><br><span class="line">    Event&lt;News&gt; event = new Event&lt;&gt;(C.EventCode.D, new News());</span><br><span class="line">    EventBusUtil.sendEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的方式，将<code>EventBus</code>封装到<code>BaseActivity/BaseFragment</code>中，使得EventBus和项目解耦更加彻底，同时在需要使用的子Activity/Fragment中只需要复写<code>isRegisterEventBus()</code>和<code>receiveEvent(Event event)</code>即可，不用每个地方都去订阅和取消订阅。并且给<code>Event</code>给定<code>code</code>和泛型能够很好的区分不同的事件来源和数据类型。</p>
<hr>
<p>源码：<a href="https://github.com/xiaoyanger0825/EventBusExample" target="_blank" rel="noopener">https://github.com/xiaoyanger0825/EventBusExample</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/25/Android内存优化——内存泄露检测分析方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/25/Android内存优化——内存泄露检测分析方法/" itemprop="url">Android内存优化——内存泄露检测分析方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-25T10:55:21+08:00">
                2017-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇文章总结了一些<a href="http://www.jianshu.com/p/ab4a7e353076" target="_blank" rel="noopener">常见的内存泄露场景及优化方案</a>，这篇文章继续总结内存泄露的一些常用的检测和分析方法。</p>
<h6 id="Lint代码检查"><a href="#Lint代码检查" class="headerlink" title="Lint代码检查"></a>Lint代码检查</h6><p>AndroidStudio自动Lint代码检查工具，一些常见的代码警告Lint工具都会给我们提示。使用也比较简单：</p>
<p>Analyze —&gt; Inspect Code 然后选择检查范围：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-bc223bbbdf6ab2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lint使用-1"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-81edacec4a087dea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lint使用-2"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-1eb6b990be21eaf9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lint使用-3"></p>
<p>比如如果存在非静态内部类的Handler，可能会导致内存泄露，检查结果就会显示在AndroidStudio的控制台。</p>
<p>其实，只要我们在设置里面勾选了Lint代码检查（AnroidStudio默认是勾选了的），在写代码的时候就会自动提示可能发生内存泄露。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-99a98b44e3a0d66f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lint检查代码内存泄露"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-d27989516257bf48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lint提示内存泄露"></p>
<p>通常在写Handler、静态字段、标记对象等可能存在的内存泄露时，Lint检查工具都会有一个警告提示信息，我们可以根据Lint检查的提示信息来避免这些有可能发生的内存泄露。</p>
<h6 id="Android-Monitor"><a href="#Android-Monitor" class="headerlink" title="Android Monitor"></a>Android Monitor</h6><p>在AndroidStudio中，可以通过Monitors来监控Memory、CPU、Network、GPU等。在Monitors监控中，我们可以获取内存的各种信息来分析内存泄露。</p>
<p>首先运行工程后，打开控制台的Android Monitor：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-3de57143897ccbec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Monitor"></p>
<p>在运行设备中使用app（各个页面的跳转，使用相应的各种功能），就可以看到内存使用的不断变化：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-fc4b9fdcb361aabd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存使用变化"></p>
<p>淡蓝色和浅灰色区域就是内存分配的变化过程，浅灰色表示空闲内存，淡蓝色表示使用内存。</p>
<p>通常，我们在打开一个新的页面后，使用的内存就会增加，相应的，关闭一个页面后，系统执行了GC，使用的内存应该下降。如果我们在退出界面并执行GC后，内存使用并未下降明显，或者使用内存没有下降初始的使用大小，那么有可能就发生了内存泄露。</p>
<p>运行工程，在设备上操作app，观察Monitor中内存的变化，点击 initiate GC 触发GC，然后点击Dump Java Heap转出堆信息，稍等片刻，生成hprof文件，生成后会在Studio中自动打开。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-b56a5fd91ae3ff96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hprof文件"></p>
<p>点击右侧的Analyzer Tasks，再点击Perform Analyzer，展开下面分析结果<br>中的 Leaked Activities 就可以看到发生内存泄露的Activity了。<br><img src="http://upload-images.jianshu.io/upload_images/1801191-55e08f111e30a361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Monitor内存泄露分析"></p>
<p>可以根据左侧的引用树，来查找持有Activity引用的位置，从而判断出哪个地方导致了内存泄露。</p>
<h6 id="Mat"><a href="#Mat" class="headerlink" title="Mat"></a>Mat</h6><p>使用第三方的Mat工具来分析内存泄露，需要在<a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">官网下载</a>独立版的Mat。</p>
<p>将Android Monitor生成的hprof文件导出为标准的hprof文件（必须这样导出，直接copy出来会报错的）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-9712bf17dd12d5a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导出hprof文件"></p>
<p>使用Mat打开导出的hprof文件：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-98de246ca5bbe888.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mat打开hprof文件"></p>
<p>点击Histogram（直方图），可以看到类对应的实例数量的统计。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-f3b3adfbd89c6ee7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="直方图"></p>
<p>在Class Name下面输入需要匹配的类名，根据类来查看它的实例的引用，进而分析是否存在内存泄露。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-0fce4cddd18749e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类的实例"></p>
<p>可以看到TestActivity和MyHandler都只有一个实例被引用。</p>
<p>TestActivity点击右键—&gt;Merge Shortest Paths to GC Roots —&gt;exclude all phantom/weak/soft etc.references。</p>
<blockquote>
<p>Merge Shortest Paths to GC Roots 可以查看一个对象到RC  Roots是否存在引用链相连接， 在JAVA中是通过可达性（Reachability Analysis)来判断对象是否存活，这个算法的基本思想是通过一系列的称谓”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走得路径称为引用链，当一个对象到GC Roots没有任何引用链相连则该对象被判定为可以被回收的对象，反之不能被回收，我们可以选择 exclude all phantom/weak/soft etc.references(排查虚引用/弱引用/软引用等）因为被虚引用/弱引用/软引用的对象可以直接被GC给回收。</p>
</blockquote>
<p>参考自<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0309/2565.html" target="_blank" rel="noopener">Android 性能优化之使用MAT分析内存泄露问题</a>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-fef276943a7e358a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TestActivity实例 RC Roots引用链"></p>
<p>可以看到TestActivity实例存在GC Roots链，TextActivity实例被mMessageQueue.mMessae.target.this$0持有，那么发生了内存泄露，我们可以根据引用链来在代码中找到内存泄露的位置。</p>
<h6 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h6><p>LeakCanary是<a href="https://github.com/square" target="_blank" rel="noopener">square</a>开源的检测内存泄露的第三方库。它最大的有点就是开发者只需要添加简单代码，app在运行时如果发生了内存泄露，就会很直观的将内存泄露的详细信息展示在通知栏上，这样避免了Android Monitor或者Mat等工具的繁琐的分析过程。</p>
<p>项目地址：<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">https://github.com/square/leakcanary</a></p>
<p>在Gradle文件中添加依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5&apos;</span><br><span class="line">  releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos;</span><br><span class="line">  testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在入口的Application中进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class App extends Application &#123;</span><br><span class="line"></span><br><span class="line">    // 模拟内存泄露场景</span><br><span class="line">    public static ArrayList&lt;Activity&gt; sActivities = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        if (LeakCanary.isInAnalyzerProcess(this)) &#123;</span><br><span class="line">            // This process is dedicated to LeakCanary for heap analysis.</span><br><span class="line">            // You should not init your app in this process.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        LeakCanary.install(this);</span><br><span class="line">        // Normal app init code...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Application中新建一个静态List，里面存储Activity，来模拟内存泄露案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test);</span><br><span class="line">        App.sActivities.add(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void back(View view) &#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行app后，在控制台可以看到LeakCanary的日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">04-25 10:20:46.793 D/LeakCanary: In com.xiao.memoryleakexample:1.0:1.</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * com.xiao.memoryleakexample.TestActivity has leaked:</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * GC ROOT static com.xiao.memoryleakexample.app.App.sActivities</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * references java.util.ArrayList.array</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * references array java.lang.Object[].[0]</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * leaks com.xiao.memoryleakexample.TestActivity instance</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Retaining: 88 KB.</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Reference Key: 915bf11a-db9f-468e-8064-d6fb103710e9</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Device: OPPO OPPO OPPO R9 Plusm A R9PlusmA</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Android Version: 5.1.1 API: 22 LeakCanary: 1.5 00f37f5</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Durations: watch=5049ms, gc=207ms, heap dump=979ms, analysis=122889ms</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Details:</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Class com.xiao.memoryleakexample.app.App</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static $staticOverhead = byte[24]@314667009 (0x12c17001)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static sActivities = java.util.ArrayList@315492800 (0x12ce09c0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static serialVersionUID = -920324649544707127</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static $change = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Instance of java.util.ArrayList</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static $staticOverhead = byte[16]@1893824473 (0x70e177d9)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static MIN_CAPACITY_INCREMENT = 12</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static serialVersionUID = 8683452581122892189</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   array = java.lang.Object[12]@318048768 (0x12f50a00)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   size = 1</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   modCount = 1</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Array of java.lang.Object[]</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [0] = com.xiao.memoryleakexample.TestActivity@316091520 (0x12d72c80)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [1] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [2] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [3] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [4] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [5] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [6] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [7] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [8] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [9] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [10] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   [11] = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: * Instance of com.xiao.memoryleakexample.TestActivity</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static $staticOverhead = byte[16]@316125185 (0x12d7b001)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static serialVersionUID = 836998863274086997</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   static $change = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mHandler = com.xiao.memoryleakexample.TestActivity$MyHandler@318005952 (0x12f462c0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mDelegate = android.support.v7.app.AppCompatDelegateImplV14@314816320 (0x12c3b740)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mEatKeyUpEvent = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mResources = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mThemeId = 2131230884</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mCreated = true</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mFragments = android.support.v4.app.FragmentController@317876896 (0x12f26aa0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mHandler = android.support.v4.app.FragmentActivity$1@318005920 (0x12f462a0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mNextCandidateRequestIndex = 0</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mOptionsMenuInvalidated = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mPendingFragmentActivityResults = android.support.v4.util.SparseArrayCompat@318008352 (0x12f46c20)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mReallyStopped = true</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mRequestedPermissionsFromFragment = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mResumed = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mRetaining = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mStopped = true</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mStartedActivityFromFragment = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mStartedIntentSenderFromFragment = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mExtraDataMap = android.support.v4.util.SimpleArrayMap@318005888 (0x12f46280)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mActionBar = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mActivityInfo = android.content.pm.ActivityInfo@318009472 (0x12f47080)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mActivityTransitionState = android.app.ActivityTransitionState@317937344 (0x12f356c0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mAllLoaderManagers = android.util.ArrayMap@318081312 (0x12f58920)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mApplication = com.xiao.memoryleakexample.app.App@315492832 (0x12ce09e0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mCalled = true</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mChangeCanvasToTranslucent = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mChangingConfigurations = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mCheckedForLoaderManager = true</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mComponent = android.content.ComponentName@314990768 (0x12c660b0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mConfigChangeFlags = 0</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mContainer = android.app.Activity$1@317876848 (0x12f26a70)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mCurrentConfig = android.content.res.Configuration@317856672 (0x12f21ba0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mDecor = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mDefaultKeyMode = 0</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mDefaultKeySsb = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mDestroyed = true</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mDoReportFullyDrawn = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mEmbeddedID = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mEnableDefaultActionBarUp = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mEnterTransitionListener = android.app.SharedElementCallback$1@1893595344 (0x70ddf8d0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mExitTransitionListener = android.app.SharedElementCallback$1@1893595344 (0x70ddf8d0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mFinished = true</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mFragments = android.app.FragmentManagerImpl@317856448 (0x12f21ac0)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mHandler = android.os.Handler@318005856 (0x12f46260)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mIdent = 578025123</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mInstanceTracker = android.os.StrictMode$InstanceTracker@317876864 (0x12f26a80)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mInstrumentation = android.app.Instrumentation@315352176 (0x12cbe470)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mIntent = android.content.Intent@317362304 (0x12ea9080)</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mLastNonConfigurationInstances = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mLoaderManager = null</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mLoadersStarted = false</span><br><span class="line">04-25 10:20:46.793 D/LeakCanary: |   mMainThread = android.app.ActivityThread@314856000 (0x12c45240)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mManagedCursors = java.util.ArrayList@318005792 (0x12f46220)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mManagedDialogs = null</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mMenuInflater = null</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mParent = null</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mReferrer = java.lang.String@314984512 (0x12c64840)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mResultCode = 0</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mResultData = null</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mResumed = false</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mSearchManager = null</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mStartedActivity = false</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mStopped = true</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mTemporaryPause = false</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mTitle = java.lang.String@316164352 (0x12d84900)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mTitleColor = 0</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mTitleReady = true</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mToken = android.os.BinderProxy@314983040 (0x12c64280)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mTranslucentCallback = null</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mUiThread = java.lang.Thread@1967775656 (0x7549dfa8)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mVisibleBehind = false</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mVisibleFromClient = true</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mVisibleFromServer = true</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mVoiceInteractor = null</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mWindow = com.android.internal.policy.impl.PhoneWindow@315631936 (0x12d02940)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mWindowAdded = true</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mWindowManager = android.view.WindowManagerImpl@318006848 (0x12f46640)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mInflater = com.android.internal.policy.impl.PhoneLayoutInflater@317929312 (0x12f33760)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mOverrideConfiguration = null</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mResources = android.content.res.Resources@314591360 (0x12c04880)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mTheme = android.content.res.Resources$Theme@318006400 (0x12f46480)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mThemeResource = 2131230884</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: |   mBase = android.app.ContextImpl@317145792 (0x12e742c0)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: * Excluded Refs:</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.view.inputmethod.InputMethodManager.mNextServedView</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.view.inputmethod.InputMethodManager.mServedView</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.view.inputmethod.InputMethodManager.mServedInputConnection</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.view.inputmethod.InputMethodManager.mCurRootView</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.animation.LayoutTransition$1.val$parent</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.view.textservice.SpellCheckerSession$1.this$0</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.support.v7.internal.widget.ActivityChooserModel.mActivityChoserModelPolicy</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.widget.ActivityChooserModel.mActivityChoserModelPolicy</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.accounts.AccountManager$AmsTask$Response.this$1</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.media.MediaScannerConnection.mContext</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.os.UserManager.mContext</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.media.AudioManager$1.this$0</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.widget.Editor$Blink.this$0</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.net.ConnectivityManager.sInstance</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Field: android.view.Choreographer$FrameDisplayEventReceiver.mMessageQueue (always)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Static field: android.text.TextLine.sCached</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Thread:FinalizerWatchdogDaemon (always)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Thread:main (always)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Thread:LeakCanary-Heap-Dump (always)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.WeakReference (always)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.SoftReference (always)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.PhantomReference (always)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.Finalizer (always)</span><br><span class="line">04-25 10:20:46.803 D/LeakCanary: | Class:java.lang.ref.FinalizerReference (always)</span><br></pre></td></tr></table></figure></p>
<p>日志当中展示了详细的内存泄露信息。同时，在运行设备上，会以通知的形式展示内存泄露：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-8bcf65fad8f9b3f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LeakCanary内存泄露通知"></p>
<p>点击通知栏后会展示消息的内存泄露信息，包括泄露的具体实例、以及发生在哪个类中的具体引用位置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-948d449f47593e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LeakCanary内存泄露详细信息-1"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-3352c6ff39918b00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LeakCanary内存泄露详细信息-2"></p>
<h6 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h6><p>Lint、Android Monitor、Mat，以及LeakCanary都能让我们在平常的开发过程中非常有效的避免内存泄露，至于选择哪个工具，那种方式，就看自己平常的习惯了。个人还是更喜欢使用LeakCanary，只需要简单的集成，就可以更加快速，直观展示内存泄露的信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/Android内存优化——常见内存泄露及优化方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/13/Android内存优化——常见内存泄露及优化方案/" itemprop="url">Android内存优化——常见内存泄露及优化方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T15:59:55+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果一个无用对象（不需要再使用的对象）仍然被其他对象持有引用，造成该对象无法被系统回收，以致该对象在堆中所占用的内存单元无法被释放而造成内存空间浪费，这中情况就是内存泄露。</p>
<p>在Android开发中，一些不好的编程习惯会导致我们的开发的app存在内存泄露的情况。下面介绍一些在Android开发中常见的内存泄露场景及优化方案。</p>
<h6 id="单例导致内存泄露"><a href="#单例导致内存泄露" class="headerlink" title="单例导致内存泄露"></a>单例导致内存泄露</h6><p>单例模式在Android开发中会经常用到，但是如果使用不当就会导致内存泄露。因为单例的静态特性使得它的生命周期同应用的生命周期一样长，如果一个对象已经没有用处了，但是单例还持有它的引用，那么在整个应用程序的生命周期它都不能正常被回收，从而导致内存泄露。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AppSettings &#123;</span><br><span class="line"></span><br><span class="line">    private static AppSettings sInstance;</span><br><span class="line">    private Context mContext;</span><br><span class="line"></span><br><span class="line">    private AppSettings(Context context) &#123;</span><br><span class="line">        this.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static AppSettings getInstance(Context context) &#123;</span><br><span class="line">        if (sInstance == null) &#123;</span><br><span class="line">            sInstance = new AppSettings(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>像上面代码中这样的单例，如果我们在调用<code>getInstance(Context context)</code>方法的时候传入的<code>context</code>参数是<code>Activity</code>、<code>Service</code>等上下文，就会导致内存泄露。</p>
<p>以<code>Activity</code>为例，当我们启动一个<code>Activity</code>，并调用<code>getInstance(Context context)</code>方法去获取<code>AppSettings</code>的单例，传入<code>Activity.this</code>作为<code>context</code>，这样<code>AppSettings</code>类的单例<code>sInstance</code>就持有了<code>Activity</code>的引用，当我们退出<code>Activity</code>时，该<code>Activity</code>就没有用了，但是因为<code>sIntance</code>作为静态单例（在应用程序的整个生命周期中存在）会继续持有这个<code>Activity</code>的引用，导致这个<code>Activity</code>对象无法被回收释放，这就造成了内存泄露。</p>
<p>为了避免这样单例导致内存泄露，我们可以将<code>context</code>参数改为全局的上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private AppSettings(Context context) &#123;</span><br><span class="line">    this.mContext = context.getApplicationContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>全局的上下文<code>Application Context</code>就是应用程序的上下文，和单例的生命周期一样长，这样就避免了内存泄漏。</p>
<p>单例模式对应应用程序的生命周期，所以我们在构造单例的时候尽量避免使用<code>Activity</code>的上下文，而是使用<code>Application</code>的上下文。</p>
<h6 id="静态变量导致内存泄露"><a href="#静态变量导致内存泄露" class="headerlink" title="静态变量导致内存泄露"></a>静态变量导致内存泄露</h6><p>静态变量存储在方法区，它的生命周期从类加载开始，到整个进程结束。一旦静态变量初始化后，它所持有的引用只有等到进程结束才会释放。</p>
<p>比如下面这样的情况，在<code>Activity</code>中为了避免重复的创建<code>info</code>，将<code>sInfo</code>作为静态变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static Info sInfo;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        if (sInfo != null) &#123;</span><br><span class="line">            sInfo = new Info(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Info &#123;</span><br><span class="line">    public Info(Activity activity) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Info</code>作为<code>Activity</code>的静态成员，并且持有<code>Activity</code>的引用，但是<code>sInfo</code>作为静态变量，生命周期肯定比<code>Activity</code>长。所以当<code>Activity</code>退出后，<code>sInfo</code>仍然引用了<code>Activity</code>，<code>Activity</code>不能被回收，这就导致了内存泄露。</p>
<p>在Android开发中，静态持有很多时候都有可能因为其使用的生命周期不一致而导致内存泄露，所以我们在新建静态持有的变量的时候需要多考虑一下各个成员之间的引用关系，并且尽量少地使用静态持有的变量，以避免发生内存泄露。当然，我们也可以在适当的时候讲静态量重置为null，使其不再持有引用，这样也可以避免内存泄露。</p>
<h6 id="非静态内部类导致内存泄露"><a href="#非静态内部类导致内存泄露" class="headerlink" title="非静态内部类导致内存泄露"></a>非静态内部类导致内存泄露</h6><p>非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。</p>
<p>非静态内部类导致的内存泄露在Android开发中有一种典型的场景就是使用<code>Handler</code>，很多开发者在使用<code>Handler</code>是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void start() &#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = 1;</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Handler mHandler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (msg.what == 1) &#123;</span><br><span class="line">                // 做相应逻辑</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也许有人会说，<code>mHandler</code>并未作为静态变量持有<code>Activity</code>引用，生命周期可能不会比<code>Activity</code>长，应该不一定会导致内存泄露呢，显然不是这样的！</p>
<p>熟悉<code>Handler</code>消息机制的都知道，<code>mHandler</code>会作为成员变量保存在发送的消息<code>msg</code>中，即<code>msg</code>持有<code>mHandler</code>的引用，而<code>mHandler</code>是<code>Activity</code>的非静态内部类实例，即<code>mHandler</code>持有<code>Activity</code>的引用，那么我们就可以理解为<code>msg</code>间接持有<code>Activity</code>的引用。<code>msg</code>被发送后先放到消息队列<code>MessageQueue</code>中，然后等待<code>Looper</code>的轮询处理（<code>MessageQueue</code>和<code>Looper</code>都是与线程相关联的，<code>MessageQueue</code>是<code>Looper</code>引用的成员变量，而<code>Looper</code>是保存在<code>ThreadLocal</code>中的）。那么当<code>Activity</code>退出后，<code>msg</code>可能仍然存在于消息对列<code>MessageQueue</code>中未处理或者正在处理，那么这样就会导致<code>Activity</code>无法被回收，以致发生<code>Activity</code>的内存泄露。</p>
<p>通常在Android开发中如果要使用内部类，但又要规避内存泄露，一般都会采用<em>静态内部类+弱引用</em>的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private Handler mHandler;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mHandler = new MyHandler(this);</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void start() &#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = 1;</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class MyHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line">        private WeakReference&lt;MainActivity&gt; activityWeakReference;</span><br><span class="line"></span><br><span class="line">        public MyHandler(MainActivity activity) &#123;</span><br><span class="line">            activityWeakReference = new WeakReference&lt;&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            MainActivity activity = activityWeakReference.get();</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                if (msg.what == 1) &#123;</span><br><span class="line">                    // 做相应逻辑</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mHandler</code>通过弱引用的方式持有<code>Activity</code>，当GC执行垃圾回收时，遇到<code>Activity</code>就会回收并释放所占据的内存单元。这样就不会发生内存泄露了。</p>
<p>上面的做法确实避免了<code>Activity</code>导致的内存泄露，发送的<code>msg</code>不再已经没有持有<code>Activity</code>的引用了，但是<code>msg</code>还是有可能存在消息队列<code>MessageQueue</code>中，所以更好的是在<code>Activity</code>销毁时就将<code>mHandler</code>的回调和发送的消息给移除掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    mHandler.removeCallbacksAndMessages(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非静态内部类造成内存泄露还有一种情况就是使用<code>Thread</code>或者<code>AsyncTask</code>。</p>
<p>比如在Activity中直接<code>new</code>一个子线程<code>Thread</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // 模拟相应耗时逻辑</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者直接新建<code>AsyncTask</code>异步任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        new AsyncTask&lt;Void, Void, Void&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Void doInBackground(Void... params) &#123;</span><br><span class="line">                // 模拟相应耗时逻辑</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 很多初学者都会像上面这样新建线程和异步任务，殊不知这样的写法非常地不友好，这种方式新建的子线程<code>Thread</code>和<code>AsyncTask</code>都是匿名内部类对象，默认就隐式的持有外部<code>Activity</code>的引用，导致<code>Activity</code>内存泄露。要避免内存泄露的话还是需要像上面<code>Handler</code>一样使用<em>静态内部类+弱应用</em>的方式（代码就不列了，参考上面<code>Hanlder</code>的正确写法）。</p>
<h6 id="未取消注册或回调导致内存泄露"><a href="#未取消注册或回调导致内存泄露" class="headerlink" title="未取消注册或回调导致内存泄露"></a>未取消注册或回调导致内存泄露</h6><p>比如我们在<code>Activity</code>中注册广播，如果在<code>Activity</code>销毁后不取消注册，那么这个刚播会一直存在系统中，同上面所说的非静态内部类一样持有<code>Activity</code>引用，导致内存泄露。因此注册广播后在<code>Activity</code>销毁后一定要取消注册。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        this.registerReceiver(mReceiver, new IntentFilter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BroadcastReceiver mReceiver = new BroadcastReceiver() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            // 接收到广播需要做的逻辑</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        this.unregisterReceiver(mReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用<code>Retrofit+RxJava</code>注册网络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候取消注册。</p>
<h6 id="Timer和TimerTask导致内存泄露"><a href="#Timer和TimerTask导致内存泄露" class="headerlink" title="Timer和TimerTask导致内存泄露"></a>Timer和TimerTask导致内存泄露</h6><p><code>Timer</code>和<code>TimerTask</code>在Android中通常会被用来做一些计时或循环任务，比如实现无限轮播的<code>ViewPager</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private ViewPager mViewPager;</span><br><span class="line">    private PagerAdapter mAdapter;</span><br><span class="line">    private Timer mTimer;</span><br><span class="line">    private TimerTask mTimerTask;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        init();</span><br><span class="line">        mTimer.schedule(mTimerTask, 3000, 3000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mViewPager = (ViewPager) findViewById(R.id.view_pager);</span><br><span class="line">        mAdapter = new ViewPagerAdapter();</span><br><span class="line">        mViewPager.setAdapter(mAdapter);</span><br><span class="line"></span><br><span class="line">        mTimer = new Timer();</span><br><span class="line">        mTimerTask = new TimerTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                MainActivity.this.runOnUiThread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        loopViewpager();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loopViewpager() &#123;</span><br><span class="line">        if (mAdapter.getCount() &gt; 0) &#123;</span><br><span class="line">            int curPos = mViewPager.getCurrentItem();</span><br><span class="line">            curPos = (++curPos) % mAdapter.getCount();</span><br><span class="line">            mViewPager.setCurrentItem(curPos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void stopLoopViewPager() &#123;</span><br><span class="line">        if (mTimer != null) &#123;</span><br><span class="line">            mTimer.cancel();</span><br><span class="line">            mTimer.purge();</span><br><span class="line">            mTimer = null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mTimerTask != null) &#123;</span><br><span class="line">            mTimerTask.cancel();</span><br><span class="line">            mTimerTask = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        stopLoopViewPager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们<code>Activity</code>销毁的时，有可能<code>Timer</code>还在继续等待执行<code>TimerTask</code>，它持有Activity的引用不能被回收，因此当我们Activity销毁的时候要立即<code>cancel</code>掉<code>Timer</code>和<code>TimerTask</code>，以避免发生内存泄漏。</p>
<h6 id="集合中的对象未清理造成内存泄露"><a href="#集合中的对象未清理造成内存泄露" class="headerlink" title="集合中的对象未清理造成内存泄露"></a>集合中的对象未清理造成内存泄露</h6><p>这个比较好理解，如果一个对象放入到<code>ArrayList</code>、<code>HashMap</code>等集合中，这个集合就会持有该对象的引用。当我们不再需要这个对象时，也并没有将它从集合中移除，这样只要集合还在使用（而此对象已经无用了），这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那些没有用的对象更会造成内存泄露了。所以在使用集合时要及时将不用的对象从集合<code>remove</code>，或者<code>clear</code>集合，以避免内存泄漏。</p>
<h6 id="资源未关闭或释放导致内存泄露"><a href="#资源未关闭或释放导致内存泄露" class="headerlink" title="资源未关闭或释放导致内存泄露"></a>资源未关闭或释放导致内存泄露</h6><p>在使用<code>IO</code>、<code>File</code>流或者<code>Sqlite</code>、<code>Cursor</code>等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果及时不关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。因此我们在不需要使用它们的时候就及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。</p>
<h6 id="属性动画造成内存泄露"><a href="#属性动画造成内存泄露" class="headerlink" title="属性动画造成内存泄露"></a>属性动画造成内存泄露</h6><p>动画同样是一个耗时任务，比如在<code>Activity</code>中启动了属性动画（<code>ObjectAnimator</code>），但是在销毁的时候，没有调用<code>cancle</code>方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用<code>Activity</code>，这就造成<code>Activity</code>无法正常释放。因此同样要在<code>Activity</code>销毁的时候<code>cancel</code>掉属性动画，避免发生内存泄漏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    mAnimator.cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="WebView造成内存泄露"><a href="#WebView造成内存泄露" class="headerlink" title="WebView造成内存泄露"></a>WebView造成内存泄露</h6><p>关于WebView的内存泄露，因为WebView在加载网页后会长期占用内存而不能被释放，因此我们在Activity销毁后要调用它的<code>destory()</code>方法来销毁它以释放内存。</p>
<p>另外在查阅<code>WebView</code>内存泄露相关资料时看到这种情况：</p>
<blockquote>
<p><code>Webview</code>下面的<code>Callback</code>持有<code>Activity</code>引用，造成<code>Webview</code>内存无法释放，即使是调用了<code>Webview.destory()</code>等方法都无法解决问题（Android5.1之后）。</p>
</blockquote>
<p>最终的解决方案是：在销毁<code>WebView</code>之前需要先将<code>WebView从</code>父容器中移除，然后在销毁<code>WebView</code>。详细分析过程请参考这篇文章：<a href="http://blog.csdn.net/xygy8860/article/details/53334476?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener"><a href="http://blog.csdn.net/xygy8860/article/details/53334476" target="_blank" rel="noopener">WebView内存泄漏解决方法</a></a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    // 先从父控件中移除WebView</span><br><span class="line">    mWebViewContainer.removeView(mWebView);</span><br><span class="line">    mWebView.stopLoading();</span><br><span class="line">    mWebView.getSettings().setJavaScriptEnabled(false);</span><br><span class="line">    mWebView.clearHistory();</span><br><span class="line">    mWebView.removeAllViews();</span><br><span class="line">    mWebView.destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>内存泄露在Android内存优化是一个比较重要的一个方面，很多时候程序中发生了内存泄露我们不一定就能注意到，所有在编码的过程要养成良好的习惯。总结下来只要做到以下这几点就能避免大多数情况的内存泄漏：</p>
<p>构造单例的时候尽量别用<code>Activity</code>的引用；<br>静态引用时注意应用对象的置空或者少用静态引用；<br>使用静态内部类+软引用代替非静态内部类；<br>及时取消广播或者观察者注册；<br>耗时任务、属性动画在<code>Activity</code>销毁时记得<code>cancel</code>；<br>文件流、<code>Cursor</code>等资源及时关闭；<br><code>Activity</code>销毁时<code>WebView</code>的移除和销毁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/Android内存优化——概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/11/Android内存优化——概述/" itemprop="url">Android内存优化——概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T23:14:10+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android 应用运行在 Java 虚拟机上，每打开一个 Android app 都会打开一个独立的虚拟机。运行虚拟机时会在设备的寄存器上开辟一块内存空间作为虚拟机的内存区域。虚拟机的内存区域一般划分为堆、栈、方法区/静态存储区、运行时常量池、本地方法栈等。</p>
<h6 id="堆、栈"><a href="#堆、栈" class="headerlink" title="堆、栈"></a>堆、栈</h6><p>堆是不连续的内存区域（因为系统是用链表来存储堆中的空闲内存地址）。堆上分配内存的过程为动态分配过程，在堆中存放由 new 关键字创建的对象或数组。堆的内存管理是由 Java 的 GC（垃圾回收机制）来管理的。通常我们所说的内存优化即是堆内存的优化。</p>
<p>栈是针对线程来说的，每个线程都有一个栈。栈中主要存放<em>基本类型的变量</em>和<em>对象的引用</em>，并且对象本身是没有存放在栈中，而是存放在堆中的。</p>
<p>当方法执行时，方法内部的局部变量被创建，基本类型的变量会直接存放在栈中，引用类型的变量则会将该引用变量在堆中的内存地址存放在栈中。方法执行结束时，这些局部变量在栈中所占的内存空间就会被释放。</p>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    int i = 1;</span><br><span class="line">    Girl g1 = new Girl();</span><br><span class="line"></span><br><span class="line">    public void x() &#123;</span><br><span class="line">        int j = 1;</span><br><span class="line">        Girl g2 = new Girl();</span><br><span class="line">        Girl g3 = g1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>i</code>、<code>g1</code>为成员变量，<code>j</code>、<code>g2</code>、<code>g3</code>为方法<code>x()</code>中的局部变量，<code>i</code>和<code>g1</code>字段属于类，类最终是要被new出来。所以<code>i</code>和<code>g1</code>存放在堆中的。<code>j</code>为基本类型，作为局部变量肯定是存放在栈中的。<code>g2</code>和<code>g3</code>都为引用类型，它们引用的对象实体是存放在堆中的，在栈中只存有他们的引用（堆中的内存地址），当方法执行结束后，栈中的引用被释放。</p>
<p>总结： 成员变量（基本类型和引用类型）全部存储在堆中；基本类型的局部变量存储在栈中；引用类型的局部变量的对象实体是存在堆中，栈中只存有它的引用。</p>
<h6 id="垃圾回收器-GC"><a href="#垃圾回收器-GC" class="headerlink" title="垃圾回收器 GC"></a>垃圾回收器 GC</h6><p>栈内存的特点是效率高、速度快，并且在方法结束时就自动释放，但是它的容量有限。而堆内存空间的释放完全依赖于 GC 。在程序的运行过程中，GC 会不定时的被唤醒检查是否有没有被引用的对象，并释放他们的空间。</p>
<p>一般在堆内存占用较多（内存不足）的空闲时候系统可能会自动执行垃圾回收。但是垃圾回收机制只针对“垃圾”有效。所谓垃圾，是指存在于堆中，并且程序不能再访问到的对象（不可达的对象）。GC 在执行垃圾回收时，会将不可达的对象放入垃圾回收器中，而对于那些还处于引用状态即可达对象 GC 会根据该对象的引用状态来决定是否回收。</p>
<p>Java中对象的引用状态有强引用、软引用、弱引用、虚引用4种。</p>
<h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><p>强引用是使用最普遍的引用方式，我们平常使用的大部分引用都是强引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠回收具有强引用的对象来解决内存不足的问题。</p>
<h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><p>一个对象具有软引用，如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        SoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person);</span><br><span class="line">        person = null;</span><br><span class="line">        if (sr != null) &#123;</span><br><span class="line">            person = sr.get();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            person = new Person();</span><br><span class="line">            sr = new SoftReference&lt;Person&gt;(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        WeakReference&lt;Person&gt; wr = new WeakReference&lt;Person&gt;(person);</span><br><span class="line">        person = null;</span><br><span class="line">        if (wr != null) &#123;</span><br><span class="line">            person = wr.get();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            person = new Person();</span><br><span class="line">            wr = new WeakReference&lt;Person&gt;(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动，我们平常一般不会使用。</p>
<p>需要注意的是，GC 什么时候回收垃圾是无法控制的，垃圾回收时间也是无法预料的。</p>
<p>GC 内存管理机制虽然能帮助我们自动管理内存，避免了程序员主动释放内存的繁琐工作，但它不能解决所有的问题。GC不能回收的对象可能会导致内存泄露，甚至使整个程序发生OOM。</p>
<h6 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h6><p>当一个对象在程序执行过后已经不需要再使用了，但是有其他的对象仍然持有该对象的引用，以致该对象不能被 GC 回收，那么这个对象会一直占据内存，从而导致该内存不可用。这种本该被GC回收（不再需要用了）而又不能被回收（被其他对象持有引用）以致停留在堆内存中的对象就造成了内存泄露。</p>
<h6 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h6><p>内存溢出，OutOfMemory ，即 我们通常所说的OOM，是指程序在申请内存时，没有足够的内存空间供其使用。</p>
<p>在Android中，有以下几种情况可能发生内存溢出：<br>1.内存泄露可能导致内存溢出的发生；<br>2.一次加载的数据量过大，如一次从数据库读取过多数据；<br>3.保存了许多耗用内存过大的对象（如Bitmap）或加载单个超大的图片，造成内存超出限制；<br>4.代码中存在死循环或循环产生过多重复的对象实体。</p>
<p>GC能自动回收并释放无用的对象，但是如果程序频繁的GC也会导致一些问题。</p>
<h6 id="频繁GC"><a href="#频繁GC" class="headerlink" title="频繁GC"></a>频繁GC</h6><p>程序在执行GC操作的时候，任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。故而如果Andorid应用频繁GC，UI线程有可能会暂停，从而导致导致界面卡顿。</p>
<p>导致频繁GC主要有两个方面的原因：<br>1.内存抖动， 即大量的对象被创建又在短时间内马上被释放。<br>2.瞬间产生大量对象会严重占用内存区域，当达到阀值， 剩余空间不够的时候，就会触发GC。即使每次分配的对象需要占用很少的内存，但是他们叠加在一起会增加堆内存的压力， 从而触发更多的GC。</p>
<hr>
<p>OK，Android内存优化的概述就到此为止。后面会详细介绍Android中的内存泄露及相关优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/29/Android动画总结——布局动画、转场动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/29/Android动画总结——布局动画、转场动画/" itemprop="url">Android动画总结——布局动画、转场动画</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-29T11:37:42+08:00">
                2017-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前一篇文章总结了<a href="http://www.jianshu.com/p/afc7b3a2e3e9" target="_blank" rel="noopener">View动画、属性动画、帧动画</a>，这篇文章继续总结布局动画、转场动画。</p>
<hr>
<h4 id="布局动画"><a href="#布局动画" class="headerlink" title="布局动画"></a>布局动画</h4><p>布局动画的作用于<code>ViewGroup</code>，执行动画效果的是内部的子View。布局动画在android中可以通过<code>LayoutAnimation</code>或<code>LayoutTransition</code>来实现。</p>
<h5 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h5><p><code>LayoutAnimation</code>实际上是一个View动画，用来控制子View显示时的动画效果。可以通过Java代码或者Xml文件来定义<code>LayoutAnimation</code>动画。</p>
<h6 id="通过Java代码来定义LayoutAnimation"><a href="#通过Java代码来定义LayoutAnimation" class="headerlink" title="通过Java代码来定义LayoutAnimation"></a>通过Java代码来定义LayoutAnimation</h6><p>定义子View的显示动画<code>layout_item_anim_set.xml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">     android:duration=&quot;300&quot;</span><br><span class="line">     android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;</span><br><span class="line">     android:shareInterpolator=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;alpha</span><br><span class="line">        android:fromAlpha=&quot;0.0&quot;</span><br><span class="line">        android:toAlpha=&quot;1.0&quot;/&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:fromXDelta=&quot;500&quot;</span><br><span class="line">        android:toXDelta=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>以<code>ListView</code>为例，给<code>ListView</code>设置item的显示动画：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void setLayoutAnimation() &#123;</span><br><span class="line">    Animation animation = AnimationUtils.loadAnimation(this, R.anim.layout_item_anim_set);</span><br><span class="line">    LayoutAnimationController controller = new LayoutAnimationController(animation);</span><br><span class="line">    controller.setDelay(0.5f);</span><br><span class="line">    controller.setOrder(LayoutAnimationController.ORDER_NORMAL);</span><br><span class="line">    mListView.setLayoutAnimation(controller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="通过Xml代码来定义LayoutAnimation："><a href="#通过Xml代码来定义LayoutAnimation：" class="headerlink" title="通过Xml代码来定义LayoutAnimation："></a>通过Xml代码来定义LayoutAnimation：</h6><p><code>layout_anim.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layoutAnimation</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:animation=&quot;@anim/layout_item_anim_set&quot;</span><br><span class="line">    android:animationOrder=&quot;normal&quot;</span><br><span class="line">    android:delay=&quot;0.5&quot;&gt;</span><br><span class="line">&lt;/layoutAnimation&gt;</span><br></pre></td></tr></table></figure></p>
<p>在<code>ListView</code>所在布局中调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView</span><br><span class="line">    android:id=&quot;@+id/list_view&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:divider=&quot;#f1f1f1&quot;</span><br><span class="line">    android:dividerHeight=&quot;1dp&quot;</span><br><span class="line">    android:layoutAnimation=&quot;@anim/layout_anim&quot;</span><br><span class="line">    android:listSelector=&quot;?android:attr/selectableItemBackground&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>setDelay()</code>方法以及<code>android:delay</code>属性表示子View动画显示的延迟时间比例。比如动画执行时间是300ms，延迟比例是0.5，那么延迟时间就是150ms，在Listview中，第一个item在延迟150ms开始动画后，第二个在300ms后开始动画，第三个在450ms后开始，以此类推。<br><code>setOder()</code>方法以及<code>android:animationOrder</code>表示动画执行的顺序类型，共有三种：<code>normal</code>表示子View按顺序显示，<code>reverse</code>表示子View按逆序显示，<code>random</code>表示子View随机先后显示。<br><img src="http://upload-images.jianshu.io/upload_images/1801191-d0d77f6e9c72efb6.gif?imageMogr2/auto-orient/strip" alt="LayoutAnimation效果图"></p>
<h5 id="LayoutTransition"><a href="#LayoutTransition" class="headerlink" title="LayoutTransition"></a>LayoutTransition</h5><p><code>LayoutTransition</code>用于在<code>ViewGroup</code>中有子View添加、删除、隐藏、显示时所有子View动画效果。<code>LayoutTransition</code>有5中动画变化形式</p>
<blockquote>
<p><code>LayoutTransition.APPEARING</code>：子View添加到容器中时的动画效果<code>LayoutTransition.CHANGE_APPEARING</code>：子View添加到容器中时，其他子View位置改变的动画效果<br><code>LayoutTransition.DISAPPEARING</code>：子View被移除时的动画效果<br><code>LayoutTransition.CHANGE_DISAPPEARING</code>：子View被移除时，其他子View的动画效果<br><code>LayoutTransition.CHANGING</code>：子View在容器中位置变化时其他子View的动画效果</p>
</blockquote>
<h6 id="使用默认的动画样式"><a href="#使用默认的动画样式" class="headerlink" title="使用默认的动画样式"></a>使用默认的动画样式</h6><p>只需要在使用的LinearLayout、FrameLayout、RelativeLayout等ViewGroup容器的布局文件中添加<code>android:animateLayoutChanges=&quot;true&quot;</code>即可，系统会使用默认的LayoutTransition来实现子View添加、删除或变化是的动画效果。<br><img src="http://upload-images.jianshu.io/upload_images/1801191-60af20516bcae8fb.gif?imageMogr2/auto-orient/strip" alt="默认的LayoutTransition效果"></p>
<h6 id="使用自定义动画样式"><a href="#使用自定义动画样式" class="headerlink" title="使用自定义动画样式"></a>使用自定义动画样式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private void init() &#123;</span><br><span class="line">    mContainer = (LinearLayout) findViewById(R.id.container);</span><br><span class="line">    setLayoutTransition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setLayoutTransition() &#123;</span><br><span class="line">    LayoutTransition transition = new LayoutTransition();</span><br><span class="line">    // 子View添加到mContainer时的动画</span><br><span class="line">    Animator appearAnim = ObjectAnimator</span><br><span class="line">            .ofFloat(null, &quot;rotationX&quot;, 90, 0)</span><br><span class="line">            .setDuration(transition.getDuration(LayoutTransition.APPEARING));</span><br><span class="line">    transition.setAnimator(LayoutTransition.APPEARING, appearAnim);</span><br><span class="line">    // 子Veiw从mContainer中移除时的动画</span><br><span class="line">    Animator disappearAnim = ObjectAnimator</span><br><span class="line">            .ofFloat(null, &quot;rotationX&quot;, 0, 90)</span><br><span class="line">            .setDuration(transition.getDuration(LayoutTransition.DISAPPEARING));</span><br><span class="line">    transition.setAnimator(LayoutTransition.DISAPPEARING, disappearAnim);</span><br><span class="line">    // 子Veiw添加到mContainer中时其他子View的动画</span><br><span class="line">    PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;, 0, 0);</span><br><span class="line">    PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;, 0, 0);</span><br><span class="line">    PropertyValuesHolder pvhTranslationY = PropertyValuesHolder</span><br><span class="line">            .ofFloat(&quot;translationX&quot;, 0, 150, 0);</span><br><span class="line">    Animator changeAppearAnim = ObjectAnimator</span><br><span class="line">            .ofPropertyValuesHolder(mContainer, pvhLeft, pvhTop, pvhTranslationY)</span><br><span class="line">            .setDuration(transition.getDuration(LayoutTransition.CHANGE_APPEARING));</span><br><span class="line">    transition.setAnimator(LayoutTransition.CHANGE_APPEARING, changeAppearAnim);</span><br><span class="line">    // 子View从mContainer中移除时其他子View的动画</span><br><span class="line">    PropertyValuesHolder outLeft = PropertyValuesHolder.ofInt(&quot;left&quot;, 0, 0);</span><br><span class="line">    PropertyValuesHolder outTop = PropertyValuesHolder.ofInt(&quot;top&quot;, 0, 0);</span><br><span class="line">    PropertyValuesHolder pvhTranslationYDis = PropertyValuesHolder</span><br><span class="line">            .ofFloat(&quot;translationX&quot;, 0, -150, 0);</span><br><span class="line">    ObjectAnimator changeDisAppearAnim = ObjectAnimator</span><br><span class="line">            .ofPropertyValuesHolder(mContainer, outLeft, outTop, pvhTranslationYDis)</span><br><span class="line">            .setDuration(transition.getDuration(LayoutTransition.CHANGE_DISAPPEARING));</span><br><span class="line">    transition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, changeDisAppearAnim);</span><br><span class="line"></span><br><span class="line">    mContainer.setLayoutTransition(transition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加子View到第0个位置</span><br><span class="line">public void addData(View view) &#123;</span><br><span class="line">    View child = LayoutInflater.from(this)</span><br><span class="line">            .inflate(R.layout.item, mContainer, false);</span><br><span class="line">    mContainer.addView(child, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移除第0个子View</span><br><span class="line">public void deleteData(View view) &#123;</span><br><span class="line">    if (mContainer.getChildCount() != 0) mContainer.removeViewAt(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用<code>PropertyValuesHolder</code>时，需要注意一下几点：<br>1.<code>LayoutTransition.CHANGE_APPEARING</code>和<code>LayoutTransition.CHANGE_DISAPPEARING</code>必须使用<code>PropertyValuesHolder</code>构造动画才会有效果，其他任何方式构造动画都不会有效果。<br>2.在使用<code>PropertyValuesHolder</code>时，<code>”left”</code>、<code>”top”</code>属性就算不需要变化也必须要写，如果不需要变化可以写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;, 0, 0);</span><br><span class="line">PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;, 0, 0);</span><br></pre></td></tr></table></figure></p>
<p>3.<code>ofInt</code>，<code>ofFloat</code>中的参数值，第一个值和最后一个值必须相同，不然此属性所对应的的动画将被放弃，在此属性值上将不会有效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder pvhTranslationY = PropertyValuesHolder</span><br><span class="line">            .ofFloat(&quot;translationX&quot;, 0, 150, 0);</span><br></pre></td></tr></table></figure></p>
<p>4.使用的<code>ofInt</code>，<code>ofFloat</code>中，如果所有参数值都相同，也将不会有动画效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;, 0, 0);</span><br></pre></td></tr></table></figure></p>
<p>动画的参数全部相同，left这个属性的动画不会有任何效果。</p>
<p>说明：关于<code>PropertyValuesHolder</code>几个注意点参考自文章<a href="http://blog.csdn.net/xuefu_78/article/details/52449749" target="_blank" rel="noopener"><a href="http://blog.csdn.net/xuefu_78/article/details/52449749" target="_blank" rel="noopener">animateLayoutChanges与LayoutTransition</a></a>。<br><img src="http://upload-images.jianshu.io/upload_images/1801191-eeafc5d795f256d8.gif?imageMogr2/auto-orient/strip" alt="自定义动画样式配置LayoutTransition效果"></p>
<hr>
<h4 id="转场动画"><a href="#转场动画" class="headerlink" title="转场动画"></a>转场动画</h4><h5 id="Android-5-0之前转场动画"><a href="#Android-5-0之前转场动画" class="headerlink" title="Android 5.0之前转场动画"></a>Android 5.0之前转场动画</h5><p>在Android 5.0以前实现转场动画是通过补间动画来实现，通常是在<code>Activity</code>中是<code>overridePendingTransition(int enterAnim, int exitAnim)</code>方法。<br><code>enterAnim</code>和<code>exitAnim</code>两个参数对应的是两个View动画：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_anim);</span><br><span class="line">    setStartActivityAnim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setStartActivityAnim() &#123;</span><br><span class="line">    overridePendingTransition(R.anim.activity_right_in, R.anim.activity_left_out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>入场动画<code>activity_right_in.xml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;translate</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;300&quot;</span><br><span class="line">    android:fromXDelta=&quot;100%p&quot;</span><br><span class="line">    android:toXDelta=&quot;0&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>出场动画<code>activity_left_out.xml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;translate</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;300&quot;</span><br><span class="line">    android:fromXDelta=&quot;0&quot;</span><br><span class="line">    android:toXDelta=&quot;-100%p&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Activity</code>的<code>onCreate</code>中调用<code>overridePendingTransition</code>方法只对主动启动<code>Activity</code>有效，如果我们返回上一个<code>Activity</code>也需要同样的转场动画，就需要在<code>finish</code>方法也添加上这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void finish() &#123;</span><br><span class="line">    super.finish();</span><br><span class="line">    setEndActivityAnim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setEndActivityAnim() &#123;</span><br><span class="line">    overridePendingTransition(R.anim.activity_left_in, R.anim.activity_right_out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>finish</code>时入场动画<code>activity_left_in.xml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;translate</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;300&quot;</span><br><span class="line">    android:fromXDelta=&quot;-100%p&quot;</span><br><span class="line">    android:toXDelta=&quot;0&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>finish</code>时出场动画<code>activity_right_out.xml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;translate</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;300&quot;</span><br><span class="line">    android:fromXDelta=&quot;0&quot;</span><br><span class="line">    android:toXDelta=&quot;100%p&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-b1d765a1c5381600.gif?imageMogr2/auto-orient/strip" alt="Android 5.0前转场动画效果"></p>
<h5 id="Android-5-0之后转场动画-Activity-Transition"><a href="#Android-5-0之后转场动画-Activity-Transition" class="headerlink" title="Android 5.0之后转场动画 Activity Transition"></a>Android 5.0之后转场动画 Activity Transition</h5><p>Android 5.0之后，谷歌引入了 Activity Transition 来实现交互更加友好的转场动画效果。</p>
<blockquote>
<p><strong>Tansition的类型共有三种：</strong><br>进入 —— 决定Activity中的所有视图怎么进入屏幕<br>退出 —— 决定Activity中的所有视图怎么退出屏幕<br>共享元素 —— 决定两个Activity之间的过渡时怎么共享它们的视图</p>
<p><strong>进入和退出包含如下动画效果：</strong><br>explode(分解) —— 从屏幕中间进或出<br>slide(滑动) —— 从屏幕边缘进或出地<br>fade(淡出) —— 改变屏幕上视图的不透明度实现添加或移除视图的效果</p>
<p><strong>共享元素包含如下动画效果：</strong><br>changeBounds —— 改变目标视图的布局边界<br>changeClipBounds —— 裁剪目标视图边界<br>changeTransform —— 改变目标视图的缩放比例和旋转角度<br>changeImageTransform —— 改变目标图片的大小和缩放比例</p>
</blockquote>
<p>说明：Tansition分类及动画效果说明参考<a href="https://item.jd.com/11758334.html" target="_blank" rel="noopener">《Android群英传》</a></p>
<p>先来看下<code>Explode</code>（分解）、<code>Slide</code>（滑动）、<code>Fade</code>（淡出）三种转场动画的使用。</p>
<p>第一个<code>Activity</code>中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void explode(View view) &#123;</span><br><span class="line">    Intent intent = new Intent(this, NextTransitionActivity.class);</span><br><span class="line">    intent.putExtra(&quot;flag&quot;, &quot;explode&quot;);</span><br><span class="line">    startActivity(intent,</span><br><span class="line">            ActivityOptionsCompat.makeSceneTransitionAnimation(this).toBundle());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void slide(View view) &#123;</span><br><span class="line">    Intent intent = new Intent(this, NextTransitionActivity.class);</span><br><span class="line">    intent.putExtra(&quot;flag&quot;, &quot;slide&quot;);</span><br><span class="line">    startActivity(intent,</span><br><span class="line">            ActivityOptionsCompat.makeSceneTransitionAnimation(this).toBundle());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void fade(View view) &#123;</span><br><span class="line">    Intent intent = new Intent(this, NextTransitionActivity.class);</span><br><span class="line">    intent.putExtra(&quot;flag&quot;, &quot;fade&quot;);</span><br><span class="line">    startActivity(intent,</span><br><span class="line">            ActivityOptionsCompat.makeSceneTransitionAnimation(this).toBundle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动的第二个<code>Activity</code>中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</span><br><span class="line">    switch (getIntent().getStringExtra(&quot;flag&quot;)) &#123;</span><br><span class="line">        case &quot;explode&quot;:</span><br><span class="line">            getWindow().setEnterTransition(new Explode());</span><br><span class="line">            getWindow().setExitTransition(new Explode());</span><br><span class="line">            break;</span><br><span class="line">        case &quot;slide&quot;:</span><br><span class="line">            getWindow().setEnterTransition(new Slide());</span><br><span class="line">            getWindow().setExitTransition(new Slide());</span><br><span class="line">            break;</span><br><span class="line">        case &quot;fade&quot;:</span><br><span class="line">            getWindow().setEnterTransition(new Fade());</span><br><span class="line">            getWindow().setExitTransition(new Fade());</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    setContentView(R.layout.activity_next_transition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在第二个<code>Activity</code>中可以通过在style中配置<code>&lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt;</code><br>就不需要调用<code>getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)</code>。<br><img src="//upload-images.jianshu.io/upload_images/1801191-9377a27bf8457a40.gif" alt=""><br>共享元素转场动画，使用也比较简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;</span><br><span class="line">    TransitionAdapter.TransitionViewHolder holder = (TransitionAdapter.TransitionViewHolder) view.getTag();</span><br><span class="line">    View shareViewImg = holder.civImg;</span><br><span class="line">    View shareViewName = holder.tvName;</span><br><span class="line">    Intent intent = new Intent(this, NextTransitionActivity.class);</span><br><span class="line">    intent.putExtra(&quot;flag&quot;, &quot;share&quot;);</span><br><span class="line">    startActivity(intent, ActivityOptionsCompat</span><br><span class="line">            .makeSceneTransitionAnimation(this,</span><br><span class="line">                    Pair.create(shareViewImg, &quot;shareView_img&quot;),</span><br><span class="line">                    Pair.create(shareViewName, &quot;shareView_name&quot;))</span><br><span class="line">            .toBundle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用<code>ListView</code>实现一个列表，列表中的头像和名字作为共享元素。在<code>ListView</code>的<code>item</code>的布局以及第二个启动的<code>Activity</code>的布局中，被共享的<code>View</code>都需要在布局文件中添加上相同<code>android:transitionName</code>属性，当然也可以在Java代码中通过<code>ViewCompat.setTransitionName(View view, String transitionName)</code>方法来设置共享<code>View</code>的<code>transitionName</code>。<br>我们给头像和名称分别指定<code>android:transitionName=&quot;shareView_img&quot;</code>和<code>android:transitionName=&quot;shareView_name&quot;</code>。<br>点击<code>item</code>后启动目标<code>Activity</code>时，指定的<code>options</code>参数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptionsCompat.makeSceneTransitionAnimation(this,</span><br><span class="line">        Pair.create(shareViewImg,&quot;shareView_img&quot;),</span><br><span class="line">        Pair.create(shareViewName, &quot;shareView_name&quot;))</span><br><span class="line">.toBundle());</span><br></pre></td></tr></table></figure></p>
<p>通过<code>options</code>参数，可以利用<code>Pair</code>构造多个共享元素，但是共享元素<code>View</code>的共享名称<code>transitionName</code>必须一一对应。<br><img src="http://upload-images.jianshu.io/upload_images/1801191-30545fbee6c38a0e.gif?imageMogr2/auto-orient/strip" alt="共享元素转场动画效果"></p>
<hr>
<p>源码：<a href="https://github.com/xiaoyanger0825/AnimationSummary" target="_blank" rel="noopener">https://github.com/xiaoyanger0825/AnimationSummary</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/17/Android实现底部对话框BottomDialog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小样儿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/17/Android实现底部对话框BottomDialog/" itemprop="url">Android实现底部对话框BottomDialog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T18:06:21+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目上需要实现一个底部对话框，要实现这样的功能其实很简单，先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void show1() &#123;</span><br><span class="line">    Dialog bottomDialog = new Dialog(this, R.style.BottomDialog);</span><br><span class="line">    View contentView = LayoutInflater.from(this).inflate(R.layout.dialog_content_normal, null);</span><br><span class="line">    bottomDialog.setContentView(contentView);</span><br><span class="line">    ViewGroup.LayoutParams layoutParams = contentView.getLayoutParams();</span><br><span class="line">    layoutParams.width = getResources().getDisplayMetrics().widthPixels;</span><br><span class="line">    contentView.setLayoutParams(layoutParams);</span><br><span class="line">    bottomDialog.getWindow().setGravity(Gravity.BOTTOM);</span><br><span class="line">    bottomDialog.getWindow().setWindowAnimations(R.style.BottomDialog_Animation);</span><br><span class="line">    bottomDialog.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对话框的样式style：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;BottomDialog&quot; parent=&quot;@style/Base.V7.Theme.AppCompat.Light.Dialog&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>在对话框中的按钮需要MD风格的波纹效果的话，对话框的<code>style</code>的<code>parent</code>需要设定<code>parent=&quot;@style/Base.V7.Theme.AppCompat.Light.Dialog&quot;</code>，否则没有效果。同时将对话框所在<code>window</code>的标题去掉。<code>android:windowBackground</code>属性一定要设置成透明，否则自定义形状的对话框背景就是默认的白色了。如果不设置为透明，比如我们通常要设置的圆角对话框就没有效果。</p>
<p>对话框显示时从底部进入，关闭时从底部滑出。动画样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;BottomDialog.Animation&quot; parent=&quot;Animation.AppCompat.Dialog&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@anim/translate_dialog_in&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowExitAnimation&quot;&gt;@anim/translate_dialog_out&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>tranlate_dialog_in.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">           android:duration=&quot;300&quot;</span><br><span class="line">           android:fromXDelta=&quot;0&quot;</span><br><span class="line">           android:fromYDelta=&quot;100%&quot;</span><br><span class="line">           android:toXDelta=&quot;0&quot;</span><br><span class="line">           android:toYDelta=&quot;0&quot;&gt;</span><br><span class="line">&lt;/translate&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>tranlate_dialog_out.xml</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">           android:duration=&quot;300&quot;</span><br><span class="line">           android:fromXDelta=&quot;0&quot;</span><br><span class="line">           android:fromYDelta=&quot;0&quot;</span><br><span class="line">           android:toXDelta=&quot;0&quot;</span><br><span class="line">           android:toYDelta=&quot;100%&quot;&gt;</span><br><span class="line">&lt;/translate&gt;</span><br></pre></td></tr></table></figure></p>
<p>实现底部对话框的原理就是修改对话框的内容布局<code>contentView</code>的参数，使它的宽度刚好等于屏幕的宽度，并且设置对话框所在<code>Window</code>的<code>gravity</code>属性为<code>bottom</code>。</p>
<p>需要注意的是，上面代码中需要在调用<code>contentView.getLayoutParams()</code>需要在<code>setContentView</code>方法后，否则获取到的<code>LayoutParams</code>为<code>null</code>，当然也可以自己<code>new</code>一个<code>LayoutParams</code>设置给<code>contentView</code>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-0b67a467df9098be.gif?imageMogr2/auto-orient/strip" alt="底部对话框效果"></p>
<p>如果是要实现底部圆角对话框，原理也相似，只需要给<code>contentView</code>添加一个圆角的背景<code>shape</code>，并减小<code>contentView</code>的宽度给左右两边留一定的距离，同时给底部设置边距。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void show2() &#123;</span><br><span class="line">    Dialog bottomDialog = new Dialog(this, R.style.BottomDialog);</span><br><span class="line">    View contentView = LayoutInflater.from(this).inflate(R.layout.dialog_content_circle, null);</span><br><span class="line">    bottomDialog.setContentView(contentView);</span><br><span class="line">    ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) contentView.getLayoutParams();</span><br><span class="line">    params.width = getResources().getDisplayMetrics().widthPixels - DensityUtil.dp2px(this, 16f);</span><br><span class="line">    params.bottomMargin = DensityUtil.dp2px(this, 8f);</span><br><span class="line">    contentView.setLayoutParams(params);</span><br><span class="line">    bottomDialog.getWindow().setGravity(Gravity.BOTTOM);</span><br><span class="line">    bottomDialog.getWindow().setWindowAnimations(R.style.BottomDialog_Animation);</span><br><span class="line">    bottomDialog.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-5927bd366aad6070.gif?imageMogr2/auto-orient/strip" alt="底部圆角对话框效果"><br>源码：<a href="https://github.com/xiaoyanger0825/BottomDialog" target="_blank" rel="noopener">https://github.com/xiaoyanger0825/BottomDialog</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="xiaoyanger0825" />
            
              <p class="site-author-name" itemprop="name">xiaoyanger0825</p>
              <p class="site-description motion-element" itemprop="description">喜欢NBA的Android码农</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/xiaoyanger0825" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="xiaojianjun0825@aliyun.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoyanger0825</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
