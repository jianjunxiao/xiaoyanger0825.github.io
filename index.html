<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="喜欢NBA的Android码农">
<meta property="og:type" content="website">
<meta property="og:title" content="xiaoyanger0825">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="xiaoyanger0825">
<meta property="og:description" content="喜欢NBA的Android码农">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xiaoyanger0825">
<meta name="twitter:description" content="喜欢NBA的Android码农">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>xiaoyanger0825</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiaoyanger0825</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/21/Java集合框架-——-HashSet、LinkedHashSet源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/21/Java集合框架-——-HashSet、LinkedHashSet源码分析/" itemprop="url">Java集合框架 —— HashSet、LinkedHashSet源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T16:06:30+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>HashSet</code>实现了<code>Set</code>接口，它的底层是由<code>HashMap</code>来支持的。<code>HashSet</code>的元素实际上是存储在底层<code>HashMap</code>的<code>key</code>上的。由于<code>HashMap</code>的无序不重复特性，<code>HashSet</code>存储的元素也是无序的，并且元素也不能重复，同时也只允许存储一个<code>null</code>元素。</p>
<h4 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a>HashSet源码分析</h4><p>主要属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// HashSet底层map</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">// 虚拟对象</span><br><span class="line">private static final Object PRESENT = new Object();</span><br></pre></td></tr></table></figure></p>
<p><code>HashSet</code>是通过<code>HashMap</code>来保存元素，由于只需要在<code>key</code>中保存，所以采用虚拟对象<code>PRESENT</code>对应<code>map</code>中插入<code>key-value</code>的<code>value</code>值的引用。每次向<code>map</code>中添加元素时，键值对对应的<code>value</code>都是<code>PRESENT</code>。</p>
<p>构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 默认无参构造</span><br><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">// 根据已有集合元素来构造HashSet</span><br><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line">// 给定初始容量</span><br><span class="line">public HashSet(int initialCapacity) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">// 给定初始容量和加载因子</span><br><span class="line">public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line">// 这个构造函数外部不能调用，供LinkedHashSet复写</span><br><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数都是初始<code>map</code>，以便加入元素的时候存储。</p>
<p>重要方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 集合大小</span><br><span class="line">public int size() &#123;</span><br><span class="line">    return map.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 集合是否为空</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    return map.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移除元素</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 清空集合</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 集合中是否有元素o</span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HashSet</code>的增删改查，同时直接操作<code>map</code>来完成的，代码都非常简单。</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p><code>LinkedHashSet</code>继承自<code>HashSet</code>，它的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashSet() &#123;</span><br><span class="line">    super(16, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">    super(initialCapacity, .75f, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>LinkedHashSet</code>构造方法调用了父类<code>HashSet</code>的这个构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// LinkedHashSet复写，初始化LinkedHashMap</span><br><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，它的底层是一个<code>LinkedHashMap</code>，元素的所有操作都是由<code>LinkedHashMap</code>来维护。<code>LinkedHashSet</code>与<code>HashSet</code>的区别和<code>LinkedHashMap</code>与<code>HashMap</code>的区别一样，<code>LinkedHashMap</code>和<code>LinkedHashSet</code>是有序的，内部由双向链表来记录顺序，而<code>HashMap</code>和<code>HashSet</code>都是无序的。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>对于<code>HashSet/LinkedHashSet</code>，只要阅读过<code>HashMap/LinkedHashMap</code>的源码，基本上就能完全了解它的实现原理。<code>HashSet/LinkedHashSet</code>中数据的存入、删除、访问都是都是直接操作内部的<code>HashMap</code>，可以说<code>HashSet/LinkedHashSet</code>是在<code>HashMap/LinkedHashMap</code>的基础上加了一层壳。他们唯一的区别就是<code>HashSet/LinkedHashSet</code>保存的元素时单个的数据或对象，而<code>HashMap/LinkedHashMap</code>保存的元素时键值对。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/21/Java集合框架-——-LinkedHashMap源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/21/Java集合框架-——-LinkedHashMap源码分析/" itemprop="url">Java集合框架 —— LinkedHashMap源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T11:15:47+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们知道<code>HashMap</code>底层是采用数组+单向线性链表/红黑树来实现的，<code>HashMap</code>在扩容或者链表与红黑树转换过程时可能会改变元素的位置和顺序。如果需要保存元素存入或访问的先后顺序，那就需要采用<code>LinkedHashMap</code>了。</p>
<h4 id="LinkedHashMap结构"><a href="#LinkedHashMap结构" class="headerlink" title="LinkedHashMap结构"></a>LinkedHashMap结构</h4><p><code>LinkedHashMap</code>继承自<code>HashMap</code>，它的所有操作和<code>HashMap</code>类似，底层结构也和<code>HashMap</code>一样，只不过为了维护元素的存入/访问顺序，增加了一个双向链表。</p>
<p><img src="https://i.imgur.com/7q4Qif4.png" alt="LinkedHashMap结构图"></p>
<p><code>LinkedHashMap</code>由数组、单向线性链表、红黑树、双向线性链表组成。如上图：灰色区域为数组，蓝色节点和蓝色箭头为单向链表的引用关系，绿色节点和绿色箭头为红黑树的引用关系，节点中的数字依次表示元素的存入/访问顺序，由橙色的双向箭头表示双向链表的引用关系。</p>
<p>注：在JDK1.7及之前<code>HashMap</code>中没有红黑树，<code>LinkedHashMap中</code>也不存在红黑树。另在JDK1.6及之前，HashMap中的链表为单向环形链表，<code>LinkedHashMap中</code>中的单向链表和双向链表都是环形链表。在JDK1.8，<code>LinkedHashMap</code>中可能会存在红黑树，同时单向链表和双向链表都是线性的。本文是基于JDK1.8来分析的。</p>
<h4 id="LinkedHashMap源码分析"><a href="#LinkedHashMap源码分析" class="headerlink" title="LinkedHashMap源码分析"></a>LinkedHashMap源码分析</h4><p>基本属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;	// 双向链表头节点</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;	// 双向链表尾节点</span><br><span class="line">final boolean accessOrder;					// 是否按照访问顺序排序</span><br></pre></td></tr></table></figure></p>
<p>head和tail分别记录了双向链表的头节点和尾节点，遍历时通过<code>head</code>或<code>tail</code>就可以按照存入/访问的顺序来取数据。</p>
<p><code>accessOrder</code>用以表示<code>LinkedHashMap</code>是否按照访问顺序来排序，为<code>true</code>的话表示按照访问顺序排序，为<code>false</code>表示按照存入顺序排序，默认为<code>false</code>。</p>
<p>构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 无参构造</span><br><span class="line">public LinkedHashMap() &#123;</span><br><span class="line">    super();</span><br><span class="line">    accessOrder = false;</span><br><span class="line">&#125;</span><br><span class="line">// 给定初始容量</span><br><span class="line">public LinkedHashMap(int initialCapacity) &#123;</span><br><span class="line">    super(initialCapacity);</span><br><span class="line">    accessOrder = false;</span><br><span class="line">&#125;</span><br><span class="line">// 给定初始容量和加载因子</span><br><span class="line">public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = false;</span><br><span class="line">&#125;</span><br><span class="line">// 给定初始容量、加载因子、是否按访问先后排序</span><br><span class="line">public LinkedHashMap(int initialCapacity,</span><br><span class="line">                     float loadFactor,</span><br><span class="line">                     boolean accessOrder) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor);</span><br><span class="line">    this.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数都是调用父类<code>HashMap</code>的构造函数。前3个都默认<code>accessOrder</code>为<code>false</code>，<code>LinkedHashMap</code>内部按照存入顺序排序。最后一个构造函数可以指定<code>accessOrder</code>的值。</p>
<p>增：</p>
<p><code>LinkedHashMap</code>添加数据要调用了父类的<code>HashMap</code>的<code>put</code>方法，在<code>HashMap</code>的源码中，<code>put</code>方法存入元素后，调用了<code>afterNodeAccess</code>和<code>afterNodeInsertion</code>方法，这两个方法在<code>HashMap</code>中都是空方法，<code>LinkedHashMap</code>实现了这两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; </span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">	// 如果按照访问顺序排序，并且添加的元素e不是双向链表的尾节点</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = null;</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a;</span><br><span class="line">        else</span><br><span class="line">            b.after = a;</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b;</span><br><span class="line">        else</span><br><span class="line">            last = b;</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>afterNodeAccess</code>方法的逻辑就是将当前节点<code>e</code>移动到双向链表的尾部。每次<code>LinkedHashMap</code>中有元素被访问时，就会按照访问先后来排序，先访问的在双向链表中靠前，越后访问的越接近尾部。当然只有当<code>accessOrder</code>为<code>true</code>时，才会执行这个操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>afterNodeInsertion</code>方法意思是<code>evict</code>为<code>true</code>时删除双向链表的头节点。</p>
<p>通过<code>afterNodeAccess</code>和<code>afterNodeInsertion</code>这两个方法，如果当<code>LinkedHashMap</code>的容量达到一定量时，需要保存它的<code>size</code>不变，那么每次添加一个元素到双向链表的尾部，就要删除一个双向链表头部的元素，这相当于实现了<code>LruCache</code>的策略。</p>
<p>删：</p>
<p>删除元素同样也是调用了<code>HashMap</code>的<code>remove</code>方法，在<code>remove</code>方法中，调用了<code>afterNodeRemoval</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = null;</span><br><span class="line">    if (b == null)</span><br><span class="line">        head = a;</span><br><span class="line">    else</span><br><span class="line">        b.after = a;</span><br><span class="line">    if (a == null)</span><br><span class="line">        tail = b;</span><br><span class="line">    else</span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>afterNodeRemoval</code>方法就是将<code>e</code>节点从双向链表中删除，更改<code>e</code>前后节点引用关系，使之重新连成完整的双向链表。</p>
<p>改：</p>
<p><code>LinkedHashMap</code>更改元素的<code>value</code>值，仍是调用<code>put</code>方法，涉及到的逻辑可以看上面的<code>afterNodeAccess</code>和<code>afterNodeInsertion</code>这两个方法。</p>
<p>查：</p>
<p><code>LinkedHashMap</code>自己实现了<code>get</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑非常简单，直接调用<code>HashMap</code>的<code>getNode</code>方法，如果需要按照访问先后排序，调用<code>afterNodeAccess</code>更新双向链表排序。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>LinkedHashMap</code>继承了<code>HashMap</code>的所有特性，唯一的区别就是<code>LinkedHashMap</code>是一个有序的映射集合，而<code>HashMap</code>则是无序的。<code>LinkedHashMap</code>实现排序的原理就是再内部增加了一个双向链表来记录元素的存入/访问顺序。<code>LinkedHashMap</code>内部是记录的是存入还是访问顺序取决于关键属性<code>accessOrder</code>，默认是按存入顺序记录。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/18/Java集合框架-——-HashMap源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/18/Java集合框架-——-HashMap源码分析/" itemprop="url">Java集合框架 —— HashMap源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-18T18:11:14+08:00">
                2017-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>HashMap</code>是基于<code>Map</code>的键值对映射表，底层是通过数组、链表、红黑树（JDK1.8加入）来实现的。</p>
<h4 id="HashMap结构"><a href="#HashMap结构" class="headerlink" title="HashMap结构"></a>HashMap结构</h4><p><code>HashMap</code>中存储元素，是将<code>key</code>和<code>value</code>封装成了一个<code>Node</code>，先以一个<code>Node</code>数组的来存储，通过<code>key</code>的<code>hashCode</code>来计算<code>hash</code>值，根据<code>hash</code>值和<code>HashMap</code>的大小确定存入元素在数组中的位置。当<code>hashCode</code>相同时，即产生了相同的数组索引位置，那么就会通过单向链表的形式来继续存储。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 省略部分代码...		</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>HashMap</code>中所有的映射都保存在节点<code>Node</code>中，同时为了解决发生<code>hash</code>碰撞的冲突，节点可以持有下一个节点的引用，以形成一个单向链表。</p>
<p><img src="https://i.imgur.com/ufoYPo0.png" alt="HashMap结构图（JDK1.7及之前）"></p>
<p>在JDK1.8，<code>HashMap</code>又做了一些改动，当数组<code>table</code>某个索引位置的上链表的长度大于8的话，则会将链表转化为红黑树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 省略部分代码...		</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样地，映射的key-value就保存在<code>TreeNode</code>中。<code>parent</code>、<code>left</code>、<code>right</code>持有相应节点的引用形成红黑树。</p>
<p><img src="https://i.imgur.com/dWu8QEO.png" alt="HashMap结构图（JDK1.8）"></p>
<h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><p>主要属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table; // 数组</span><br><span class="line">transient int size; 		 // 大小</span><br><span class="line">int threshold				 // 扩容阈值</span><br><span class="line">final float loadFactor; 	 // 加载因子，默认值为0.75</span><br></pre></td></tr></table></figure></p>
<p>构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 使用默认的初始容量和加载因子</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指定初始容量，使用默认的加载因子</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用现有的Map来构造一个新的HashMap</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据自定义的初始容量和加载因子来构造HashMap</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    &#125; else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">        initialCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数主要是设置<code>HashMap</code>的初始容量，以及扩容的加载因子。<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>构造函数根据已有的映射来构造新的<code>HashMap</code>，它同样采用的默认的加载因子，并将<code>m</code>中的元素添加到新构造的<code>HashMap</code>中。</p>
<p>数据存放：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    putMapEntries(m, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">    int s = m.size();</span><br><span class="line">    if (s &gt; 0) &#123;</span><br><span class="line">        if (table == null) &#123; // pre-size</span><br><span class="line">            float ft = ((float)s / loadFactor) + 1.0F;</span><br><span class="line">            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            if (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, false, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>putAll</code>方法直接调用<code>putMapEntries</code>。<code>putMapEntries</code>方法中先根据已有的<code>Map</code>中的元素数量对新构造的<code>HashMap</code>进行扩容，然后遍历旧的<code>Map</code>，取出元素存放到新的<code>HashMap</code>中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 存放key-value</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据key的hashCode来计算hash值</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">	// table为null的话，进行初始化</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">	// 根据（n-1）&amp;hash来计算出元素在数组中的位置i</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">		// 如果数组中该位置没有元素，即tab[i]==null,则直接构建Node存放在该位置</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123; // tab[i]不为null</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">		// 如果数组中已有的节点tab[i]与需要新存入的元素的key相同，则直接替换掉tab[i]</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">			// 如果tab[i]为红黑树节点，则直接存入红黑树</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">			// tab[i]为链表的第一个节点，遍历链表，将新的节点加入到链表的末尾</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">					// 如果链表的长度大于阈值，则将链表转换为红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">				// 如果链表中存在与新加入的元素key相同，则直接替换掉</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">	// 添加完成后，检查是否需要扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>put</code>方法的主要逻辑：根据添加节点的<code>hash</code>值计算计算它在数组中的位置<code>i</code>，判断<code>tab[i]</code>是否为空，为空则直接加入；不为空的话，需要判断该节点的<code>key</code>是否与新加入的节点的<code>key</code>相同，相同的话直接替换；如果不同则需要判断<code>tab[i]</code>节点是否是红黑树节点，如果是红黑树节点，则直接加入到红黑树中；如果不是红黑树节点，那肯定就是链表的第一个节点了，遍历链表，在遍历的过程中还需要判断是否与链表中已有节点的<code>key</code>相同，如果相同，同样直接替换掉，都不同的话就直接添加到链表的末尾。并且呢，加入链表后还需要判断链表的长度是否超过了阈值8，超过了的话，需要将链表转换为红黑树。</p>
<p><code>HashMap</code>在添加数据的时候，会判断当前数据量是否超过设定的阈值，如果超过的话会进行扩容，在扩容过程中会将已添加的数据进行重新添加，以致原来添加元素的顺序和位置都改变了，所以<code>HashMap</code>不能保证元素的存入取出顺序。</p>
<p>删除数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 根据key删除数据</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据key-value删除数据</span><br><span class="line">@Override</span><br><span class="line">public boolean remove(Object key, Object value) &#123;</span><br><span class="line">    return removeNode(hash(key), key, value, true, true) != null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除节点</span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                           boolean matchValue, boolean movable) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">	// 根据hash值得到数组索引位置的节点p</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">		// p节点的key与需要删除的节点的key相同的话，则说明p就是需要删除的节点</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;	// 赋值给node</span><br><span class="line">        else if ((e = p.next) != null) &#123;</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">				// p节点为红黑树节点，从红黑树中获取匹配的删除节点</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">				// p节点为链表的第一个节点，遍历链表，找到匹配的删除节点</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		// 匹配的删除节点node不为null的话，删除node</span><br><span class="line">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">				// 从红黑树中删除</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">            else if (node == p)</span><br><span class="line">				// 从数组中删除</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            else</span><br><span class="line">				// 从链表中删除</span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>remove</code>的逻辑和加入元素的逻辑相似，依次从数组、红黑树、链表中找到匹配的删除节点来删除。</p>
<p><code>clear</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        for (int i = 0; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>clear</code>方法要简单些，直接遍历数组tab，将数组中所有元素都置空即可。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>对于<code>HashMap</code>，我们只要知道了它的底层结构，要理解它的实现原理还是非常简单。在JDK1.8之后，加入了红黑树的结构，使<code>HashMap</code>的效率比之前的版本又优化了很多，关于链表转化为红黑树，以及红黑树转链表的具体实现等细节后续再做分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/Java集合框架-——-LinkedList源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/Java集合框架-——-LinkedList源码分析/" itemprop="url">Java集合框架 —— LinkedList源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T17:28:44+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JDK1.7之前，<code>LinkedList</code>是采用双向环形链表来实现的，在1.7及之后，Oracle将<code>LinkedList</code>做了优化，将环形链表改成了线性链表。本文对于<code>LinkedList</code>的源码分析基于JDK1.8。</p>
<p><code>LinkedList</code>既然是通过一个双向线性链表来实现，那么肯定就能够很轻易的找到链表的第一个节点和最后一个节点，在源码中可以看到有这两个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;E&gt; first; // 链表第一个节点</span><br><span class="line">transient Node&lt;E&gt; last;  // 链表最后一个节点</span><br></pre></td></tr></table></figure></p>
<p>先来看一下什么是节点<code>Node</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节点<code>Node</code>中有三个成员：</p>
<ul>
<li>item ： 存储的元素</li>
<li>next ： 下一个节点</li>
<li>prev ： 上一个节点</li>
</ul>
<p>节点中保存有需要存储的元素，同时持有上一个节点和下一个节点的引用，各个节点依次持有前后节点的引用就形成了一个链，这样，当我们需要查找链中某一个节点保存的元素时，只需要通过第一个节点或者最后一个节点依次查找，就可以找到我们需要的节点。</p>
<p>需要注意的是，在JDK1.7及之后，第一个节点<code>first</code>的前一个节点<code>prev</code>为<code>null</code>，最后一个节点<code>last</code>的后一个节点<code>next</code>也为<code>null</code>。而在JDK1.6及之前，头节点<code>header</code>是一个不保存元素的节点，<code>header</code>的下一个节点<code>next</code>是第一个元素节点，而<code>header</code>的上一个节点是最后一个元素节点，这样使得它形成一个环形的双向链表。</p>
<p><img src="https://i.imgur.com/SuHIva6.png" alt="LinkedList节点结构图1（JDK1.7及以后）"><br><img src="https://i.imgur.com/QAwP1zC.png" alt="LinkedList节点结构图2（JDK1.6及以前）"></p>
<p><code>LinkedList</code>的构造函数有两个，一个无参，另一个可以传入一个集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看下<code>addAll</code>方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">	// 检查是否越界</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">	// 将集合c转化为数组a</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    if (numNew == 0)</span><br><span class="line">        return false;</span><br><span class="line">	// pred为插入元素位置点前一个节点，succ为插入元素位置的后一个节点</span><br><span class="line">    Node&lt;E&gt; pred, succ;     </span><br><span class="line">    if (index == size) &#123;	// index==size的话，在链表的末尾添加元素</span><br><span class="line">        succ = null;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; else &#123;				// 否则的话，从链表中间加入</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">	// 遍历需要加入的元素数组a</span><br><span class="line">    for (Object o : a) &#123;   </span><br><span class="line">		// 通过元素o构造一个节点Node</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred == null) // 插入位置的前一个节点为null，说明需要插入的是first节点</span><br><span class="line">            first = newNode;</span><br><span class="line">        else		    // 插入位置的前一个节点不为null，即从链表中或链表末尾插入</span><br><span class="line">			// 将要插入的节点复制给插入位置的上一个节点的next</span><br><span class="line">            pred.next = newNode;</span><br><span class="line">		// 将newNode赋值给下个需要插入的节点的pred</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    if (succ == null) &#123; // succ为null，说明是从末尾添加的元素，将添加的最后一个元素赋值给last</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; else &#123;			// 从链表中某个位置添加的，重新连接上添加元素时断开的引用链</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line">	// 更新链表的大小</span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造方法中调用<code>addAll</code>方法，相当于是向一个空链表中添加集合<code>c</code>中的元素。</p>
<p>如果是在已有元素的链表中调用<code>addAll</code>方法来添加元素的话，就需要判断指定的添加位置<code>index</code>是否越界，如果越界会抛出异常；如果没有越界，根据添加的位置<code>index</code>，断开链表中<code>index</code>位置的节点前后的引用，加入新元素，重新连上断开位置的前后节点的引用。过程如下图：</p>
<p><img src="https://i.imgur.com/tTw37wG.png" alt="LinkedList加入元素1"><br><img src="https://i.imgur.com/h1JzRfl.png" alt="LinkedList加入元素2"></p>
<p><code>add</code>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接就调用了<code>linkLast</code>方法，说明默认的<code>add</code>方法是直接将元素添加到已有的链表的末尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新加入元素的节点赋值给<code>last</code>节点，然后判断了一下加入之前的<code>last</code>节点是否为空，为空的话，说明链表中没有元素，新加入的就是链表的<code>first</code>节点；不为空直接将之前的最后一个节点的<code>next</code>引用添加的节点即可。</p>
<p>还有一个add方法，指定了添加位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    if (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要先判断是否越界，再看添加的位置是否在已有链表的末尾，如果在末尾就直接添加到末尾，不在末尾的话，调用linkBefore添加到index位置的节点之前。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">    // assert succ != null;</span><br><span class="line">    final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    if (pred == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pred</code>为<code>null</code>的话，说明<code>succ</code>是添加元素前链表的<code>first</code>节点，加入元素<code>e</code>，更新<code>first</code>节点，并更改引用链。</p>
<p><code>addFirst</code>和<code>addLast</code>方法中分别调用了<code>linkFirst</code>方法和<code>linkLast</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    if (f == null)</span><br><span class="line">        last = newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>linkFirst/linkLast</code>方法即是将新节点添加到链表的头部或者尾部，更新链表的<code>prev</code>和<code>next</code>引用。</p>
<p><code>remove</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (x.item == null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不管需要移除的元素<code>O</code>是否为空，都是遍历后调用<code>unlink</code>方法来删除节点，继续看<code>unlink</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    // assert x != null;</span><br><span class="line">    final E element = x.item;</span><br><span class="line">    final Node&lt;E&gt; next = x.next;</span><br><span class="line">    final Node&lt;E&gt; prev = x.prev;</span><br><span class="line">	</span><br><span class="line">    if (prev == null) &#123;</span><br><span class="line">		// 如果prev为null的话，那么删除的是first节点，将next指定为删除后的first节点</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">		// prev不为null，将prev的next引用指向next，并解除x元素对prev的引用</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (next == null) &#123;</span><br><span class="line">		// 如果next为null，那么删除的是last节点，将prev指定为删除后的last节点</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">		// next不为null，将next的prev引用指向prev，并解除x的next引用</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = null;</span><br><span class="line">    &#125;</span><br><span class="line">	// 置空x节点中的元素</span><br><span class="line">    x.item = null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>removeFirst</code>和<code>removeLast</code>方法同样是直接调用了<code>unlinkFirst</code>和<code>unlinkLast</code>，实现和<code>unlink</code>差不多，不做过多解释。</p>
<p><code>set</code>方法，<code>set</code>方法即修改链表中指定位置的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    return oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>找到指定位置的节点<code>x</code>，更改该节点的<code>item</code>属性就行了。</p>
<p>看下获取节点的<code>node</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">	</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123; // 靠近头部</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;				// 靠近尾部</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断位置<code>index</code>是靠近头部还是尾部，靠近头部，则从<code>first</code>节点往后遍历，靠近尾部则从<code>last</code>节点往前遍历，这种方式可以使得链表查找的时候遍历次数不会超过链表长度的一半，从而提升查找效率。</p>
<p><code>get</code>、<code>getFirst</code>、<code>getLast</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    if (f == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E getLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    if (l == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getFirst</code>和<code>getLast</code>直接后去<code>first</code>和<code>last</code>节点中的元素值，<code>get</code>方法则直接调用了<code>node</code>方法，不再解释。</p>
<p><code>LinkedList</code>源码中的其他方法不再分析了，实现都很容易理解。从<code>LinkedList</code>的增、删、改、查等方法的实现逻辑可以看出来，<code>LinkedList</code>的增和删效率相对于改和查要高，因为每次修改和查询都要从链表的头节点或尾节点开始遍历，而增加和删除，只需要在制定位置断开节点引用，添加和删除元素后，重新连上引用链即可。所以，<code>LinkedList</code>适合用在添加和删除比较频繁，而修改和查询较少的情况下。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/13/Java集合框架-——-ArrayList源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/13/Java集合框架-——-ArrayList源码分析/" itemprop="url">Java集合框架 —— ArrayList源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-13T18:11:00+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>ArrayList</code>可以说是在Java开发中最常用的集合容器了，今天就来分析一下<code>ArrayList</code>的源码，可以更加深入的理解<code>ArrayList</code>实现原理。</p>
<p><code>ArrayList</code>的成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 初始容量:10</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">// 空数组，没有元素数据</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">// 空数组，默认容量为空，没有元素数据</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">// 数组，用来存储ArrayList的元素</span><br><span class="line">transient Object[] elementData;</span><br><span class="line">// size为ArrayList的大小，在elementData不为空数组的情况下，size是小于elementData.length的</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure></p>
<p>根据<code>elementData</code>也能看出来，<code>ArrayList</code>的内部是通过数组来实现的，<code>ArrayList</code>对元素的增删改查实际上都是对数组的操作。</p>
<p><code>ArrayList</code>的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    if ((size = elementData.length) != 0) &#123;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // replace with empty array.</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造<code>ArrayList</code>时，可以指定容器的初始容量<code>initialCapacity</code>，构造一个给定初始大小的数组作为数据集；使用无参构造时，则默认容量为空的数组作为初始数据集；也可以使用其他任意的集合<code>Collection</code>作为构造参数，可以看到，源码中就是直接将集合<code>c</code>转换数组来作为数据集（如果数据集是非<code>Object</code>数组，比如多维数组，则将元素拷贝到数据集数组中）。<code>ArrayList</code>的构造实际上就是对其内部数组的初始化。</p>
<p><code>add</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">	// 确保当前数据集数组能够放得下新加入的元素</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">	// 将列表大小size自增1，并在数据集数组中放入元素e</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">	// 检查新加入的位置index是否越界</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">	// 确保当前数据集数组能够放得下新加入的元素，如果需要扩容的话就扩容</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">	// 将index位置及后面的元素都向后移动一位</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                     size - index);</span><br><span class="line">	// 将index位置的元素设置为新建如的element</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在添加元素时，如果不指定加入的位置，会添加到内部数组中已有元素的最后一位，也就是添加到了<code>ArrayList</code>的末尾。如果指定了添加位置index，判断index是否越界，是否需要扩容，最后移动index位置后的元素，并将index位置设置为新添加的元素。</p>
<p>需要注意的是，添加的元素并没有判空，所以<code>ArrayList</code>中的元素是可以为<code>null</code>的。</p>
<p>在add方法中，都调用了<code>ensureCapacityInternal(int minCapacity)</code>这个方法来确保数据集数组能够放得下新的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">	// 如果添加新元素需要的最小容量大于数组的长度，就需要扩容</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看下扩容的方法<code>grow(int minCapacity)</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">	// 扩展至新的容量newCapacity为旧的容量的1.5倍</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">	// 将之前的数组中的元素复制到扩展后的新的数组中</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组扩容的过程，实际上是新建了一个需要扩容的长度的数组，然后将原素组中的元素拷贝到这个新建的数组中，新的数组指定为<code>ArrayList</code>内部数据集数组。</p>
<p>总结：ArrayList在添加元素时，首先会判断添加的位置是否在内部数组中越界，如果越界，抛出异常；如果没有越界，则判断数组能否放得下新添加的元素，如果放得下，则直接存放到数组中；如果放不下，则将数组扩容，扩容后再存放到数组中。</p>
<p><code>remove</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">	// 检查越界</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">	// 需要移除的元素</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">	// 需要移动位置的元素的数量</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">	// 将需要移除元素的位置后的所有元素复制到index位置开始后的numMoved个位置</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">	// size减1，并将之前的最后一个位置元素置空</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>remove</code>还有一个重载的方法，是移除给定的元素，它的实现就是遍历数组，找到元素的索引值，然后调用<code>remove(int index)</code>方法，根据索引值去删除。</p>
<p>总结：<code>ArrayList</code>在删除元素时，根据删除的索引值判断是否越界，如果越界，抛出异常；如果没有越界，取出要删除的元素，然后将这个元素后面所有的元素向前移动一位。</p>
<p><code>set</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>set方法即修改列表中指定位置的元素值。它的实现非常简单：直接修改数组指定位置的值。</p>
<p><code>get</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>get</code>方法实现非常简单只需要堆获取位置判断是否越界，然后直接从数组中取值即可。</p>
<p>从上面分析的源码中可以看出，ArrayList的实现就是对数组的操作，在添加和删除元素的时候，会涉及到数组的扩容和数组元素位置的移动，相对查询和修改元素要复杂一些，所以ArrayList适合用在查询和修改比较频繁，而添加和删除较少的情况下。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/10/Java虚拟机-——-类的加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/Java虚拟机-——-类的加载机制/" itemprop="url">Java虚拟机 —— 类的加载机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T17:43:48+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道class文件中存储了类的描述信息和各种细节的数据，在运行Java程序时，虚拟机需要先将类的这些数据加载到内存中，并经过校验、转换、解析和初始化过后，最终形成可以直接使用的Java类型。</p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。<br><img src="http://i.imgur.com/2uatooQ.png" alt="类的生命周期"></p>
<p>类的加载机制实际上就是类的生命周期中加载、验证、准备、解析、初始化5个过程。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类的加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>通过全限定名来获取二进制流可以有很多种方式，比如从JAR、EAR、WAR文件包中读取，从网络获取，也可以由其他文件来生成（jsp文件生成对应的Servlet类），甚至还可以通过运行时动态生成（Java动态代理）。</p>
<p>相比类加载过程的其他阶段，加载阶段是可控性最强的。因为开发者既可以利用系统提供的启动类加载器来完成，也可以通过自定义类加载去完成（重写<code>loadClass</code>方法，控制字节流的获取方式）。</p>
<p>关于类加载器的详细介绍将放在文章最后。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中。然后在内存中实例化一个<code>java.lang.Class</code>类的对象，这样就可以通过这个对象来访问方法区中的这些数据。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<ul>
<li>文件格式验证： 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的<br>3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</li>
<li>元数据验证： 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。这个主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</li>
<li>字节码验证： 对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</li>
<li>符号验证： 对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，这个阶段发生在将符号引用转化为直接引用的时候（解析阶段中发生），目的是确保解析动作能正常执行。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量（静态变量）分配内存并设置初始值的阶段，这些类变量所使用的内存都将在方法区中进行分配。</p>
<p>这里有两点需要注意：</p>
<ol>
<li>成员变量不是在这里分配内存的，成员变量是在类实例化对象的时候在堆中分配的。</li>
<li>这里设置初始值是指类型的零值（比如0，null，false等），而不是代码中被显示的赋予的值。</li>
</ol>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public int number = 111;</span><br><span class="line">    public static int sNumber = 111; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>成员变量<code>number</code>在这个阶段就不会进行内存分配和初始化。而类变量<code>sNunber</code>会在方法区中分配内存，并<strong>设置为int类型的零0而不是111</strong>，赋值为111是在初始化阶段才会执行。<br><img src="http://i.imgur.com/9bEPBkZ.png" alt="Java基本数据类型和引用数据类型零值"><br>但是呢，如果类变量如果是被final修饰，为静态常量，那么在准备阶段也会在方法区中分配内存，并且将其值设置为显示赋予的值。</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static final int NUMBER = 111; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，就会在准备阶段将<code>NUMBER</code>的值设置为111。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用： 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li>直接引用： 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
</ul>
<p>解析动作主要就是在常量池中寻找类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符等7类符号引用，把这些符号引用替换为直接引用。下面主要介绍下类或接口、字段、类方法、接口方法的解析：</p>
<ol>
<li>类或接口解析： 假设当前的类<code>A</code>通过符号X引用了类<code>B</code>，虚拟机会把代表类<code>B</code>的全限定名传递给<code>A</code>的类加载器去加载<code>B</code>，<code>B</code>经过加载、验证、准备过程，在解析过程又可能会触发<code>B</code>引用的其他的类的加载过程，相当于一个类引用链的递归加载过程，整个过程只要不出现异常，<code>B</code>的就是一个加载成功的类或接口了，也就是可以获取到代表<code>B</code>的<code>java.lang.Class</code>对象。在验证了<code>A</code>具备对<code>B</code>的访问权限后，就将符号引用X替换为<code>B</code>的直接引用。</li>
<li>字段解析： 解析未被解析过的字段，要先解析字段所属的类或接口的符号引用。如果类本身就包含了简单的名称和字段描述与目标字段相匹配，就直接返回这个字段引用；如果实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段；如果是继承自其他类的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。</li>
<li>类方法解析：类方法解析和字段解析的方式类似，也是依据继承和实现关系从小到上搜索，只不过是先搜索类，后搜索接口。如果有简单名称和字段描述符都与目标相匹配的字段，就返回字段引用。</li>
<li>接口的方法解析： 与类方法解析类似，从小到上搜索接口（接口没有父类，只可能有父接口）。如果存在简单名称和字段描述符都与目标相匹配的字段，就返回字段引用。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类的初始化类加载过程的最后一步，在前面的过中，除了在加载阶段开发者可以自定义加载器之外，其余的动作都是完全有虚拟机主导和控制完成。到了初始化阶段，才真正开始执行类中定义的Java代码。</p>
<p>在准备阶段，类变量已经设置了系统要求的零值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<code>＜clinit＞()</code>方法的过程。</p>
<p><code>＜clinit＞()</code>方法是由编译器自动收集类中所有的类变量（<code>static</code>变量）和静态代码块（<code>static{}</code>块）中的语句合并生成的。编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态代码块中只能访问到定义在静态代码块之前的变量，定义在它之后的变量，在前面的静态代码块可以赋值，但是不能访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        number = 111;               // 可以赋值</span><br><span class="line">        System.out.println(number); // 不能读取，编辑器或报错Illegal forward reference</span><br><span class="line">    &#125;</span><br><span class="line">    static int number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>＜clinit＞()</code>方法与类的构造函数（或者说实例构造器<code>＜init＞()</code>方法）不同，它不需要显式地调用父类的<code>＜clinit＞()</code>方法，虚拟机会保证在子类的<code>＜clinit＞()</code>方法执行之前，父类的<code>＜clinit＞()</code>方法已经执行完毕。所以，父类定义的静态代码块要先与子类的赋值操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    public static int A = 1;</span><br><span class="line">    static &#123;</span><br><span class="line">        A = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Parent &#123;</span><br><span class="line">    public static int B = A;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Sub.B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>＜clinit＞()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>＜clinit＞()</code>方法。</p>
<p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>＜clinit＞()</code>方法。但接口与类不同的是，执行接口的<code>＜clinit＞()</code>方法不需要先执行父接口的<code>＜clinit＞()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>＜clinit＞()</code>方法。</p>
<p>虚拟机会保证一个类的<code>＜clinit＞()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>＜clinit＞()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>＜clinit＞()</code>方法完毕。如果在一个类的<code>＜clinit＞()</code>方法中有耗时很长的操作，就可能造成多个进程阻塞。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>在之前的加载过程中，提到了类加载器通过一个类的全限定名来获取描述此类的二进制字节流，这个过程可以让开发中自定义类加载器来决定如何获取需要的字节流。那么，什么是类加载器呢？</p>
<p>对于任意一个Java类，都必须通过类加载器加载到方法区，并生成<code>java.lang.Class</code>对象才能使用类的各个功能，所以我们可以把类加载器理解为一个将<code>class</code>类文件转换为<code>java.lang.Class</code>对象的工具。</p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，如果两个类“相等”，那么这两个类必须是被同一个虚拟机中的同一个类加载器加载，并且来自同一个<code>class</code>文件。</p>
<p>在Java当中，已经有3个预制的类加载器，分别是<code>BootStrapClassLoader</code>、<code>ExtClassLoader、AppClassLoader</code>。</p>
<ul>
<li>BootStrapClassLoader： 启动类加载器，它是由C++来实现的，在Java程序中不能显氏的获取到。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下的类。</li>
<li>ExtClassLoader： 扩展类加载器，它是由sun.misc.Launcher$ExtClassLoader实现，负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库。开发者可以直接使用它。</li>
<li>AppClassLoader： 应用程序类加载器，由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。一般来说，开发者自定义的类就是由应用程序类加载器加载的。</li>
</ul>
<p><code>ExtClassLoader</code>作为类加载器，但它也是一个Java类，是由<code>BootStrapClassLoader</code>来加载的，所以，<code>ExtClassLoader</code>的parent是<code>BootStrapClassLoader</code>。但是由于<code>BootStrapClassLoader</code>是<code>c++</code>实现的，我们通过<code>ExtClassLoader.getParent</code>获取到的是<code>null</code>。同样地，<code>AppClassLoader</code>是由<code>ExtClassLoader</code>加载，<code>AppClassLoader</code>的parent是<code>ExtClassLoader</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader cl = Test.class.getClassLoader();</span><br><span class="line">        while (cl != null) &#123;</span><br><span class="line">            System.out.println(cl);</span><br><span class="line">            cl = cl.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@232204a1</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@74a14482</span><br></pre></td></tr></table></figure></p>
<p>同时我们可以定义自己的类加载器<code>CustomClassLoader</code>，那么它的parent肯定就是<code>AppClassLoader</code>了。类加载器的这种层次关系称为双亲委派模型。<br><img src="http://i.imgur.com/NCkfOLT.png" alt="类加载器"></p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系不是以继承的关系来实现，而是都使用递归的方式来调用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>ClassLoader的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先检查是否已经被加载过，若没有加载则调用父类加载器的<code>loadClass()</code>方法，依次向上递归。若父类加载器为空则说明递归到启动类加载器了。如果从父类加载器到启动类加载器的上层次的所有加载器都加载失败，则调用自己的<code>findClass()</code>方法进行加载。</p>
<p>使用双亲委派模型能使Java类随着加载器一起具备一种优先级的层次关系，保证同一个类只加载一次，避免了重复加载，同时也能阻止有人恶意替换加载系统类。</p>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>一般地，在<code>ClassLoader</code>方法的<code>loadClass</code>方法中已经给开发者实现了双亲委派模型，在自定义类加载器的时候，只需要复写<code>findClass</code>方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String root;</span><br><span class="line"></span><br><span class="line">    public CustomClassLoader(String root) &#123;</span><br><span class="line">        this.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        byte[] classData = loadClassData(name);</span><br><span class="line">        if (classData == null) &#123;</span><br><span class="line">            throw new ClassNotFoundException();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return defineClass(name, classData, 0, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] loadClassData(String name) &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + name.replace(&apos;.&apos;, File.separatorChar)</span><br><span class="line">                + &quot;.class&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream ins = new FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            int bufferSize = 1024;</span><br><span class="line">            byte[] buffer = new byte[bufferSize];</span><br><span class="line">            int length;</span><br><span class="line">            while ((length = ins.read(buffer)) != -1) &#123;</span><br><span class="line">                baos.write(buffer, 0, length);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新建一个类<code>com.xiao.U</code>，编译成class文件，放到桌面，来测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CustomClassLoader customClassLoader = new CustomClassLoader(&quot;C:\\Users\\PC\\Desktop&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = customClassLoader.loadClass(&quot;com.xiao.U&quot;);</span><br><span class="line">            Object o = clazz.newInstance();</span><br><span class="line">            System.out.println(o.getClass().getClassLoader());</span><br><span class="line">        &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomClassLoader@1540e19d</span><br></pre></td></tr></table></figure></p>
<p>自定义类加载器在可以实现服务端的热部署，在移动端比如android也可以实现热更新。</p>
<hr>
<p>参考：</p>
<ol>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">深入理解Java虚拟机（第二版）</a></li>
<li><a href="http://www.jianshu.com/p/808a36134da5" target="_blank" rel="noopener">Java 类加载机制详解</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/08/Java虚拟机-——-垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/08/Java虚拟机-——-垃圾回收机制/" itemprop="url">Java虚拟机 —— 垃圾回收机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T12:00:20+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java虚拟机中，对象和数组的内存都是在堆中分配的，垃圾收集器主要回收的内存就是再堆内存中。如果在Java程序运行过程中，动态创建的对象或者数组没有及时得到回收，持续积累，最终堆内存就会被占满，导致OOM。</p>
<p>JVM提供了一种垃圾回收机制，简称GC机制。通过GC机制，能够在运行过程中将堆中的垃圾对象不断回收，从而保证程序的正常运行。</p>
<h3 id="垃圾对象的判定"><a href="#垃圾对象的判定" class="headerlink" title="垃圾对象的判定"></a>垃圾对象的判定</h3><p>我们都知道，所谓“垃圾”对象，就是指我们在程序的运行过程中不再有用的对象，即不再存活的对象。那么怎么来判断堆中的对象是“垃圾”、不再存活的对象呢？</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>每个对象都有一个引用计数的属性，用来保存该对象被引用的次数。当引用次数为0时，就意味着该对象没有被引用了，也就不会在使用这个对象了，可以判定为垃圾对象。但是，这种方式有一个很大的Bug，就是无法解决对象间相互引用或者循环引用的问题：当两个对象相互引用，他们两个和其他任何对象也没有引用关系，它俩的引用次数都不为0，因此不会被回收，但实际上这两个对象已经不再有用了。</p>
<h4 id="可达性分析（根搜索法）"><a href="#可达性分析（根搜索法）" class="headerlink" title="可达性分析（根搜索法）"></a>可达性分析（根搜索法）</h4><p>为了避免使用引用计数法带来的问题，Java采用了可达性分析法来判断垃圾对象。</p>
<p>这种方式可以将所有对象的引用关系想象成一棵树，从树的根节点GC Root遍历所有引用的对象，树的节点就为可达对象，其他没有处于节点的对象则为不可达对象。<br><img src="http://i.imgur.com/ZDj6cyi.png" alt=""><br>那么什么样的对象可以作为GC的根节点呢？</p>
<ul>
<li>虚拟机栈（帧栈中的本地变量表）中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<h3 id="引用状态"><a href="#引用状态" class="headerlink" title="引用状态"></a>引用状态</h3><p>垃圾回收机制，不管采用是引用计数法，还是可达性分析法，都与对象的引用有关，Java中存在四种引用状态：</p>
<ul>
<li><p>强引用 - 我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，就表示它处于可达状态，垃圾回收器绝不会回收它，即便系统内存非常紧张，Java虚拟机宁愿抛出<code>OutOfMemoryError</code>错误，使程序异常终止，也不会回收被强引用所引用的对象。因此，强引用是造成Java内存泄露的主要原因之一。</p>
</li>
<li><p>软引用 - 一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p>
</li>
<li><p>弱引用 - 一个对象只具有弱引用，那就类似于是可有可无的。弱引用和软引用很像，但弱引用的引用级别更低。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
</li>
<li><p>虚引用 - 一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动，我们平常一般不会使用。</p>
</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>通过可达性分析算法能够判定哪些对象是需要回收的了，那么回收具体需要怎样去执行呢？</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>首先需要标记可以回收的对象内存，然后在对回收的内存进行清除。<br><img src="http://i.imgur.com/05CUQBx.png" alt="标记-清除算法（回收前）"><br><img src="http://i.imgur.com/LUPWXr9.png" alt="标记-清除算法（回收后）"><br>但是这样的话，随着程序的运行，会不断分配释放内存，在堆中会产生很多的不连续的空闲内存区，即内存碎片。这样即使有足够多的空闲内存，也不一定能分配出足够大的内存，并且可能会造成频繁的GC，影响效率，甚至OOM。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>和标记-清除算法不同的是，标记-整理算法在标记后不直接清理可回收内存，而是将存活对象都移动到一端，然后清除掉可回收内存。<br><img src="http://i.imgur.com/05CUQBx.png" alt="标记-整理算法（回收前）"><br><img src="http://i.imgur.com/NAACDZA.png" alt="标记-整理算法（回收后）"><br>这样做的好处就是不会产生内存碎片。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法需要先将内存分为两块，先在其中一块内存上分配内存，当这块内存被分配完后，则执行垃圾回收，然后把存活对象全部复制到另一块内存上，第一块内存则全部清空。<br><img src="http://i.imgur.com/auv29Mp.png" alt="复制算法（回收前）"><br><img src="http://i.imgur.com/Hdpv9nh.png" alt="复制算法（回收后）"><br>这种算法不会产生内存碎片，但是相当于只能使用一半的内存空间。同时，复制算法和存活对象的数量有关，如果存活对象的数量多，那么复制算法的效率会大大降低。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>在Java虚拟机中，对象的生命周期有长有短，大部分对象的生命周期很短，只有少部分的对象才会在内存中存留较长时间，因此可以依据对象生命周期的长短将它们放在不同的区域。在采用分代收集算法的Java虚拟机堆中，一般分为三个区域，用来分别储存这三类对象：</p>
<ul>
<li><p>新生代 - 刚创建的对象，在代码运行时一般都会持续不断地创建新的对象，这些新创建的对象有很多是局部变量，很快就会变成垃圾对象。这些对象被放在一块称为新生代的内存区域。新生代的特点是垃圾对象多，存活对象少。</p>
</li>
<li><p>老年代 - 一些对象很早被创建了，经历了多次GC也没有被回收，而是一直存活下来。这些对象被放在一块称为老年代的区域。老年代的特点是存活对象多，垃圾对象少。</p>
</li>
<li><p>永久代 - 一些伴随虚拟机生命周期永久存在的对象，比如一些静态对象，常量等。这些对象被放在一块称为永久代的区域。永久代的特点是这些对象一般不需要垃圾回收，会在虚拟机运行过程中一直存活。（在Java1.7之前，方法区中存储的是永久代对象，Java1.7方法区的永久代对象移到了堆中，而在Java1.8永久代已经从堆中移除了，这块内存给了元空间。）</p>
</li>
</ul>
<p>分代收集算法也就根据新生代和老年代来进行垃圾回收的。</p>
<p>对于新生代区域，每次GC都会有很多垃圾对象被回收，只有少量存活。因此采用复制回收算法，GC时把剩余很少的存活对象复制过去即可。</p>
<p>在新生代区域中，并不是按照1:1的比例来进行复制回收，而是按照8:1:1的比例分为了Eden、SurvivorA、SurvivorB三个区域。其中Eden意为伊甸园，形容有很多新生对象在里面创建；Survivor区则为幸存者，即经历GC后仍然存活下来的对象。</p>
<ol>
<li>Eden区对外提供堆内存。当Eden区快要满了，则进行Minor GC(新生代GC)，把存活对象放入SurvivorA区，清空Eden区；</li>
<li>Eden区被清空后，继续对外提供堆内存；</li>
<li>当Eden区再次被填满，此时对Eden区和SurvivorA区同时进行Minor GC(新生代GC)，把存活对象放入SurvivorB区，此时同时清空Eden区和SurvivorA区；</li>
<li>Eden区继续对外提供堆内存，并重复上述过程，即在 Eden 区填满后，把Eden区和某个Survivor区的存活对象放到另一个Survivor区；</li>
<li>当某个Survivor区被填满，且仍有对象未被复制完毕时，或者某些对象在反复Survive 15次左右时，则把这部分剩余对象放到老年代区域；当老年区也被填满时，进行Major GC（老年代GC），对老年代区域进行垃圾回收。<br>老年代区域对象一般存活周期较长，每次GC时，存活的对象比较多，因此采用标记-整理算法，GC时移动少量存活对象，不会产生内存碎片。</li>
</ol>
<h3 id="触发GC的类型"><a href="#触发GC的类型" class="headerlink" title="触发GC的类型"></a>触发GC的类型</h3><p>Java虚拟机会把每次触发GC的信息打印出来，可以根据日志来分析触发GC的原因。</p>
<ul>
<li>GC_FOR_MALLOC：表示是在堆上分配对象时内存不足触发的GC。</li>
<li>GC_CONCURRENT：当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。</li>
<li>GC_EXPLICIT：表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。</li>
<li>GC_BEFORE_OOM：表示是在准备抛OOM异常之前进行的最后努力而触发的GC。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/daijin888888/article/details/49949283" target="_blank" rel="noopener">Java内存回收机制–Java引用的种类（强引用、弱引用、软引用、虚引用）</a></li>
<li><a href="http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">理解Java垃圾回收机制</a></li>
<li><a href="http://wingjay.com/2017/05/24/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">Java 技术之垃圾回收机制</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/07/Java虚拟机-——-运行时数据区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/Java虚拟机-——-运行时数据区/" itemprop="url">Java虚拟机 —— 运行时数据区</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T14:45:57+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java虚拟机内存，是指JVM的运行时数据区域，主要分为：方法区、堆、虚拟机栈、本地方法栈、程序计数器。其中方法区和堆为索引线程的共享数据区，而虚拟机栈、本地方法栈、程序计数器为线程隔离的数据区。<br><img src="http://i.imgur.com/mNNVN4G.png" alt=""></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>每个线程都有一个独立的计数器用来记录程序当前执行的指令，可以看成是当前线程所执行的字节码的行号指示器。如果线程正在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，计数器记录值为空(<code>Undefined</code>)。程序计数器占用的内存空间非常小，是线程的私有区域，此内存区域是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈是一个后进先出的数据结构，里面存放的是栈帧，每个Java方法的调用对应一个栈帧在虚拟机栈中的入栈和出栈。当线程执行一个Java方法执行时，就会创建一个新的栈帧并压入到该线程的虚拟机栈的栈顶，Java方法执行结束后栈顶的该栈帧就会弹出栈并销毁。</p>
<p>栈帧里面存放的是Java方法执行的一些数据，包括局部变量表、操作数栈、动态连接、方法出口等。<br><img src="http://i.imgur.com/DEiQRe6.png" alt=""></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<p>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。</p>
<p>Java虚拟机是使用局部变量表完成参数值到Java方法参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。</p>
<p>Slot是可以重用的，下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>操作数栈也常被称为操作栈，同样是一个后进先出的数据结构。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。在做算术运算的时候是通过操作数栈来进行的，在调用其他方法的时候是通过操作数栈来进行参数传递的。JVM将操作数栈作为工作区。JVM没有寄存器，所有的参数传递和返回值都是基于操作数栈来完成的。</p>
<p>比如，执行引擎执行<code>c = a + b</code>时，会先被操作的参数<code>a</code>和<code>b</code>压入操作数栈，然后操作指令将他们弹出栈，并执行操作，将结果再压入栈。</p>
<p>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</p>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池有存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。</p>
<h4 id="方法出口-返回地址"><a href="#方法出口-返回地址" class="headerlink" title="方法出口(返回地址)"></a>方法出口(返回地址)</h4><p>当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</p>
<p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p>
<p>无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<h4 id="虚拟机栈Error"><a href="#虚拟机栈Error" class="headerlink" title="虚拟机栈Error"></a>虚拟机栈Error</h4><p>Java虚拟机栈有可能出现的error就是<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。当线程请求的栈深度大于Java虚拟机栈允许的深度时，就会抛出<code>StackOverflowError</code>错误。比如将一个方法反复递归，最终就会出现<code>StackOverflowError</code>。当Java虚拟机栈可以动态扩展时（大部分的 Java 虚拟机都可动态扩展，不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），如果无法申请到足够的内存来扩展栈，就会抛出<code>OutOfMemoryError</code>错误。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈的功能类似，他们的区别在于虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务。本地方法栈就是一个C的方法栈，本地方法栈的参数顺序、返回值和典型的C程序相同，本地方法一般来说可以（依赖 JVM 的实现）反过来调用 JVM 中的 Java 方法。这种native方法调用Java会发生在栈（一般是Java栈）上，线程将离开本地方法栈，并在 Java 栈上开辟一个新的栈帧。</p>
<p>与虚拟机栈一样，本地方法栈也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是Java虚拟机中最大的一块内存区域，它是有所有的线程共享。几乎所有的实例对象和数组都是在堆中存放。只要是通过<code>new</code>关键字创建对象或者直接声明数组，都会在堆中开辟内存空间来存放。因为在栈帧被创建后无法调整大小，栈帧中只能存放对象和数组在堆中的引用。方法或线程结束时对象和数组不会立即被移除销毁，它只能由垃圾回收器回收。</p>
<p>同样地，如果在堆中没有内存来完成实例分配，并且堆也无法扩展时，将会抛出<code>OutOfMemoryError</code>。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与堆一样，是各个线程共享的内存区域，它存储已经被虚拟机加载的类信息(包括字段信息、方法信息、方法代码等)、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>方法区中的内存一般不会被GC回收，GC也很难回收。方法区的内存回收主要是针对针对常量池的回收和对类的卸载。根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分，Class文件除了有关类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池可以理解为是类或接口的常量池的运行时表现形式。</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.csdn.net/xlgen157387/article/details/45044655" target="_blank" rel="noopener">Java虚拟机内存区域划分详解</a></li>
<li><a href="http://www.360doc.com/content/17/0804/15/46080707_676628168.shtml" target="_blank" rel="noopener">JAVA内存结构之运行时栈帧结构</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/21/React-Native-——-react-navigation的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/21/React-Native-——-react-navigation的使用/" itemprop="url">React Native —— react-navigation的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-21T10:56:37+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React-Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在<code>React Native</code>中，官方已经推荐使用<code>react-navigation</code>来实现各个界面的跳转和不同板块的切换。<code>react-navigation</code>主要包括三个组件：</p>
<ul>
<li><code>StackNavigator</code> 导航组件</li>
<li><code>TabNavigator</code> 切换组件</li>
<li><code>DrawerNavigator</code> 抽屉组件</li>
</ul>
<p><code>StackNavigator</code>用于实现各个页面之间的跳转，<code>TabNavigator</code>用来实现同一个页面上不同界面的切换，<code>DrawerNavigator</code> 可以实现侧滑的抽屉效果。</p>
<h4 id="StackNavigator"><a href="#StackNavigator" class="headerlink" title="StackNavigator"></a>StackNavigator</h4><p><code>StackNavigator</code>组件采用堆栈式的页面导航来实现各个界面跳转。它的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StackNavigator(RouteConfigs, StackNavigatorConfig)</span><br></pre></td></tr></table></figure></p>
<p>有<code>RouteConfigs</code>和<code>StackNavigatorConfig</code>两个参数。</p>
<h5 id="RouteConfigs"><a href="#RouteConfigs" class="headerlink" title="RouteConfigs"></a>RouteConfigs</h5><p><code>RouteConfigs</code> 参数表示各个页面路由配置，类似于android原生开发中的<code>AndroidManifest.xml</code>，它是让导航器知道需要导航的路由对应的页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const RouteConfigs = &#123;</span><br><span class="line">    Home: &#123;</span><br><span class="line">        screen: HomePage,</span><br><span class="line">        navigationOptions: (&#123;navigation&#125;) =&gt; (&#123;</span><br><span class="line">            title: &apos;首页&apos;,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">    Find: &#123;</span><br><span class="line">        screen: FindPage,</span><br><span class="line">        navigationOptions: (&#123;navigation&#125;) =&gt; (&#123;</span><br><span class="line">            title: &apos;发现&apos;,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">    Mine: &#123;</span><br><span class="line">        screen: MinePage,</span><br><span class="line">        navigationOptions: (&#123;navigation&#125;) =&gt; (&#123;</span><br><span class="line">            title: &apos;我的&apos;,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里给导航器配置了三个页面，<code>Home</code>、<code>Find</code>、<code>Mine</code>为路由名称，<code>screen</code>属性值<code>HomePage</code>、<code>FindPage</code>、<code>MinePage</code>为对应路由的页面。</p>
<p><code>navigationOptions</code>为对应路由页面的配置选项：</p>
<ul>
<li><code>title</code> - 可以作为头部标题<code>headerTitle</code>，或者Tab标题<code>tabBarLabel</code></li>
<li><code>header</code> - 自定义的头部组件，使用该属性后系统的头部组件会消失</li>
<li><code>headerTitle</code> -  头部的标题，即页面的标题</li>
<li><code>headerBackTitle</code> - 返回标题，默认为<code>title</code></li>
<li><code>headerTruncatedBackTitle</code> - 返回标题不能显示时（比如返回标题太长了）显示此标题，默认为<code>“Back”</code></li>
<li><code>headerRight</code> - 头部右边组件</li>
<li><code>headerLeft</code> - 头部左边组件</li>
<li><code>headerStyle</code> - 头部组件的样式</li>
<li><code>headerTitleStyle</code> - 头部标题的样式</li>
<li><code>headerBackTitleStyle</code> - 头部返回标题的样式</li>
<li><code>headerTintColor</code> - 头部颜色</li>
<li><code>headerPressColorAndroid</code> - <code>Android 5.0</code>以上MD风格的波纹颜色</li>
<li><code>gesturesEnabled</code> - 否能侧滑返回，<code>iOS</code>默认<code>true</code>，<code>Android</code>默认<code>false</code></li>
</ul>
<h5 id="StackNavigatorConfig"><a href="#StackNavigatorConfig" class="headerlink" title="StackNavigatorConfig"></a>StackNavigatorConfig</h5><p><code>StackNavigatorConfig</code>参数表示导航器的配置，包括导航器的初始页面、各个页面之间导航的动画、页面的配置选项等等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const StackNavigatorConfig = &#123;</span><br><span class="line">    initialRouteName: &apos;Home&apos;,</span><br><span class="line">    initialRouteParams: &#123;initPara: &apos;初始页面参数&apos;&#125;,</span><br><span class="line">    navigationOptions: &#123;</span><br><span class="line">        title: &apos;标题&apos;,</span><br><span class="line">        headerTitleStyle: &#123;fontSize: 18, color: &apos;#666666&apos;&#125;,</span><br><span class="line">        headerStyle: &#123;height: 48, backgroundColor: &apos;#fff&apos;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    paths: &apos;page/main&apos;,</span><br><span class="line">    mode: &apos;card&apos;,</span><br><span class="line">    headerMode: &apos;screen&apos;,</span><br><span class="line">    cardStyle: &#123;backgroundColor: &quot;#ffffff&quot;&#125;,</span><br><span class="line">    transitionConfig: (() =&gt; (&#123;</span><br><span class="line">        screenInterpolator: CardStackStyleInterpolator.forHorizontal,</span><br><span class="line">    &#125;)),</span><br><span class="line">    onTransitionStart: (() =&gt; &#123;</span><br><span class="line">        console.log(&apos;页面跳转动画开始&apos;);</span><br><span class="line">    &#125;),</span><br><span class="line">    onTransitionEnd: (() =&gt; &#123;</span><br><span class="line">        console.log(&apos;页面跳转动画结束&apos;);</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>initialRouteName</code> - 导航器组件中初始显示页面的路由名称，如果不设置，则默认第一个路由页面为初始显示页面</li>
<li><code>initialRouteParams</code> - 给初始路由的参数，在初始显示的页面中可以通过<code>this.props.navigation.state.params</code>来获取</li>
<li><code>navigationOptions</code> - 路由页面的配置选项，它会被<code>RouteConfigs</code> 参数中的 <code>navigationOptions</code>的对应属性覆盖。</li>
<li><code>paths</code> - 路由中设置的路径的覆盖映射配置</li>
<li><code>mode</code> - 页面跳转方式，有<code>card</code>和<code>modal</code>两种，默认为<code>card</code>：<ul>
<li><code>card</code> - 原生系统默认的的跳转</li>
<li><code>modal</code> - 只针对iOS平台，模态跳转</li>
</ul>
</li>
<li><code>headerMode</code> - 页面跳转时，头部的动画模式，有<code>float</code>、<code>screen</code>、<code>none</code>三种：<ul>
<li><code>float</code> - 渐变，类似iOS的原生效果</li>
<li><code>screen</code> - 标题与屏幕一起淡入淡出</li>
<li><code>none</code> - 没有动画</li>
</ul>
</li>
<li><code>cardStyle</code> - 为各个页面设置统一的样式，比如背景色，字体大小等</li>
<li><code>transitionConfig</code> - 配置页面跳转的动画，覆盖默认的动画效果</li>
<li><code>onTransitionStart</code> - 页面跳转动画即将开始时调用</li>
<li><code>onTransitionEnd</code> - 页面跳转动画一旦完成会马上调用</li>
</ul>
<p>页面的配置选项<code>navigationOptions</code>通常还可以在对应页面中去静态配置，比如在<code>HomePage</code>页面中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default class HomePage extends Component &#123;</span><br><span class="line"></span><br><span class="line">    // 配置页面导航选项</span><br><span class="line">    static navigationOptions = (&#123;navigation&#125;) =&gt; (&#123;</span><br><span class="line">        title: &apos;HOME&apos;,</span><br><span class="line">        titleStyle: &#123;color: &apos;#ff00ff&apos;&#125;,</span><br><span class="line">        headerStyle:&#123;backgroundColor:&apos;#000000&apos;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;&lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，在页面里面采用静态的方式配置<code>navigationOptions</code>中的属性，会覆盖<code>StackNavigator</code>构造函数中两个参数<code>RouteConfigs</code>和<code>StackNavigatorConfig</code>配置的<code>navigationOptions</code>里面的对应属性。<code>navigationOptions</code>中属性的优先级是：<br>页面中静态配置 &gt; <code>RouteConfigs</code> &gt; <code>StackNavigatorConfig</code></p>
<p>有了<code>RouteConfigs</code>和<code>StackNavigatorConfig</code>两个参数，就可以构造出一个导航器组件<code>StackNavigator</code>，直接引用该组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Navigator = StackNavigator(RouteConfigs, StackNavigatorConfig);</span><br><span class="line"></span><br><span class="line">export default class MainComponent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Navigator/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>已经配置好导航器以及对应的路由页面了，但是要完成页面之间的跳转，还需要<code>navigation</code>。</p>
<h5 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h5><p>在导航器中的每一个页面，都有<code>navigation</code>属性，该属性有以下几个属性/方法：</p>
<ul>
<li><code>navigate</code> - 跳转到其他页面</li>
<li><code>state</code> - 当前页面导航器的状态</li>
<li><code>setParams</code> - 更改路由的参数</li>
<li><code>goBack</code> - 返回</li>
<li><code>dispatch</code> - 发送一个action</li>
</ul>
<h6 id="navigete"><a href="#navigete" class="headerlink" title="navigete"></a>navigete</h6><p>调用这个方法可以跳转到导航器中的其他页面，此方法有三个参数：<br>— <code>routeName</code> 导航器中配置的路由名称<br>— <code>params</code> 传递参数到下一个页面<br>— <code>action</code> action<br>比如：<code>this.props.navigation.navigate(&#39;Find&#39;, {param: &#39;i am the param&#39;});</code></p>
<h6 id="state"><a href="#state" class="headerlink" title="state"></a>state</h6><p><code>state</code>里面包含有传递过来的参数<code>params</code>、<code>key</code>、路由名称<code>routeName</code>，打印log可以看得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  params: &#123; param: &apos;i am the param&apos; &#125;,</span><br><span class="line">  key: &apos;id-1500546317301-1&apos;,</span><br><span class="line">  routeName: &apos;Mine&apos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="setParams"><a href="#setParams" class="headerlink" title="setParams"></a>setParams</h6><p>更改当前页面路由的参数，比如可以用来更新头部的按钮或者标题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    this.props.navigation.setParams(&#123;param:&apos;i am the new param&apos;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="goBack"><a href="#goBack" class="headerlink" title="goBack"></a>goBack</h5><p>回退，可以不传，也可以传参数，还可以传<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.props.navigation.goBack();       // 回退到上一个页面</span><br><span class="line">this.props.navigation.goBack(null);   // 回退到任意一个页面</span><br><span class="line">this.props.navigation.goBack(&apos;Home&apos;); // 回退到Home页面</span><br></pre></td></tr></table></figure>
<h4 id="TabNavigator"><a href="#TabNavigator" class="headerlink" title="TabNavigator"></a>TabNavigator</h4><p><code>TabNavigator</code>，即是Tab选项卡，类似于原生<code>android</code>中的<code>TabLayout</code>，它的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TabNavigator(RouteConfigs, TabNavigatorConfig)</span><br></pre></td></tr></table></figure>
<p>api和<code>StackNavigator</code>类似，参数<code>RouteConfigs</code>是路由配置，参数<code>TabNavigatorConfig</code>是Tab选项卡配置。</p>
<h5 id="RouteConfigs-1"><a href="#RouteConfigs-1" class="headerlink" title="RouteConfigs"></a>RouteConfigs</h5><p>路由配置和<code>StackNavigator</code>中是一样的，配置路由以及对应的<code>screen</code>页面，<code>navigationOptions</code>为对应路由页面的配置选项：</p>
<ul>
<li><code>title</code> - Tab标题，可用作<code>headerTitle</code>和<code>tabBarLabel</code>回退标题</li>
<li><code>tabBarVisible</code> - Tab的是否可见，没有设置的话默认为<code>true</code></li>
<li><code>tabBarIcon</code> - Tab的icon组件，可以根据<code>{focused: boolean, tintColor: string}</code>方法来返回一个icon组件</li>
<li><code>tabBarLabel</code> - Tab中显示的标题字符串或者组件，也可以根据<code>{ focused: boolean, tintColor: string }</code>方法返回一个组件</li>
</ul>
<h5 id="TabNavigatorConfig"><a href="#TabNavigatorConfig" class="headerlink" title="TabNavigatorConfig"></a>TabNavigatorConfig</h5><ul>
<li><code>tabBarComponent</code> - Tab选项卡组件，有<code>TabBarBottom</code>和<code>TabBarTop</code>两个值，在iOS中默认为<code>TabBarBottom</code>，在Android中默认为<code>TabBarTop</code>。<ul>
<li><code>TabBarTop</code> - 在页面的顶部</li>
<li><code>TabBarBottom</code> - 在页面的底部</li>
</ul>
</li>
<li><code>tabBarPosition</code> - Tab选项卡的位置，有 <code>top</code> 或 <code>bottom</code>两个值</li>
<li><code>swipeEnabled</code> - 是否可以滑动切换Tab选项卡</li>
<li><code>animationEnabled</code> - 点击Tab选项卡切换界面是否需要动画</li>
<li><code>lazy</code> - 是否懒加载页面</li>
<li><code>initialRouteName</code> - 初始显示的Tab对应的页面路由名称</li>
<li><code>order</code> - 用路由名称数组来表示Tab选项卡的顺序，默认为路由配置顺序</li>
<li><code>paths</code> - 路径配置</li>
<li><code>backBehavior</code> - androd点击返回键时的处理，有<code>initialRoute</code>和<code>none</code>两个值<ul>
<li><code>initailRoute</code> - 返回初始界面</li>
<li><code>none</code> - 退出</li>
</ul>
</li>
<li><code>tabBarOptions</code> - Tab配置属性，用在<code>TabBarTop</code>和<code>TabBarBottom</code>时有些属性不一致：<ul>
<li>用于<code>TabBarTop</code>时：<ul>
<li><code>activeTintColor</code> - 选中的文字颜色</li>
<li><code>inactiveTintColor</code> - 未选中的文字颜色</li>
<li><code>showIcon</code> - 是否显示图标，默认显示</li>
<li><code>showLabel</code> - 是否显示标签，默认显示</li>
<li><code>upperCaseLabel</code> - 是否使用大写字母，默认使用</li>
<li><code>pressColor</code> - android 5.0以上的MD风格波纹颜色</li>
<li><code>pressOpacity</code> - android 5.0以下或者iOS按下的透明度</li>
<li><code>scrollEnabled</code> - 是否可以滚动</li>
<li><code>tabStyle</code> - 单个Tab的样式</li>
<li><code>indicatorStyle</code> - 指示器的样式</li>
<li><code>labelStyle</code> - 标签的样式</li>
<li><code>iconStyle</code> - icon的样式</li>
<li><code>style</code> - 整个TabBar的样式</li>
</ul>
</li>
<li>用于<code>TabBarBottom</code>时：<ul>
<li><code>activeTintColor</code> - 选中Tab的文字颜色</li>
<li><code>activeBackgroundColor</code> - 选中Tab的背景颜色</li>
<li><code>inactiveTintColor</code> - 未选中Tab的的文字颜色</li>
<li><code>inactiveBackgroundColor</code> - 未选中Tab的背景颜色</li>
<li><code>showLabel</code> -  是否显示标题，默认显示</li>
<li><code>style</code> - 整个TabBar的样式</li>
<li><code>labelStyle</code> - 标签的样式</li>
<li><code>tabStyle</code> - 单个Tab的样式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="底部Tab导航示例"><a href="#底部Tab导航示例" class="headerlink" title="底部Tab导航示例"></a>底部Tab导航示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">import &#123;StackNavigator, TabBarBottom, TabNavigator&#125; from &quot;react-navigation&quot;;</span><br><span class="line">import HomeScreen from &quot;./index18/HomeScreen&quot;;</span><br><span class="line">import NearByScreen from &quot;./index18/NearByScreen&quot;;</span><br><span class="line">import MineScreen from &quot;./index18/MineScreen&quot;;</span><br><span class="line">import TabBarItem from &quot;./index18/TabBarItem&quot;;</span><br><span class="line">export default class MainComponent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Navigator/&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const TabRouteConfigs = &#123;</span><br><span class="line">    Home: &#123;</span><br><span class="line">        screen: HomeScreen,</span><br><span class="line">        navigationOptions: (&#123;navigation&#125;) =&gt; (&#123;</span><br><span class="line">            tabBarLabel: &apos;首页&apos;,</span><br><span class="line">            tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class="line">                &lt;TabBarItem</span><br><span class="line">                    tintColor=&#123;tintColor&#125;</span><br><span class="line">                    focused=&#123;focused&#125;</span><br><span class="line">                    normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_homepage_2x.png&apos;)&#125;</span><br><span class="line">                    selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_homepage_selected_2x.png&apos;)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            ),</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">    NearBy: &#123;</span><br><span class="line">        screen: NearByScreen,</span><br><span class="line">        navigationOptions: &#123;</span><br><span class="line">            tabBarLabel: &apos;附近&apos;,</span><br><span class="line">            tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class="line">                &lt;TabBarItem</span><br><span class="line">                    tintColor=&#123;tintColor&#125;</span><br><span class="line">                    focused=&#123;focused&#125;</span><br><span class="line">                    normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_merchant_2x.png&apos;)&#125;</span><br><span class="line">                    selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_merchant_selected_2x.png&apos;)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            ),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    Mine: &#123;</span><br><span class="line">        screen: MineScreen,</span><br><span class="line">        navigationOptions: &#123;</span><br><span class="line">            tabBarLabel: &apos;我的&apos;,</span><br><span class="line">            tabBarIcon: (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class="line">                &lt;TabBarItem</span><br><span class="line">                    tintColor=&#123;tintColor&#125;</span><br><span class="line">                    focused=&#123;focused&#125;</span><br><span class="line">                    normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_mine_2x.png&apos;)&#125;</span><br><span class="line">                    selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_mine_selected_2x.png&apos;)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            ),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const TabNavigatorConfigs = &#123;</span><br><span class="line">    initialRouteName: &apos;Home&apos;,</span><br><span class="line">    tabBarComponent: TabBarBottom,</span><br><span class="line">    tabBarPosition: &apos;bottom&apos;,</span><br><span class="line">    lazy: true,</span><br><span class="line">&#125;;</span><br><span class="line">const Tab = TabNavigator(TabRouteConfigs, TabNavigatorConfigs);</span><br><span class="line">const StackRouteConfigs = &#123;</span><br><span class="line">    Tab: &#123;</span><br><span class="line">        screen: Tab,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const StackNavigatorConfigs = &#123;</span><br><span class="line">    initialRouteName: &apos;Tab&apos;,</span><br><span class="line">    navigationOptions: &#123;</span><br><span class="line">        title: &apos;标题&apos;,</span><br><span class="line">        headerStyle: &#123;backgroundColor: &apos;#5da8ff&apos;&#125;,</span><br><span class="line">        headerTitleStyle: &#123;color: &apos;#333333&apos;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const Navigator = StackNavigator(StackRouteConfigs, StackNavigatorConfigs);</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-1ca808f4f9735657.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h5 id="顶部Tab选项卡示例"><a href="#顶部Tab选项卡示例" class="headerlink" title="顶部Tab选项卡示例"></a>顶部Tab选项卡示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &quot;react&quot;;</span><br><span class="line">import &#123;StackNavigator, TabBarTop, TabNavigator&#125; from &quot;react-navigation&quot;;</span><br><span class="line">import HomeScreen from &quot;./index18/HomeScreen&quot;;</span><br><span class="line">import NearByScreen from &quot;./index18/NearByScreen&quot;;</span><br><span class="line">import MineScreen from &quot;./index18/MineScreen&quot;;</span><br><span class="line">export default class MainComponent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Navigator/&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const TabRouteConfigs = &#123;</span><br><span class="line">    Home: &#123;</span><br><span class="line">        screen: HomeScreen,</span><br><span class="line">        navigationOptions: (&#123;navigation&#125;) =&gt; (&#123;</span><br><span class="line">            tabBarLabel: &apos;首页&apos;,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">    NearBy: &#123;</span><br><span class="line">        screen: NearByScreen,</span><br><span class="line">        navigationOptions: &#123;</span><br><span class="line">            tabBarLabel: &apos;附近&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    Mine: &#123;</span><br><span class="line">        screen: MineScreen,</span><br><span class="line">        navigationOptions: &#123;</span><br><span class="line">            tabBarLabel: &apos;我的&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const TabNavigatorConfigs = &#123;</span><br><span class="line">    initialRouteName: &apos;Home&apos;,</span><br><span class="line">    tabBarComponent: TabBarTop,</span><br><span class="line">    tabBarPosition: &apos;top&apos;,</span><br><span class="line">    lazy: true,</span><br><span class="line">    tabBarOptions: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">const Tab = TabNavigator(TabRouteConfigs, TabNavigatorConfigs);</span><br><span class="line">const StackRouteConfigs = &#123;</span><br><span class="line">    Tab: &#123;</span><br><span class="line">        screen: Tab,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const StackNavigatorConfigs = &#123;</span><br><span class="line">    initialRouteName: &apos;Tab&apos;,</span><br><span class="line">    navigationOptions: &#123;</span><br><span class="line">        title: &apos;标题&apos;,</span><br><span class="line">        headerStyle: &#123;backgroundColor: &apos;#5da8ff&apos;&#125;,</span><br><span class="line">        headerTitleStyle: &#123;color: &apos;#333333&apos;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const Navigator = StackNavigator(StackRouteConfigs, StackNavigatorConfigs);</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-54d6d324b627a750.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h4 id="DrawerNavigator"><a href="#DrawerNavigator" class="headerlink" title="DrawerNavigator"></a>DrawerNavigator</h4><p>在原生Android MD 风格里面很多app都会采用侧滑抽屉来做主页面的导航，利用<code>DrawerNavigator</code>在RN中可以很方便来实现抽屉导航。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DrawerNavigator(RouteConfigs, DrawerNavigatorConfig)</span><br></pre></td></tr></table></figure>
<p>和<code>DrawerNavigator</code>的构造函数一样，参数配置也类似。</p>
<h5 id="RouteConfigs-2"><a href="#RouteConfigs-2" class="headerlink" title="RouteConfigs"></a>RouteConfigs</h5><p>抽屉导航的路由配置<code>RouteConfigs</code>，和<code>TabNavigator</code>的路由配置完全一样，<code>screen</code>配置对应路由页面，<code>navigationOptions</code>为对应页面的抽屉配置选项：</p>
<ul>
<li><code>title</code> - 抽屉标题，和<code>headerTitle</code>、<code>drawerLabel</code>一样</li>
<li><code>drawerLabel</code> - 标签字符串，或者自定义组件， 可以根据<code>{ focused: boolean, tintColor: string }</code>函数来返回一个自定义组件作为标签</li>
<li><code>drawerIcon</code> - 抽屉icon，可以根据<code>{ focused: boolean, tintColor: string }</code>函数来返回一个自定义组件作为icon</li>
</ul>
<h5 id="DrawerNavigatorConfig"><a href="#DrawerNavigatorConfig" class="headerlink" title="DrawerNavigatorConfig"></a>DrawerNavigatorConfig</h5><p>抽屉配置项属性：</p>
<ul>
<li><code>drawerWidth</code> - 抽屉宽度，可以使用Dimensions获取屏幕的宽度，动态计算</li>
<li><code>drawerPosition</code> - 抽屉位置，可以是<code>left</code>或者<code>right</code></li>
<li><code>contentComponent</code> - 抽屉内容组件，可以自定义侧滑抽屉中的所有内容，默认为<code>DrawerItems</code></li>
<li><code>contentOptions</code> - 用来配置抽屉内容的属性。当用来配置<code>DrawerItems</code>是配置属性选项：<ul>
<li><code>items</code> - 抽屉栏目的路由名称数组，可以被修改</li>
<li><code>activeItemKey</code> - 当前选中页面的key id</li>
<li><code>activeTintColor</code> - 选中条目状态的文字颜色</li>
<li><code>activeBackgroundColor</code> - 选中条目的背景色</li>
<li><code>inactiveTintColor</code> - 未选中条目状态的文字颜色</li>
<li><code>inactiveBackgroundColor</code> - 未选中条目的背景色</li>
<li><code>onItemPress(route)</code> - 条目按下时会调用此方法</li>
<li><code>style</code> - 抽屉内容的样式</li>
<li><code>labelStyle</code> - 抽屉的条目标题/标签样式</li>
</ul>
</li>
<li><code>initialRouteName</code> - 初始化展示的页面路由名称</li>
<li><code>order</code> - 抽屉导航栏目顺序，用路由名称数组表示</li>
<li><code>paths</code> - 路径</li>
<li><code>backBehavior</code> - androd点击返回键时的处理，有initialRoute和none两个值，<code>initailRoute</code>：返回初始界面，<code>none</code>：退出</li>
</ul>
<h5 id="抽屉导航示例"><a href="#抽屉导航示例" class="headerlink" title="抽屉导航示例"></a>抽屉导航示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">import &#123;DrawerNavigator, StackNavigator, TabBarBottom, TabNavigator&#125; from &quot;react-navigation&quot;;</span><br><span class="line">import HomeScreen from &quot;./index18/HomeScreen&quot;;</span><br><span class="line">import NearByScreen from &quot;./index18/NearByScreen&quot;;</span><br><span class="line">import MineScreen from &quot;./index18/MineScreen&quot;;</span><br><span class="line">import TabBarItem from &quot;./index18/TabBarItem&quot;;</span><br><span class="line">export default class MainComponent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Navigator/&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const DrawerRouteConfigs = &#123;</span><br><span class="line">    Home: &#123;</span><br><span class="line">        screen: HomeScreen,</span><br><span class="line">        navigationOptions: (&#123;navigation&#125;) =&gt; (&#123;</span><br><span class="line">            drawerLabel : &apos;首页&apos;,</span><br><span class="line">            drawerIcon : (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class="line">                &lt;TabBarItem</span><br><span class="line">                    tintColor=&#123;tintColor&#125;</span><br><span class="line">                    focused=&#123;focused&#125;</span><br><span class="line">                    normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_homepage_2x.png&apos;)&#125;</span><br><span class="line">                    selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_homepage_selected_2x.png&apos;)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            ),</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;,</span><br><span class="line">    NearBy: &#123;</span><br><span class="line">        screen: NearByScreen,</span><br><span class="line">        navigationOptions: &#123;</span><br><span class="line">            drawerLabel : &apos;附近&apos;,</span><br><span class="line">            drawerIcon : (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class="line">                &lt;TabBarItem</span><br><span class="line">                    tintColor=&#123;tintColor&#125;</span><br><span class="line">                    focused=&#123;focused&#125;</span><br><span class="line">                    normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_merchant_2x.png&apos;)&#125;</span><br><span class="line">                    selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_merchant_selected_2x.png&apos;)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            ),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    Mine: &#123;</span><br><span class="line">        screen: MineScreen,</span><br><span class="line">        navigationOptions: &#123;</span><br><span class="line">            drawerLabel : &apos;我的&apos;,</span><br><span class="line">            drawerIcon : (&#123;focused, tintColor&#125;) =&gt; (</span><br><span class="line">                &lt;TabBarItem</span><br><span class="line">                    tintColor=&#123;tintColor&#125;</span><br><span class="line">                    focused=&#123;focused&#125;</span><br><span class="line">                    normalImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_mine_2x.png&apos;)&#125;</span><br><span class="line">                    selectedImage=&#123;require(&apos;./img/tabbar/pfb_tabbar_mine_selected_2x.png&apos;)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            ),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const DrawerNavigatorConfigs = &#123;</span><br><span class="line">    initialRouteName: &apos;Home&apos;,</span><br><span class="line">    tabBarComponent: TabBarBottom,</span><br><span class="line">    tabBarPosition: &apos;bottom&apos;,</span><br><span class="line">    lazy: true,</span><br><span class="line">    tabBarOptions: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">const Drawer = DrawerNavigator(DrawerRouteConfigs, DrawerNavigatorConfigs);</span><br><span class="line">const StackRouteConfigs = &#123;</span><br><span class="line">    Drawer: &#123;</span><br><span class="line">        screen: Drawer,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const StackNavigatorConfigs = &#123;</span><br><span class="line">    initialRouteName: &apos;Drawer&apos;,</span><br><span class="line">    navigationOptions: &#123;</span><br><span class="line">        title: &apos;标题&apos;,</span><br><span class="line">        headerStyle: &#123;backgroundColor: &apos;#5da8ff&apos;&#125;,</span><br><span class="line">        headerTitleStyle: &#123;color: &apos;#333333&apos;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const Navigator = StackNavigator(StackRouteConfigs, StackNavigatorConfigs);</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-71504dd56a5ccaa5.gif?imageMogr2/auto-orient/strip" alt=""></p>
<hr>
<p>源码：<a href="https://gitee.com/xiaojianjun/DD.git" target="_blank" rel="noopener">https://gitee.com/xiaojianjun/DD.git</a> （index20.js、index21.js、index22.js）</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://reactnavigation.org/docs/" target="_blank" rel="noopener">https://reactnavigation.org/docs/</a><br><a href="http://www.guiyongdong.com/2017/05/20/ReactNative%E5%AF%BC%E8%88%AA%E6%96%B0%E5%AE%A0%E5%84%BFreact-navigation/" target="_blank" rel="noopener">ReactNative导航新宠儿react-navigation</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/10/React-Native-——-flex（弹性布局）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaoyanger0825">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaoyanger0825">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/10/React-Native-——-flex（弹性布局）/" itemprop="url">React Native —— flex（弹性布局）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-10T23:14:56+08:00">
                2017-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React-Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>flex，是flexible box的简称，意为弹性布局，在RN中是用来描述子组件在父组件中的对齐方式和相对位置，使其能够适应不同的屏幕，为界面布局带来更大的灵活性。</p>
<p>flex布局由flex container 和flex item组成。flex container分为主轴（main axis）和交叉轴（across axis）。主轴默认是竖直方向。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-517b49c48be19b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>flex为弹性容器的属性，在css3中由flex-grow、flex-shrink、flex-basis三个属性组合起来，其中后面两个是可选参数。在RN中<code>flex</code>默认为<code>flexGrow</code>属性。</p>
<ul>
<li>flexGrow 元素主轴尺寸占当前容器主轴尺寸的比重，默认值为0。</li>
</ul>
<h4 id="flexDirection"><a href="#flexDirection" class="headerlink" title="flexDirection"></a>flexDirection</h4><p><code>flexDirection</code>属性为主轴方向，取值为<code>column</code>、<code>column-reverse</code>、<code>row</code>、<code>row-reverse</code>。默认值为<code>column</code>。</p>
<ul>
<li>column 竖直方向，起点在顶部，子组件从上到下排列。</li>
<li>column-reverse 竖直方向，起点在底部，子组件从下到上排列。</li>
<li>row 水平方向，起点在左侧，子组件从左到右排列。</li>
<li>row-reverse 水平方向，起点在右侧，子组件从右到左排列。</li>
</ul>
<h4 id="flexWrap"><a href="#flexWrap" class="headerlink" title="flexWrap"></a>flexWrap</h4><p>flexWrap表示沿主轴方向放不下是否需要换行。取值为：<code>wrap</code>、<code>nowrap</code>，默认值为<code>wrap</code>。</p>
<ul>
<li>wrap 主轴方向放不下要换行。</li>
<li>nowrap 主轴方向放不下不换行。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-9a87feb9851eaffa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexWrap属性值对比图（其中`flexDirection: &#39;row&#39;`）"></p>
<h4 id="justifyContent"><a href="#justifyContent" class="headerlink" title="justifyContent"></a>justifyContent</h4><p>justifyContent表示容器中的子组件在主轴方向上的对齐方式，取值为<code>flex-start</code>、<code>flex-end</code>、<code>center</code>、<code>space-between</code>、<code>space-around</code>，默认值为<code>flex-start</code>。</p>
<ul>
<li>flex-start 在主轴方向上和主轴的起点对齐。</li>
<li>flex-end 在主轴方向上和主轴的终点对齐。</li>
<li>center 在主轴方向上居中对齐。</li>
<li>space-between 在主轴方向上两端对齐，每个item的间隔相等，第一个item和主轴起点、最后一个item和主轴终点没有间隔。</li>
<li>space-around  在主轴方向上分散对齐，每个item的两边都有相同的间隔。主轴起点和终点与邻近的两个item的间隔只有中间item之间的间隔的一半。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-0a6619ed589c1b23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="justifyContent属性值对比图（其中`flexDirection: &#39;row&#39;`）"></p>
<h4 id="alignItems"><a href="#alignItems" class="headerlink" title="alignItems"></a>alignItems</h4><p>alignItems表示容器中子组件在交叉轴方向上的对齐方式，取值为：<code>flex-start</code>、<code>flex-end</code>、<code>center</code>、<code>stretch</code>、<code>baseline</code>，默认值为<code>flex-start</code>。</p>
<ul>
<li>flex-start 在交叉轴方向上和交叉轴的起点对齐。</li>
<li>flex-end 在交叉轴方向上和交叉轴的终点对齐。</li>
<li>center 在交叉轴方向上居中对齐。</li>
<li>stretch 如果子组件未设置交叉轴方向的大小或设为auto，将会在交叉轴方向占满整个容器。</li>
<li>baseline 与子组件第一行文字的基线对齐。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-7f96e13f4583ffd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignItems属性值对比图（其中`flexDirection: &#39;row&#39;`）"></p>
<h4 id="alignContent"><a href="#alignContent" class="headerlink" title="alignContent"></a>alignContent</h4><p>alignContent定义了多根轴线时，交叉轴方向的对齐方式，如果只有一根轴，该属性是没有效果的。取值为：<code>flex-start</code>、<code>flex-end</code>、<code>center</code>、<code>space-between</code>、<code>space-around</code>、<code>stretch</code>。默认值为<code>flex-start</code>。</p>
<ul>
<li>flex-start  在交叉轴方向上和交叉轴的起点对齐。</li>
<li>flex-end 在交叉轴方向上和交叉轴的终点对齐。</li>
<li>center 在交叉轴方向上居中对齐。</li>
<li>space-between 与交叉轴两端对齐，轴线之间的间距间隔相等，第一根轴线上的item与交叉轴起点、最后一根轴线上的item与交叉轴终点没有间隔。</li>
<li>space-around   与交叉轴两端对齐，轴线之间的间距间隔相等，第一根轴线上的item与交叉轴起点、最后一根轴线上的item与交叉轴终点的间隔只有中间轴线上item间隔的一半。</li>
<li>stretch 如果子组件未设置交叉轴方向的大小或设为auto，将会在交叉轴方向占满整个容器。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-724ea62db55c6aea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignContent属性值对比图（其中`flexDirection: &#39;row&#39;`）"></p>
<h4 id="alignSelf"><a href="#alignSelf" class="headerlink" title="alignSelf"></a>alignSelf</h4><p>alignSelf定义了子组件自身对齐方式，该属性会覆盖父组件的alignItems属性。取值为：<code>auto</code>、<code>flex-start</code>、<code>flex-end</code>、<code>center</code>、<code>stretch</code>，默认值为<code>auto</code>。</p>
<ul>
<li>auto 继承了它的父组件的 alignItems属性，如父组件没有，则为<code>stretch</code>。</li>
<li>flex-start 子组件在交叉轴方向与交叉轴起点对齐。</li>
<li>flex-end 子组件在交叉轴方向与交叉轴终点对齐。</li>
<li>center 子组件在交叉轴方向居中对齐。</li>
<li>stretch 如果没有在交叉轴方向没有设置大小，则会拉伸在交叉轴方向占满整个容器。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1801191-c9028f76ba22edb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="alignSelf属性值对比图（其中父组件`flexDirection: &#39;row&#39;`）"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="xiaoyanger0825" />
            
              <p class="site-author-name" itemprop="name">xiaoyanger0825</p>
              <p class="site-description motion-element" itemprop="description">喜欢NBA的Android码农</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/xiaoyanger0825" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="xiaojianjun0825@aliyun.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaoyanger0825</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
